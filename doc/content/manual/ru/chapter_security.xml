<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" []>
<!-- This document was created with Syntext Serna Free. --><chapter id="chapter_security" lang="ru">
  <title>Подсистема безопасности</title>
  <para>Платформа CUBA  включает в себя следующие средства разграничения прав доступа пользователей к информации:
      <itemizedlist>
      <listitem>
        <para>Система назначения пользователям <link linkend="permissions">разрешений</link>, основанная на <link linkend="roles">ролях</link>; при этом набор ролей и разрешений настраивается администратором системы на этапе внедрения.</para>
      </listitem>
      <listitem>
        <para>Иерархическая структура <link linkend="groups">групп доступа</link> с наследованием <link linkend="constraints">ограничений</link>.</para>
      </listitem>
      <listitem>Контроль доступа на следующих уровнях: <itemizedlist>
          <listitem>
            <para>Операции над сущностями предметной области (чтение, создание, изменение, удаление): например, пользователь <userinput>Иванов</userinput> может просматривать документы, но не может создавать, изменять и удалять их.</para>
          </listitem>
          <listitem>
            <para>Атрибуты сущностей (изменение, чтение, запрет): пользователь <userinput>Иванов</userinput> видит все атрибуты документов, кроме суммы.</para>
          </listitem>
          <listitem>
            <para>Доступ к определенным экземплярам сущностей (контроль доступа на уровне строк): пользователь <userinput>Иванов</userinput> видит только те документы, которые были созданы в его отделе.</para>
          </listitem>
        </itemizedlist></listitem>
      <listitem>
        <para>Интеграция с <link linkend="ldap">LDAP</link>  с возможностью реализации технологии единого входа (Single Sign-On) для пользователей <application>Windows</application>.</para>
      </listitem>
    </itemizedlist>
  </para>
  <section id="security_components">
    <title>Компоненты подсистемы безопасности</title>
    <para>Основные компоненты подсистемы безопасности CUBA  приведены на
следующей диаграмме. </para>
    <figure>
      <title>Диаграмма компонентов подсистемы безопасности</title>
      <mediaobject>
        <imageobject>
          <imagedata align="center" fileref="img/Security.png"/>
        </imageobject>
      </mediaobject>
    </figure>
    <para>Рассмотрим их более подробно. </para>
    <para><emphasis>Security management screens</emphasis> - имеющиеся в платформе экраны, с помощью которых администратором системы осуществляется настройка прав доступа <link linkend="users">пользователей</link>.</para>
    <para><emphasis>Login screen</emphasis>  − <link linkend="login_screen">окно входа</link> в систему. В этом окне производится аутентификация пользователя по имени учетной записи и паролю. В базе данных вместо пароля, в целях его безопасности, хранится  хэш.</para>
    <para>После входа пользователя в систему создается объект <link linkend="userSession">UserSession</link> − пользовательская сессия. Это  центральный элемент обеспечения безопасности, объект, ассоциированный с аутентифицированным в данный момент в системе пользователем и содержащий информацию о правах доступа пользователя к данным.</para>
    <para>Процесс входа пользователя в систему подробно описан в разделе <xref linkend="login"/>.</para>
    <para><emphasis>Roles</emphasis> − роли пользователей. <link linkend="roles">Роль</link> - это объект системы, которому с одной стороны сопоставляется набор <link linkend="permissions">разрешений</link>, необходимых для выполнения конкретных функций, а с другой стороны − подмножество пользователей, которые должны иметь эти разрешения. </para>
    <para>Разрешения бывают следующих типов:<itemizedlist>
        <listitem>
          <para><emphasis>Screen Permissions</emphasis> - возможность открытия некоторого экрана.</para>
        </listitem>
        <listitem>
          <para><emphasis>Entity Operation Permissions</emphasis> - возможность совершения операции с некоторой сущностью: чтение, создание,
модификация, удаление. </para>
        </listitem>
        <listitem>
          <para><emphasis>Entity Attribute Permissions</emphasis> - доступ к произвольному атрибуту некоторой сущности: модификация,
только чтение, нет доступа.</para>
        </listitem>
        <listitem>
          <para><emphasis>Specific Permissions</emphasis> - разрешение на некоторую именованную функциональность.</para>
        </listitem>
        <listitem>
          <para><emphasis>UI Permissions</emphasis> - управление доступом к  элементам некоторого экрана.</para>
        </listitem>
      </itemizedlist> </para>
    <para><emphasis>Access Groups</emphasis> - группы доступа пользователей. <link linkend="groups">Группы</link> представляют собой иерархическую структуру, каждый элемент которой задает набор <link linkend="constraints">ограничений</link> (<emphasis>Constraints</emphasis>),  позволяющих контролировать
доступ на уровне отдельных экземпляров (строк таблицы)  некоторой сущности. 
Например, пользователь видит только те документы, которые были созданы в его
отделе.</para>
    <section id="login_screen">
      <title>Окно входа в систему</title>
      <para>Окно входа в систему (Login screen) предназначено для регистрации пользователя путем ввода логина и пароля. </para>
      <para>Логин не чувствителен к регистру вводимых символов.</para>
      <para>Класс экрана в блоке Web Client - <code>LoginWindow</code>, в блоке Desktop Client - <code>LoginDialog</code>. Для расширения функциональности в приложении можно создать собственных наследников этих классов и возвращать соответствующие экземпляры, переопределив:<itemizedlist>
          <listitem>
            <para>для <link linkend="gui_web">веб клиента</link> - метод <code>createLoginWindow()</code> класса <code>com.haulmont.cuba.web.App</code></para>
          </listitem>
          <listitem>
            <para>для <link linkend="gui_desktop">десктоп клиента</link> - метод <code>createLoginDialog()</code> класса <code>com.haulmont.cuba.desktop.App</code>.</para>
          </listitem>
        </itemizedlist></para>
      <para>Управлять отображением флажка <guilabel>Remember Me</guilabel> в веб клиенте можно с помощью свойства приложения <link linkend="cuba.web.rememberMeEnabled">cuba.web.rememberMeEnabled</link>.</para>
      <para>Стандартное окно входа содержит также выпадающий список поддерживаемых системой языков. Отображение списка и его содержимое определяются комбинацией свойств приложения <link linkend="cuba.localeSelectVisible">cuba.localeSelectVisible</link> и <link linkend="cuba.availableLocales">cuba.availableLocales</link>.</para>
    </section>
    <section id="users">
      <title>Пользователи</title>
      <para>Для каждого пользователя системы создается соответствующий экземпляр сущности <code>sec$User</code>. Он содержит уникальный логин, хэш пароля, ссылку на группу доступа, список ролей и другие атрибуты. Управление пользователями осуществляется с помощью экрана <guimenu>Administration</guimenu> -&gt; <guimenu>Users</guimenu>: </para>
      <mediaobject>
        <imageobject>
          <imagedata align="center" fileref="img/user_browser.png"/>
        </imageobject>
      </mediaobject>
      <para>Помимо стандартных действий создания, изменения и удаления записей имеются следующие:<itemizedlist>
          <listitem>
            <para><guibutton>Copy</guibutton> - быстрое создание нового пользователя на основе выбранного. Новый пользователь будет иметь такую же группу доступа и набор ролей. И то и другое можно изменить в появляющемся экране редактирования нового пользователя.</para>
          </listitem>
          <listitem>
            <para><guibutton>Copy settings</guibutton> - позволяет скопировать выбранным пользователям настройки интерфейса, сделанные каким-либо другим пользователем. Настройки интерфейса включают в себя <link linkend="gui_Table_presentations">представления таблиц</link>, положение разделителей контейнеров <link linkend="gui_SplitPanel">SplitPanel</link>, наборы <link linkend="gui_Filter">фильтров</link> и <link linkend="folders_pane">папок поиска</link>.</para>
          </listitem>
          <listitem>
            <para><guibutton>Change password</guibutton> - позволяет администратору системы задать новый пароль выбранному пользователю.</para>
          </listitem>
          <listitem>
            <para><guibutton>Reset passwords</guibutton> - позволяет произвести следующие действия над выбранными пользователями:<itemizedlist>
                <listitem>
                  <para>Если в появляющемся окне <guilabel>Reset passwords for selected users</guilabel> не включать флажок <guilabel>Generate new passwords</guilabel>, то пользователям будет установлен признак <guilabel>Change password at next logon</guilabel>. При следующем успешном логине пользователя ему будет предложено сменить свой пароль.</para>
                </listitem>
                <listitem>
                  <para>Если в  окне <guilabel>Reset passwords for selected users</guilabel> включить флажок <guilabel>Generate new passwords</guilabel>, то для выбранных пользователей будут сгенерированы и показаны новые случайные пароли. Список новых паролей можно выгрузить в формат XLS, и например, разослать пользователям. Кроме того, для каждого пользователя будет установлен признак <guilabel>Change password at next logon</guilabel>, что делает сгенерированный пароль одноразовым.</para>
                </listitem>
                <listitem>
                  <para>Если в дополнение к <guilabel>Generate new passwords</guilabel> включить флажок <guilabel>Send emails with generated passwords</guilabel>, то новые одноразовые пароли не будут показаны администратору, а автоматически разосланы соответствующим пользователям на их адреса email.</para>
                </listitem>
              </itemizedlist></para>
          </listitem>
        </itemizedlist></para>
      <para>Рассмотрим экран редактирования пользователя:<mediaobject>
          <imageobject>
            <imagedata align="center" fileref="img/user_editor.png"/>
          </imageobject>
        </mediaobject></para>
      <itemizedlist>
        <listitem>
          <para><guilabel>Login</guilabel> - обязательный к заполнению уникальный логин пользователя.</para>
        </listitem>
        <listitem>
          <para><guilabel>Group</guilabel> - <link linkend="groups">группа доступа</link>.</para>
        </listitem>
        <listitem>
          <para><guilabel>Last name</guilabel>, <guilabel>First name</guilabel>, <guilabel>Middle name</guilabel> - части полного имени пользователя.</para>
        </listitem>
        <listitem>
          <para><guilabel>Name</guilabel> - полное имя пользователя. Автоматически формируется на основе вводимых частей (Last, First, Middle) и правила, заданного свойством приложения <link linkend="cuba.user.fullNamePattern">cuba.user.fullNamePattern</link>. Может быть произвольно изменено вручную.</para>
        </listitem>
        <listitem>
          <para><guilabel>Position</guilabel> - должность.</para>
        </listitem>
        <listitem>
          <para><guilabel>Language</guilabel> - язык интерфейса, устанавливаемый для пользователя, если возможность выбирать язык  при входе в систему отключена при помощи свойства приложения <link linkend="cuba.localeSelectVisible">cuba.localeSelectVisible</link>.</para>
        </listitem>
        <listitem>
          <para><guilabel>Email</guilabel> - адрес email.</para>
        </listitem>
        <listitem>
          <para><guilabel>Active</guilabel> - если данный флаг не установлен, то пользователь не может войти в систему.</para>
        </listitem>
        <listitem>
          <para><guilabel>Permitted IP Mask</guilabel> - маска разрешенных IP-адресов, с которых возможен вход в систему.</para>
          <para>Маска представляет собой список адресов через запятую. Поддерживаются как адреса формата IPv4, так и адреса формата IPv6. В первом случае адрес должен состоять из четырех чисел, разделенных точками, при этом любая часть вместо числа может содержать знак &quot;*&quot;, что означает &quot;любое число&quot;. Адрес в формате IPv6 представляет собой восемь групп по четыре шестнадцатеричные цифры, разделенных двоеточием. Любая группа также может быть заменена знаком &quot;*&quot;. </para>
          <para>Маска может содержать адреса только одного формата. Наличие адресов формата IPv4 и IPv6 одновременно недопустимо.</para>
          <para>Пример: <code>192.168.*.*</code></para>
        </listitem>
        <listitem>
          <para><guilabel>Roles</guilabel> - список <link linkend="roles">ролей</link> пользователя.</para>
        </listitem>
        <listitem>
          <para><guilabel>Substituted Users</guilabel> - список <link linkend="user_substitution">замещаемых</link> пользователей.</para>
        </listitem>
      </itemizedlist>
      <section id="user_substitution">
        <title>Замещение пользователей</title>
        <para>Администратор системы может дать возможность пользователю <emphasis>замещать</emphasis> другого пользователя. При этом у замещающего пользователя <link linkend="userSession">сессия</link> не меняется, а подменяется набор <link linkend="roles">ролей</link>, <link linkend="constraints">ограничений</link> и <link linkend="session_attr">атрибутов</link>. Все эти параметры текущий  пользователь получает от замещаемого пользователя. </para>
        <tip>
          <para>В прикладном коде для получения текущего пользователя рекомендуется использовать метод <code>UserSession.getCurrentOrSubstitutedUser()</code> возвращающий либо замещаемого пользователя, либо пользователя, выполнившего логин (если замещения в данный момент нет).</para>
          <para>В то же время механизмы аудита платформы (атрибуты <code>createdBy</code> и <code>updatedBy</code>, <link linkend="entity_log">журнал изменений</link> и <link linkend="entity_snapshots">снимки</link> сущностей) всегда регистрируют пользователя, который произвел логин, а не замещаемого пользователя.</para>
        </tip>
        <para>Если пользователь имеет замещаемых пользователей, то в правом верхнем углу главного окна приложения вместо простой надписи с именем текущего пользователя отображается выпадающий список:<mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/user_subst_select.png"/>
            </imageobject>
          </mediaobject></para>
        <para>При выборе другого пользователя в этом списке все открытые экраны будут закрыты, и произойдет замещение. После этого метод <code>UserSession.getUser()</code> по прежнему будет возвращать пользователя, выполнившего логин в систему, а метод <code>UserSession.getSubstitutedUser()</code> - замещенного пользователя. Если замещения нет, метод <code>UserSession.getSubstitutedUser()</code> возвращает <code>null</code>. </para>
        <para>Управление замещаемыми пользователями производится с помощью таблицы <guilabel>Substituted Users</guilabel> экрана редактирования пользователя. Рассмотрим экран добавления замещаемого пользователя:<mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/user_subst_edit.png"/>
            </imageobject>
          </mediaobject></para>
        <itemizedlist>
          <listitem>
            <para><guilabel>User</guilabel> - текущий редактируемый пользователь. Он будет замещать другого пользователя.</para>
          </listitem>
          <listitem>
            <para><guilabel>Substituted user</guilabel> - замещаемый пользователь.</para>
          </listitem>
          <listitem>
            <para><guilabel>Start date</guilabel>, <guilabel>End date</guilabel> - необязательный период замещения. Вне периода замещение будет недоступным. Если период не указан, замещение доступно, пока не удалена данная запись таблицы.</para>
          </listitem>
        </itemizedlist>
      </section>
    </section>
    <section id="permissions">
      <title>Разрешения</title>
      <para><emphasis>Разрешение</emphasis> определяет право пользователя на какой-либо объект или функциональность системы: экран, операцию над сущностью и так далее. Разрешение в зависимости от своего значения может как дать пользователю право на объект, так и отобрать его  (то есть по сути являться <emphasis>запрещением</emphasis>).</para>
      <tip>
        <para>Если явного разрешения на объект не установлено, пользователь имеет право на этот  объект.</para>
      </tip>
      <para>Разрешения представляются экземплярами сущности <code>sec$Permission</code> и содержат следующие атрибуты:<itemizedlist>
          <listitem>
            <para><code>type</code> - тип разрешения: определяет, на какой тип объектов накладывается разрешение.</para>
          </listitem>
          <listitem>
            <para><code>target</code> - конкретный объект разрешения. Формат представления объекта зависит от типа разрешения.</para>
          </listitem>
          <listitem>
            <para><code>value</code> - значение разрешения. Диапазон значений зависит от типа разрешения.</para>
          </listitem>
        </itemizedlist></para>
      <para>Рассмотрим типы разрешений:<itemizedlist>
          <listitem>
            <para><code>PermissionType.SCREEN</code> - разрешение на экран системы.</para>
            <para>В атрибуте <code>target</code> указывается идентификатор экрана, атрибут <code>value</code> может иметь значения 0 или 1 (экран запрещен или разрешен соответственно).</para>
            <para>Права на экраны проверяются при построении главного меню системы и при каждом вызове методов <code>openWindow()</code>, <code>openEditor()</code>, <code>openLookup()</code> интерфейса <link linkend="abstractFrame">IFrame</link>.</para>
            <para>Для проверки права на экран в прикладном коде используйте метод <code>isScreenPermitted()</code> интерфейса <link linkend="security">Security</link>.</para>
          </listitem>
          <listitem>
            <para><code>PermissionType.ENTITY_OP</code> - разрешение на операцию c сущностью.</para>
            <para>В атрибуте <code>target</code> указывается имя сущности и через символ &quot;:&quot; имя операции: <code>create</code>, <code>read</code>, <code>update</code>, <code>delete</code>. Например: <userinput>library$Book:delete</userinput>. Атрибут <code>value</code> может иметь значения 0 или 1 (операция запрещена или разрешена соответственно).</para>
            <para>Права на операции с сущностью проверяются при работе с данными через <link linkend="dataService">DataService и DataWorker</link>, а также в связанных с данными <link linkend="gui_components">визуальных компонентах</link> и  <link linkend="standard_actions">стандартных действиях</link> со списками сущностей. В результате права на операции оказывают влияние на поведение клиентских блоков и <link linkend="rest_api">REST API</link>. При работе с данными непосредственно на Middleware через <link linkend="entityManager">EntityManager</link> права не проверяются.</para>
            <para>Для проверки права на операцию c сущностью в прикладном коде используйте метод <code>isEntityOpPermitted()</code> интерфейса <link linkend="security">Security</link>.</para>
          </listitem>
          <listitem>
            <para><code>PermissionType.ENTITY_ATTR</code> - разрешение на атрибут сущности.</para>
            <para>В атрибуте <code>target</code> указывается имя сущности и через символ &quot;:&quot; имя арибута, например: <userinput>library$Book:name</userinput>. Атрибут <code>value</code> может иметь значения 0, 1 или 2 (атрибут скрыт, только для чтения, или полностью разрешен соответственно).</para>
            <para>Права на атрибуты  сущностей проверяются только  в связанных с данными <link linkend="gui_components">визуальных компонентах</link> и <link linkend="rest_api">REST API</link>.</para>
            <para>Для проверки права на атрибут сущности в прикладном коде используйте метод <code>isEntityAttrPermitted()</code> интерфейса <link linkend="security">Security</link>.</para>
          </listitem>
          <listitem>
            <para><code>PermissionType.SPECIFIC</code> - разрешение на произвольную именованную функциональность.</para>
            <para>В атрибуте <code>target</code> указывается код функциональности, атрибут <code>value</code> может иметь значения 0 или 1 (запрещено или разрешено соответственно).</para>
            <para>Набор специфических разрешений для данного проекта задается в конфигурационном файле <link linkend="permissions.xml">permissions.xml</link>.</para>
            <para>Пример использования:<programlisting language="java">@Inject
private Security security;

private void calculateBalance() {
    if (!security.isSpecificPermitted(&quot;myapp.calculateBalance&quot;))
        return;
    ...
}</programlisting></para>
          </listitem>
          <listitem>
            <para><code>PermissionType.UI</code> - разрешение на произвольный компонент экрана.</para>
            <para>В атрибуте <code>target</code> указывается идентификатор экрана и через символ &quot;:&quot; путь к компоненту. Описание формата пути см. в следующем разделе.</para>
          </listitem>
        </itemizedlist></para>
      <tip>
        <para>Для проверки разрешений вместо непосредственного использования методов класса <code>UserSession</code> рекомендуется использовать аналогичные методы интерфейса <link linkend="security">Security</link>, принимающие во внимание возможное <link linkend="entity_extension">расширение</link> сущностей.</para>
      </tip>
    </section>
    <section id="roles">
      <title>Роли</title>
      <para>Роль объединяет набор <link linkend="permissions">разрешений</link>, которые могут быть предоставлены пользователю.</para>
      <para>Пользователь может иметь несколько ролей. При этом он получает логическую сумму (ИЛИ) прав на некоторый объект от всех ролей, которые у него есть. Например, если пользователю назначены роли A,  B и C, роль A запрещает X,  роль B разрешает X, роль C не устанавливает явных разрешений на X, то в итоге X будет разрешен.</para>
      <para>Если ни одна роль пользователя не определяет явно разрешения на объект, то пользователь имеет право на данный объект. Таким образом, пользователь имеет права на все объекты, на которые либо ни одна роль явно не определяет разрешения, либо хотя бы одна роль определяет, что право есть.</para>
      <warning>
        <para>Если пользователю дать единственную роль без явно установленных разрешений, или не давать никаких ролей вообще, то у него будут все права на все объекты. </para>
      </warning>
      <para>Список ролей отображается экраном <guimenu>Administration</guimenu> -&gt; <guimenu>Roles</guimenu>. Здесь помимо стандартных действий создания, изменения и удаления записей имеется кнопка <guibutton>Assign to users</guibutton>, позволяющая назначить выбранную роль сразу нескольким пользователям. </para>
      <para>Рассмотрим экран редактирования роли. В верхней его части отображаются атрибуты роли: </para>
      <mediaobject>
        <imageobject>
          <imagedata align="center" fileref="img/role_attributes.png"/>
        </imageobject>
      </mediaobject>
      <itemizedlist>
        <listitem>
          <para><guilabel>Name</guilabel> - обязательное уникальное имя (или код) роли. Не может быть изменено после создания.</para>
        </listitem>
        <listitem>
          <para><guilabel>Localized name</guilabel> - понятное пользователю название роли.</para>
        </listitem>
        <listitem>
          <para><guilabel>Description</guilabel> - произвольное описание роли.</para>
        </listitem>
        <listitem>
          <para><guilabel>Type</guilabel> - тип роли, может быть следующим:<itemizedlist>
              <listitem>
                <para><guilabel>Standard</guilabel> - в роли данного типа действуют только явно назначенные разрешения.</para>
              </listitem>
              <listitem>
                <para><guilabel>Super</guilabel> - роль данного типа автоматически дает все разрешения. Это удобно для назначения администраторов системы, так как она отменяет все запрещения, установленные другими ролями. </para>
              </listitem>
              <listitem>
                <para><guilabel>Read-only</guilabel> - роль данного типа автоматически отнимает разрешения на следующие операции с сущностями: CREATE, UPDATE, DELETE. Таким образом, пользователь с такой ролью может только читать данные, и не может их изменять (если какая-либо другая роль этого пользователя не разрешает явно эти операции).</para>
              </listitem>
              <listitem>
                <para><guilabel>Denying</guilabel> - запрещающая роль. Роль данного типа автоматически отнимает разрешения на все объекты, кроме атрибутов сущностей. Чтобы пользователь с данной ролью мог что-то увидеть или изменить в системе, ему нужно назначить дополнительно другую роль, явно дающую нужные права.</para>
              </listitem>
            </itemizedlist></para>
          <para>Роли всех типов могут иметь явно установленные разрешения, например в <guilabel>Read-only</guilabel> роль можно добавить разрешения на модификацию некоторых сущностей. Однако для роли <guilabel>Super</guilabel> явная установка каких-либо запрещений не имеет смысла, так как наличие роли данного типа в любом случае отменяет все запрещения.</para>
        </listitem>
        <listitem>
          <para><guilabel>Default role</guilabel> - признак роли по умолчанию. Все роли с данным признаком автоматически назначаются вновь создаваемым пользователям.</para>
        </listitem>
      </itemizedlist>
      <para>Ниже отображаются вкладки управления разрешениями.<itemizedlist>
          <listitem>
            <para>Вкладка <guilabel>Screens</guilabel> - разрешения на экраны системы:<mediaobject>
                <imageobject>
                  <imagedata align="center" fileref="img/role_screen_permissions.png"/>
                </imageobject>
              </mediaobject></para>
            <para>Дерево в левой части вкладки отражает структуру главного меню системы. Последним элементом дерева является <guilabel>Other screens</guilabel>, внутри которого сосредоточены экраны, не включенные в главное меню (например, экраны редактирования сущностей).</para>
          </listitem>
          <listitem>
            <para>Вкладка <guilabel>Entities</guilabel> - разрешения на операции с сущностями:<mediaobject>
                <imageobject>
                  <imagedata align="center" fileref="img/role_entity_permissions.png"/>
                </imageobject>
              </mediaobject></para>
            <para>При переходе на данную вкладку изначально включен флажок <guilabel>Assigned only</guilabel>, поэтому в таблице отображаются только сущности, для которых в данной роли уже есть явные разрешения. Поэтому для новой роли таблица пуста. Для установки разрешений снимите флажок <guilabel>Assigned only</guilabel> и нажмите <guibutton>Apply</guibutton>. Список сущностей можно фильтровать, вводя в поле <guilabel>Entity</guilabel> любую часть имени сущности и нажимая <guibutton>Apply</guibutton>.</para>
            <para>Установив флажок <guilabel>System level</guilabel>, можно выбрать системную сущность, помеченную аннотацией <code>@SystemLevel</code>. По умолчанию такие сущности не показываются в таблице.</para>
          </listitem>
          <listitem>
            <para>Вкладка <guilabel>Attributes</guilabel> - разрешения на атрибуты сущностей:<mediaobject>
                <imageobject>
                  <imagedata align="center" fileref="img/role_attr_permissions.png"/>
                </imageobject>
              </mediaobject></para>
            <para>В таблице сущностей в колонке <guilabel>Permissions</guilabel> отображается список атрибутов, для которых явно указаны разрешения. Зеленым цветом обозначено разрешение <guilabel>modify</guilabel> (полный доступ), синим цветом - <guilabel>read-only</guilabel> (только чтение), красным - <guilabel>hide</guilabel> (атрибут скрыт).</para>
            <para>Управление списком сущностей аналогично описанному для вкладки <guilabel>Entities</guilabel>.</para>
          </listitem>
          <listitem>
            <para>Вкладка <guilabel>Specific</guilabel> - разрешения на именованную функциональность:<mediaobject>
                <imageobject>
                  <imagedata align="center" fileref="img/role_specific_permissions.png"/>
                </imageobject>
              </mediaobject></para>
            <para>Имена объектов, на которые могут быть назначены специфические разрешения, определяются в конфигурационном файле <link linkend="permissions.xml">permissions.xml</link> проекта.</para>
          </listitem>
          <listitem>
            <para>Вкладка <guilabel>UI</guilabel> - разрешения на UI-компоненты экранов:<mediaobject>
                <imageobject>
                  <imagedata align="center" fileref="img/role_ui_permissions.png"/>
                </imageobject>
              </mediaobject></para>
            <para>Разрешения данного типа дают возможность ограничить доступ к любому компоненту экрана, в том числе не связанному с данными (например, к контейнеру). Для создания таких разрешений необходимо знать идентификаторы компонентов, а значит, иметь доступ к исходному коду экранов.</para>
            <para>Для создания ограничения выберите нужный экран в выпадающем списке <guilabel>Screen</guilabel>, задайте путь к компоненту в поле <guilabel>Component</guilabel>, и нажмите <guibutton>Add</guibutton>. После этого установите режим доступа к выбранному компоненту в панели <guilabel>Permissions</guilabel>.</para>
            <para>Правила формирования пути к компоненту:<itemizedlist>
                <listitem>
                  <para>Если компонент принадлежит экрану, указывается просто  идентификатор компонента <code>id</code>.</para>
                </listitem>
                <listitem>
                  <para>Если компонент принадлежит фрейму, вложенному в экран, то сначала указывается идентификатор фрейма, а затем через точку идентификатор компонента внутри фрейма.</para>
                </listitem>
                <listitem>
                  <para>Если необходимо установить разрешение для вкладки <link linkend="gui_TabSheet">TabSheet</link> или поля <link linkend="gui_FieldGroup">FiledGroup</link>, то сначала указывается идентификатор компонента, а затем в квадратных скобках идентификатор соответственно вкладки или поля.</para>
                </listitem>
              </itemizedlist></para>
          </listitem>
        </itemizedlist></para>
    </section>
    <section id="groups">
      <title>Группы доступа</title>
      <para>Группы доступа позволяют организовывать пользователей в иерархическую структуру для установки <link linkend="constraints">ограничений</link>  и для присвоения произвольных <link linkend="session_attr">атрибутов сессии</link>.</para>
      <para>Пользователь может быть причислен только к одной группе, однако он получит список ограничений и атрибутов сессии от всех групп вверх по иерархии.</para>
      <para>Управление группами доступа осуществляется в экране <guimenu>Administration</guimenu> -&gt; <guimenu>Access Groups</guimenu>:<mediaobject>
          <imageobject>
            <imagedata align="center" fileref="img/group_users.png"/>
          </imageobject>
        </mediaobject></para>
      <section id="constraints">
        <title>Ограничения</title>
        <para>Ограничения (Constraints) дают возможность ограничить доступ к определенным экземплярам сущностей (записям таблиц).</para>
        <para>Ограничения задаются для класса сущности с помощью фрагментов выражений на языке <link linkend="jpql">JPQL</link>. Эти фрагменты затем подставляются в запросы каждый раз при выборке списка экземпляров данной сущности, тем самым фильтруя их.</para>
        <para>Пользователь получает список ограничений от всех групп начиная со своей и вверх по иерархии. Тем самым реализуется принцип:  чем ниже пользователь в иерархии групп, тем больше у него ограничений.</para>
        <para>Для создания ограничения в экране <guimenu>Access Groups</guimenu> выберите группу, на которую нужно наложить ограничение, перейдите на вкладку <guilabel>Constraints</guilabel> и нажмите <guibutton>Create</guibutton>:<mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/constraint_edit.png"/>
            </imageobject>
          </mediaobject></para>
        <para>Далее выберите сущность в выпадающем списке <guilabel>Entity Name</guilabel> и задайте ограничение в полях <guilabel>Join Clause</guilabel> и <guilabel>Where Clause</guilabel>.<tip>
            <para>Редактор JPQL в полях <guilabel>Join Clause</guilabel> и <guilabel>Where Clause</guilabel> поддерживает автодополнение имен сущностей и их атрибутов. Для вызова автодополнения нажмите <keycap>Ctrl+Space</keycap>. Если вызов произведен после точки, будет выведен список атрибутов сущности, соответствующей контексту, иначе - список всех сущностей модели данных.</para>
          </tip></para>
        <para>Правила формирования ограничения:<itemizedlist>
            <listitem>
              <para>В качестве алиаса извлекаемой сущности необходимо использовать строку <code>{E}</code>. При выполнении запросов она будет заменена на реальный алиас, заданный в запросе.</para>
            </listitem>
            <listitem>
              <para>В параметрах JPQL  можно использовать следующие предопределенные константы:<itemizedlist>
                  <listitem>
                    <para><literal>session$userLogin</literal> − имя учетной записи текущего пользователя (в случае <link linkend="user_substitution">замещения</link> − имя учетной записи замещаемого пользователя).</para>
                  </listitem>
                  <listitem>
                    <para><literal>session$userId</literal> − ID текущего пользователя (в случае замещения − ID замещаемого пользователя).</para>
                  </listitem>
                  <listitem>
                    <para><literal>session$userGroupId</literal> − ID группы текущего пользователя (в случае замещения − ID группы замещаемого пользователя).</para>
                  </listitem>
                  <listitem>
                    <para><literal>session$XYZ</literal> − произвольный атрибут текущей <link linkend="userSession">пользовательской сессии</link>, где XYZ − имя атрибута.</para>
                  </listitem>
                </itemizedlist></para>
            </listitem>
            <listitem>
              <para>Содержимое поля <guilabel>Where Clause</guilabel> добавляется в выражение <code>where</code> запроса по условию <code>and</code> (И). Само слово <code>where</code> писать не нужно, оно будет добавлено автоматически, даже если исходный запрос его не содержал.</para>
            </listitem>
            <listitem>
              <para>Содержимое поля <guilabel>Join Clause</guilabel> добавляется в выражение <code>from</code> запроса. Оно должно начинаться с запятой или слов <code>join</code> или <code>left join</code>.</para>
            </listitem>
          </itemizedlist></para>
        <para>Простейший пример ограничения приведен на рисунке выше: пользователи с данным ограничением будут видеть только те экземпляры сущности <code>library$BookPublication</code>, которые они создали сами. </para>
      </section>
      <section id="session_attr">
        <title>Атрибуты сессии</title>
        <para>Группа доступа может определять список атрибутов <link linkend="userSession">сессии</link> для пользователей, входящих в данную группу. Эти атрибуты можно использовать при настройке <link linkend="constraints">ограничений</link>. Кроме того, на этапе разработки в прикладной код системы можно заложить анализ наличия некоторых атрибутов сессии, и тем самым управлять поведением готовой системы для конкретных групп пользователей на этапе эксплуатации. </para>
        <para>В пользовательскую сессию при входе в систему будут помещены все атрибуты, заданные для группы, в которой находится пользователь, и для всех родительских групп вверх по иерархии. При этом если атрибут встречается в иерархии групп несколько раз, значение он получит от самой верхней группы, то есть переопределение значений атрибутов на нижнем уровне невозможно. При попытке переопределения в <link linkend="logging_setup_tomcat">журнал</link>  сервера будет выведено сообщение с уровнем <code>WARN</code>. </para>
        <para>Для создания атрибута в экране <guimenu>Access Groups</guimenu> выберите группу, перейдите на вкладку <guilabel>Session Attributes</guilabel> и нажмите <guibutton>Create</guibutton>:<mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/session_attr_edit.png"/>
            </imageobject>
          </mediaobject></para>
        <para>В данном экране необходимо задать уникальное имя атрибута, тип данных и значение. </para>
        <para>Получить атрибут <link linkend="userSession">сессии</link> в коде приложения можно следующим способом:<programlisting language="java">@Inject
private UserSessionSource userSessionSource;
...
Integer accessLevel = userSessionSource.getUserSession().getAttribute(&quot;accessLevel&quot;);</programlisting></para>
        <para>Использовать атрибут в <link linkend="constraints">ограничениях</link> можно, указав его в параметре JPQL с префиксом <code>session$</code>:<programlisting>{E}.accessLevel = :session$accessLevel</programlisting></para>
      </section>
    </section>
    <section id="ldap">
      <title>Интеграция с LDAP</title>
      <para>Интеграция CUBA-приложения c LDAP позволяет решить две задачи:<orderedlist>
          <listitem>
            <para>Хранить пароли пользователей и управлять ими централизованно в базе данных LDAP.</para>
          </listitem>
          <listitem>
            <para>Для пользователей компьютеров, входящих в домен Windows, выполнять логин в приложение без ввода имени и пароля (то есть организовывать Single Sign-On).</para>
          </listitem>
        </orderedlist></para>
      <para>Для входа в систему пользователь должен быть заведен в приложении с нужными свойствами и правами. Пароль рекомендуется не указывать, тогда пользователь сможет войти в систему только с паролем из LDAP. Сначала производится попытка аутентифицировать пользователя через LDAP, а если она не удалась, то обычным способом через хранимый в базе данных приложения хэш пароля. Поэтому если для некоторого пользователя пароль   в приложении задан, он сможет войти в систему с этим паролем, даже если в LDAP такого пользователя нет или у него там другой пароль.</para>
      <para>Взаимодействие CUBA-приложения с LDAP осуществляется через интерфейс <code>CubaAuthProvider</code>. Платформа содержит единственную реализацию данного интерфейса - <code>LdapAuthProvider</code>, предназначенную для решения первой задачи. Для расширенной интеграции с Active Directory и обеспечения Single Sign-On можно использовать библиотеку <application>Jespa</application> и соответствующую имплементацию <code>CubaAuthProvider</code>, которая описана в  <xref linkend="jespa"/>. При необходимости можно также создать собственный класс имплементации <code>CubaAuthProvider</code> и использовать его, установив следующие свойства приложения:<programlisting>cuba.web.useActiveDirectory = true
cuba.web.activeDirectoryAuthClass = com.company.sample.web.MyAuthProvider</programlisting></para>
      <section id="ldap_basic">
        <title>Базовая интеграция с Active Directory</title>
        <para>Класс <code>LdapAuthProvider</code> используется по умолчанию при включенном свойстве приложения <code>cuba.web.useActiveDirectory</code>. В этом случае для аутентификации пользователей используется библиотека <application>Spring LDAP</application>.</para>
        <para>Для настройки интеграции используются следующие свойства приложения блока Web Client:<itemizedlist>
            <listitem>
              <para><code>cuba.web.ldap.urls</code> - URL сервера Active Directory</para>
            </listitem>
            <listitem>
              <para><code>cuba.web.ldap.base</code> - база поиска имен пользователей</para>
            </listitem>
            <listitem>
              <para><code>cuba.web.ldap.user</code> - значение атрибута <code>sAMAccountName</code> пользователя, имеющего право на чтение информации из Active Directory</para>
            </listitem>
            <listitem>
              <para><code>cuba.web.ldap.password</code> - пароль пользователя, заданного свойством <code>cuba.web.ldap.user</code>.</para>
            </listitem>
          </itemizedlist></para>
        <para>Пример содержимого файла <link linkend="app_properties_files">local.app.properties</link> блока Web Client:<programlisting>cuba.web.useActiveDirectory = true
cuba.web.ldap.urls = ldap://192.168.1.1:389
cuba.web.ldap.base = ou=Employees,dc=mycompany,dc=com
cuba.web.ldap.user = myuser
cuba.web.ldap.password = mypassword</programlisting></para>
      </section>
      <section id="jespa">
        <title>Настройка аутентификации с использованием Jespa</title>
        <para><application>Jespa</application> − библиотека для <application>Java</application>, обеспечивающая расширенную интеграцию между службой каталогов <application>Active Directory</application> и Java-приложениями по протоколу <ulink url="http://en.wikipedia.org/wiki/NTLMv2#NTLMv2">NTLMv2</ulink>. Подробно о библиотеке см. <ulink url="http://www.ioplex.com">http://www.ioplex.com</ulink>. </para>
        <section>
          <title>Подключение библиотеки</title>
          <para>Загрузите библиотеку с сайта <ulink url="http://www.ioplex.com">http://www.ioplex.com</ulink> и разместите JAR в каком-либо  <link linkend="artifact_repository">репозитории</link>, зарегистрированном в вашем скрипте  сборки <link linkend="build.gradle">build.gradle</link>. Это может быть <code>mavenLocal()</code> или репозиторий вашей организации.</para>
          <para>В файле <filename>build.gradle</filename> в секции конфигурации модуля <structname>web</structname> добавьте зависимость:<programlisting>configure(webModule) {
    ...
    dependencies {
        compile(&apos;com.company.thirdparty:jespa:1.1.17&apos;)
    ...    </programlisting></para>
          <para>Создайте в модуле <structname>web</structname> класс реализации интерфейса <code>CubaAuthProvider</code>:<programlisting language="java">package com.company.sample.web;

import com.haulmont.cuba.core.global.AppBeans;
import com.haulmont.cuba.core.global.Configuration;
import com.haulmont.cuba.core.global.GlobalConfig;
import com.haulmont.cuba.core.global.Messages;
import com.haulmont.cuba.core.sys.AppContext;
import com.haulmont.cuba.security.global.LoginException;
import com.haulmont.cuba.web.auth.ActiveDirectoryHelper;
import com.haulmont.cuba.web.auth.CubaAuthProvider;
import com.haulmont.cuba.web.auth.DomainAliasesResolver;
import jespa.http.HttpSecurityService;
import jespa.ntlm.NtlmSecurityProvider;
import jespa.security.PasswordCredential;
import jespa.security.SecurityProviderException;
import org.apache.commons.lang.StringUtils;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import javax.inject.Inject;
import javax.servlet.*;
import javax.servlet.http.HttpServletRequest;
import java.io.IOException;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;

public class JespaAuthProvider extends HttpSecurityService implements CubaAuthProvider {

    private static class DomainInfo {
        private String bindStr;
        private String acctName;
        private String acctPassword;

        private DomainInfo(String bindStr, String acctName, String acctPassword) {
            this.acctName = acctName;
            this.acctPassword = acctPassword;
            this.bindStr = bindStr;
        }
    }

    private static Map&lt;String, DomainInfo&gt; domains = new HashMap&lt;&gt;();

    private static String defaultDomain;

    private Log log = LogFactory.getLog(getClass());

    @Inject
    private Configuration configuration;

    @Inject
    private Messages messages;

    @SuppressWarnings(&quot;deprecation&quot;)
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {

        initDomains();

        Map&lt;String, String&gt; properties = new HashMap&lt;&gt;();

        properties.put(&quot;jespa.bindstr&quot;, getBindStr());
        properties.put(&quot;jespa.service.acctname&quot;, getAcctName());
        properties.put(&quot;jespa.service.password&quot;, getAcctPassword());
        properties.put(&quot;jespa.account.canonicalForm&quot;, &quot;3&quot;);
        properties.put(&quot;jespa.log.path&quot;, configuration.getConfig(GlobalConfig.class).getLogDir() + &quot;/jespa.log&quot;);
        properties.put(&quot;http.parameter.anonymous.name&quot;, &quot;anon&quot;);

        fillFromSystemProperties(properties);

        try {
            super.init(properties);
        } catch (SecurityProviderException e) {
            throw new ServletException(e);
        }
    }

    @Override
    public void destroy() {
    }

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException {
        HttpServletRequest httpServletRequest = (HttpServletRequest) request;
        if (httpServletRequest.getHeader(&quot;User-Agent&quot;) != null) {
            String ua = httpServletRequest.getHeader(&quot;User-Agent&quot;).toLowerCase();
            boolean windows = ua.contains(&quot;windows&quot;);
            boolean gecko = ua.contains(&quot;gecko&quot;) &amp;&amp; !ua.contains(&quot;webkit&quot;);
            if (!windows &amp;&amp; gecko) {
                chain.doFilter(request, response);
                return;
            }
        }
        super.doFilter(request, response, chain);
    }

    @Override
    public void authenticate(String login, String password, Locale loc) throws LoginException {
        DomainAliasesResolver aliasesResolver = AppBeans.get(DomainAliasesResolver.NAME);

        String domain;
        String userName;

        int atSignPos = login.indexOf(&quot;@&quot;);
        if (atSignPos &gt;= 0) {
            String domainAlias = login.substring(atSignPos + 1);
            domain = aliasesResolver.getDomainName(domainAlias).toUpperCase();
        } else {
            int slashPos = login.indexOf(&apos;\\&apos;);
            if (slashPos &lt;= 0) {
                throw new LoginException(
                        messages.getMessage(ActiveDirectoryHelper.class, &quot;activeDirectory.invalidName&quot;, loc),
                        login
                );
            }
            String domainAlias = login.substring(0, slashPos);
            domain = aliasesResolver.getDomainName(domainAlias).toUpperCase();
        }

        userName = login;

        DomainInfo domainInfo = domains.get(domain);
        if (domainInfo == null) {
            throw new LoginException(
                    messages.getMessage(ActiveDirectoryHelper.class, &quot;activeDirectory.unknownDomain&quot;, loc),
                    domain
            );
        }

        Map&lt;String, String&gt; params = new HashMap&lt;&gt;();
        params.put(&quot;bindstr&quot;, domainInfo.bindStr);
        params.put(&quot;service.acctname&quot;, domainInfo.acctName);
        params.put(&quot;service.password&quot;, domainInfo.acctPassword);
        params.put(&quot;account.canonicalForm&quot;, &quot;3&quot;);
        fillFromSystemProperties(params);

        NtlmSecurityProvider provider = new NtlmSecurityProvider(params);
        try {
            PasswordCredential credential = new PasswordCredential(userName, password.toCharArray());
            provider.authenticate(credential);
        } catch (SecurityProviderException e) {
            throw new LoginException(
                    messages.getMessage(ActiveDirectoryHelper.class, &quot;activeDirectory.authenticationError&quot;, loc),
                    e.getMessage()
            );
        }
    }

    private void initDomains() {
        String domainsStr = AppContext.getProperty(&quot;cuba.web.activeDirectoryDomains&quot;);
        if (!StringUtils.isBlank(domainsStr)) {
            String[] strings = domainsStr.split(&quot;;&quot;);
            for (int i = 0; i &lt; strings.length; i++) {
                String domain = strings[i];
                domain = domain.trim();
                if (!StringUtils.isBlank(domain)) {
                    String[] parts = domain.split(&quot;\\|&quot;);
                    if (parts.length != 4) {
                        log.error(&quot;Invalid ActiveDirectory domain definition: &quot; + domain);
                        break;
                    } else {
                        domains.put(parts[0], new DomainInfo(parts[1], parts[2], parts[3]));
                        if (i == 0)
                            defaultDomain = parts[0];
                    }
                }
            }
        }
    }

    public String getDefaultDomain() {
        return defaultDomain != null ? defaultDomain : &quot;&quot;;
    }

    public String getBindStr() {
        return getBindStr(getDefaultDomain());
    }

    public String getBindStr(String domain) {
        initDomains();
        DomainInfo domainInfo = domains.get(domain);
        return domainInfo != null ? domainInfo.bindStr : &quot;&quot;;
    }

    public String getAcctName() {
        return getAcctName(getDefaultDomain());
    }

    public String getAcctName(String domain) {
        initDomains();
        DomainInfo domainInfo = domains.get(domain);
        return domainInfo != null ? domainInfo.acctName : &quot;&quot;;
    }

    public String getAcctPassword() {
        return getAcctPassword(getDefaultDomain());
    }

    public String getAcctPassword(String domain) {
        initDomains();
        DomainInfo domainInfo = domains.get(domain);
        return domainInfo != null ? domainInfo.acctPassword : &quot;&quot;;
    }

    public void fillFromSystemProperties(Map&lt;String, String&gt; params) {
        for (String name : AppContext.getPropertyNames()) {
            if (name.startsWith(&quot;jespa.&quot;)) {
                params.put(name, AppContext.getProperty(name));
            }
        }
    }
}</programlisting></para>
        </section>
        <section>
          <title>Настройка конфигурации</title>
          <itemizedlist>
            <listitem>
              <para>Выполнить настройки, описанные в разделе <guimenu>Installation</guimenu> -&gt; <guimenu>Step 1: Create the Computer Account for NETLOGON Communication</guimenu> руководства <application>Jespa Operator&apos;s Manual</application>, которое можно загрузить по адресу <ulink url="http://www.ioplex.com/support.html">http://www.ioplex.com/support.html</ulink>.</para>
            </listitem>
            <listitem>
              <para>Задать параметры доменов в <link linkend="app_properties_files">local.app.properties</link> в свойстве приложения <code>cuba.web.activeDirectoryDomains</code>. Каждый описатель домена имеет формат <code>domain_name|full_domain_name|service_account_name|service_account_password</code>. Описатели доменов отделяются друг от друга точкой с запятой. </para>
              <para>Например:<programlisting>cuba.web.activeDirectoryDomains = MYCOMPANY|mycompany.com|JESPA$@MYCOMPANY.COM|password1;TEST|test.com|JESPA$@TEST.COM|password2</programlisting></para>
            </listitem>
            <listitem>
              <para>Разрешить интеграцию с Active Directory, установив в <filename>local.app.properties</filename> свойство приложения <code>cuba.web.useActiveDirectory</code>:<programlisting>cuba.web.useActiveDirectory = true</programlisting></para>
            </listitem>
            <listitem>
              <para>Задать в <filename>local.app.properties</filename> дополнительные свойства для библиотеки  (см. <application>Jespa Operator&apos;s Manual</application>).  Например:<programlisting>jespa.log.level=3</programlisting></para>
            </listitem>
            <listitem>
              <para>Добавить адрес сервера в местную интрасеть в настройках браузера:<itemizedlist>
                  <listitem>
                    <para>Для <application>Internet Explorer</application>  и <application>Chrome</application>: Свойства обозревателя -&gt; Безопасность -&gt; Местная интрасеть -&gt; Узлы -&gt; Дополнительно</para>
                  </listitem>
                  <listitem>
                    <para>Для Firefox: about:config -&gt; network.automatic-ntlm-auth.trusted-uris=http://myapp.mycompany.com</para>
                  </listitem>
                </itemizedlist></para>
            </listitem>
          </itemizedlist>
        </section>
      </section>
    </section>
  </section>
  <section id="security_examples">
    <title>Примеры управления доступом</title>
    <para>В данном разделе приведены практические рекомендации по настройке доступа пользователей к данным.</para>
    <section id="roles_example">
      <title>Настройка ролей</title>
      <para>Рекомендованный способ настройки <link linkend="roles">ролей</link> и <link linkend="permissions">разрешений</link>:<orderedlist>
          <listitem>
            <para>Создать роль <userinput>Default</userinput>, отбирающую все права в системе. Проще всего это сделать, установив тип роли <guilabel>Denying</guilabel>. Включить флажок <guilabel>Default role</guilabel>, чтобы эта роль автоматически назначалась всем новым пользователям.</para>
          </listitem>
          <listitem>
            <para>Создать набор ролей, дающих нужные права различным категориям пользователей. Можно предложить две стратегии создания таких ролей:<itemizedlist>
                <listitem>
                  <para>Крупнозернистые (coarse-grained) роли - каждая роль содержит  набор разрешений для всего круга обязанностей пользователя в системе. Например <userinput>Sales Manager</userinput>, <userinput>Accountant</userinput>. В этом случае пользователям в дополнение к запрещающей <userinput>Default</userinput> роли необходимо назначить как правило только одну разрешающую роль.</para>
                </listitem>
                <listitem>
                  <para>Мелкозернистые (fine-grained) роли - каждая роль содержит небольшой набор разрешений для выполнения пользователем некоторой функции в системе. Например <userinput>Task Creator</userinput>, <userinput>References Editor</userinput>. В этом случае пользователям в дополнение к запрещающей <userinput>Default</userinput> роли необходимо назначить  несколько разрешающих ролей в соответствии с кругом их обязанностей.</para>
                </listitem>
              </itemizedlist></para>
            <para>Разумеется, ничто не мешает совмещать обе стратегии.</para>
          </listitem>
          <listitem>
            <para>Администратору системы можно просто не назначать никаких ролей вообще, тогда у него будут все права на все объекты системы. Пользователя с запрещающими ролями можно сделать администратором, добавив ему роль типа <guilabel>Super</guilabel>.</para>
          </listitem>
        </orderedlist></para>
    </section>
    <section id="local_admins_example">
      <title>Создание локальных администраторов</title>
      <para>Иерархическая структура <link linkend="groups">групп доступа</link> с наследованием <link linkend="constraints">ограничений</link> позволяет создавать <firstterm>локальных администраторов</firstterm> и делегировать им создание пользователей и настройку их прав в рамках подразделений организации. </para>
      <para>Локальному администратору доступны экраны  подсистемы безопасности, однако он видит только пользователей и группы в своей группе доступа и ниже. Он может создавать подгруппы и пользователей и назначать им имеющиеся в системе <link linkend="roles">роли</link>. При этом все создаваемые им пользователи будут иметь как минимум те же ограничения, что и он сам.</para>
      <para>Глобальный администратор, находящийся в корневой группе доступа, лишенной ограничений, должен создать роли, которые будут доступны локальным администраторам для назначения пользователям. Сами локальные администраторы не должны иметь прав на создание и изменение ролей.</para>
      <para>Рассмотрим следующую структуру групп доступа:<mediaobject>
          <imageobject>
            <imagedata align="center" fileref="img/local_admins_groups.png"/>
          </imageobject>
        </mediaobject></para>
      <para>Задача:<itemizedlist>
          <listitem>
            <para>Пользователи внутри группы <userinput>Departments</userinput> должны видеть только пользователей своей группы и ниже.</para>
          </listitem>
          <listitem>
            <para>В каждой из групп <userinput>Dept 1</userinput>, <userinput>Dept 2</userinput>, и т.д. должен быть свой локальный администратор, который может создавать пользователей и назначать им имеющиеся роли.</para>
          </listitem>
        </itemizedlist></para>
      <para>Способ решения задачи:<itemizedlist>
          <listitem>
            <para>Задать для группы <userinput>Departments</userinput> следующие ограничения:<mediaobject>
                <imageobject>
                  <imagedata align="center" fileref="img/local_admins_constraints.png"/>
                </imageobject>
              </mediaobject><itemizedlist>
                <listitem>
                  <para>Для сущности <code>sec$Group</code>:<programlisting>{E}.id in (
  select h.group.id from sec$GroupHierarchy h
  where h.group.id = :session$userGroupId or h.parent.id = :session$userGroupId
)</programlisting></para>
                  <para>Это ограничение не позволяет пользователям видеть группы выше своей собственной.</para>
                </listitem>
                <listitem>
                  <para>Для сущности <code>sec$User</code>:<programlisting>{E}.group.id in (
  select h.group.id from sec$GroupHierarchy h
  where h.group.id = :session$userGroupId or h.parent.id = :session$userGroupId
)</programlisting></para>
                  <para>Это ограничение не позволяет пользователям видеть других пользователей, входящих в группы выше своей собственной.</para>
                </listitem>
                <listitem>
                  <para>Для сущности <code>sec$Role</code>:<programlisting>({E}.description is null or {E}.description not like &apos;[hide]&apos;)</programlisting></para>
                  <para>Данное ограничение не позволяет пользователям видеть роли, в атрибуте <code>description</code> которых записана строка <userinput>[hide]</userinput>.</para>
                </listitem>
              </itemizedlist></para>
          </listitem>
          <listitem>
            <para>Создать роль, которая запретит редактирование ролей и разрешений:<mediaobject>
                <imageobject>
                  <imagedata align="center" fileref="img/local_admins_role.png"/>
                </imageobject>
              </mediaobject></para>
            <itemizedlist>
              <listitem>
                <para>Установите флажок <guilabel>Default role</guilabel>.</para>
              </listitem>
              <listitem>
                <para>В поле <guilabel>Description</guilabel> добавьте строку <userinput>[hide]</userinput>.</para>
              </listitem>
              <listitem>
                <para>На вкладке <guilabel>Entities</guilabel> запретите операции <guilabel>create</guilabel>, <guilabel>update</guilabel>, <guilabel>delete</guilabel> для сущностей <code>sec$Role</code> и <code>sec$Permission</code> (для добавления разрешений на объект <code>sec$Permission</code> установите флажок <guilabel>System level</guilabel>).</para>
              </listitem>
            </itemizedlist>
            <para>Все создаваемые пользователи, включая локальных администраторов, будут получать роль <userinput>local_user</userinput>. Эта роль невидима для пользователей группы <userinput>Departments</userinput>, поэтому даже локальные администраторы не смогут ее с себя снять. В результате они смогут оперировать только существующими ролями, созданными для них глобальным администратором. Разумеется, эти роли не должны отменять запрещений, введенных ролью <userinput>local_user</userinput>.</para>
          </listitem>
        </itemizedlist></para>
    </section>
  </section>
</chapter>
