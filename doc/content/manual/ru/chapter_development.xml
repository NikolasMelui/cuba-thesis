<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" []>
<!-- This document was created with Syntext Serna Free. --><chapter id="chapter_development" lang="ru">
  <title>Разработка приложений</title>
  <section id="project_file_structure">
    <title>Файловая структура проекта</title>
    <para>Рассмотрим структуру классов и других файлов в проекте.</para>
    <para>В корне проекта расположены скрипты сборки <filename>build.gradle</filename>, <filename>settings.gradle</filename> и проектные файлы <application>IntelliJ IDEA</application>.</para>
    <para id="text_module_id">В каталоге <filename>modules</filename> расположены подкаталоги <firstterm id="text_modules">модулей</firstterm> проекта − <structname>global</structname>, <structname>core</structname>, <structname>gui</structname>, <structname>web</structname>. Модуль – это элемент проекта, в котором хранится программный код.</para>
    <itemizedlist>
      <listitem>
        <para><structname>global</structname></para>
      </listitem>
      <listitem>
        <para><structname>core</structname></para>
      </listitem>
      <listitem>
        <para><structname>gui</structname></para>
      </listitem>
      <listitem>
        <para><structname>client</structname></para>
      </listitem>
      <listitem>
        <para><structname>web</structname></para>
      </listitem>
      <listitem>
        <para><structname>web-portal</structname></para>
      </listitem>
      <listitem>
        <para><structname>desktop</structname></para>
      </listitem>
    </itemizedlist>
    <para>Модуль <structname>global</structname> определяет компоненты, доступные как среднему слою (Middleware), так и клиентскому коду.</para>
    <itemizedlist>
      <listitem>
        <para>В пакете <package>com.haulmont.shop.core.app</package> создаются интерфейсы <link linkend="services">сервисов</link> среднего слоя (Middleware). </para>
      </listitem>
      <listitem>
        <para>В пакете <package>com.haulmont.shop.core.entity</package> создаются классы <glossterm linkend="entity">сущностей</glossterm> и <link linkend="message_packs">файлы локализованных сообщений</link>  <filename>messages.properties</filename> для задания названий сущностей и их атрибутов.</para>
      </listitem>
      <listitem>
        <para>В файле <filename>shop-persistence.xml</filename>  регистрируются новые классы сущностей.</para>
      </listitem>
      <listitem>
        <para>В файле <filename>shop-metadata.xml</filename>  может быть задано <link linkend="extension">замещение</link> стандартных сущностей новыми.</para>
      </listitem>
    </itemizedlist>
    <figure>
      <title>Структура каталогов и файлов проекта</title>
      <mediaobject>
        <imageobject>
          <imagedata contentwidth="55%" align="center" fileref="img/ch2_structure.png"/>
        </imageobject>
      </mediaobject>
    </figure>
    <para>Модуль <structname>core</structname> определяет компоненты среднего слоя (Middleware) системы.</para>
    <itemizedlist>
      <listitem>
        <para>Каталог <filename>db</filename> содержит sql-скрипты создания и <link linkend="db_update">изменения</link> базы данных в подкаталогах <filename>init</filename> и <filename>update</filename> соответственно.</para>
      </listitem>
      <listitem>
        <para>В пакете <package>com.haulmont.shop.core.app</package> создаются классы реализации <link linkend="services">сервисов (Services)</link> среднего слоя (Middleware), а также другие компоненты бизнес-логики приложения.</para>
      </listitem>
      <listitem>
        <para>Файл <filename>shop-app.properties</filename> содержит конфигурационные параметры среднего слоя:</para>
        <para><parameter>cuba.springContextConfig</parameter> − определяет набор конфигурационных файлов Spring-фреймворка;</para>
        <para><parameter>cuba.persistenceConfig</parameter> − определяет набор конфигурационных файлов ORM;</para>
        <para><parameter>cuba.viewsConfig</parameter> − задает набор конфигурационных файлов <link linkend="views">представлений</link>;</para>
      </listitem>
      <listitem>
        <para>В файле <filename>shop-spring.xml</filename> при необходимости можно подменить реализацию стандартных сервисов или других управляемых фреймворком Spring компонентов, а также зарегистрировать создаваемые <glossterm linkend="jmx">JMX</glossterm>-компоненты.</para>
      </listitem>
      <listitem>
        <para>Файл <filename>shop-views.xml</filename> содержит описание <link linkend="views">представлений</link>. Механизм представлений  обеспечивает извлечение из БД и передачу клиенту графов сущностей, ограниченных в глубину и/или по атрибутам.</para>
      </listitem>
      <listitem>
        <para>Файл <filename>web\META-INF\context.xml</filename> содержит настройки подключения к базе данных.</para>
      </listitem>
      <listitem>
        <para>Файл <filename>web\WEB-INF\web.xml</filename> − это дескриптор веб-приложения среднего слоя (Middleware). Среди прочего содержит список конфигурационных файлов <filename>*-app.properties</filename>, используемых данным приложением.</para>
      </listitem>
    </itemizedlist>
    <para>Модуль <structname>gui</structname> определяет компоненты <link linkend="gui_framework">графического пользовательского интерфейса</link>. Этот модуль доступен всем типам клиентов. Модуль <structname>gui</structname> содержит универсальные экраны: классы <glossterm linkend="screen_controller_glossentry">контроллеров</glossterm>, <glossterm linkend="screen_xml_glossentry">XML-дескрипторы</glossterm> экранов, файлы <link linkend="message_packs">локализованных сообщений</link>.</para>
    <itemizedlist>
      <listitem>
        <para>В пакете <package>com.haulmont.shop.gui.ui</package> создаются экраны приложения.</para>
      </listitem>
      <listitem>
        <para>В файле <filename>shop-screens.xml</filename> регистрируются экраны приложения.</para>
      </listitem>
    </itemizedlist>
    <para>Модуль <structname>web</structname> определяет компоненты веб-клиента. Зависит от модулей <structname>gui</structname> и <structname>global</structname>. Содержит специфические экраны и/или <glossterm>компаньоны</glossterm> и файлы конфигурации.</para>
    <itemizedlist>
      <listitem>
        <para>Класс  <code>com.haulmont.shop.App.java</code> определяет главное окно приложения.</para>
      </listitem>
      <listitem>
        <para>Файл <filename>shop-web-app.properties</filename> содержит конфигурационные параметры веб-клиента:</para>
        <para><parameter>cuba.windowConfig</parameter> − в этом свойстве указывается набор файлов конфигурации экранов приложения;</para>
        <para><parameter>cuba.menuConfig</parameter> содержит список файлов, описывающих меню приложения;</para>
        <para><parameter>cuba.appConfig.messagesPack</parameter>  задает список имен <link linkend="message_packs">пакетов сообщений</link>, формирующих <link linkend="main_message_pack">главный пакет</link>, используемый главным меню и другими общими компонентами системы;</para>
      </listitem>
      <listitem>
        <para>Файл <filename>shop-web-menu.xml</filename> содержит описание пунктов главного меню приложения.</para>
      </listitem>
      <listitem>
        <para>В файле <filename>shop-web-screens.xml</filename> регистрируются экраны приложения.</para>
      </listitem>
    </itemizedlist>
  </section>
  <section>
    <title>Описание скриптов сборки</title>
    <para>TODO</para>
  </section>
  <section>
    <title>Создание проекта</title>
    <para>TODO</para>
  </section>
  <section>
    <title>Соглашения по именованию</title>
    <para>Ниже представлены соглашения, рекомендуемые для программирования на платформе <trademark>CUBA</trademark>.</para>
    <para>При написании классов рекомендуем использовать стиль <application>IntelliJ IDEA</application> по умолчанию (это можно сделать с помощью сочетания клавиш <keycombo>
        <keycap function="control">Ctrl</keycap>
        <keycap function="alt">Alt</keycap>
        <keycap>L</keycap>
      </keycombo>). Стиль <application>IntelliJ IDEA</application> по умолчанию удовлетворяет Code Conventions for the Java Programming Language (<ulink url="http://www.oracle.com/technetwork/java/codeconv-138413.html">http://www.oracle.com/technetwork/java/codeconv-138413.html</ulink>)</para>
    <para>Максимальная длина строки − 120 символов. Максимальная длина метода − 50 строк.</para>
    <para>Правила использования прописных букв в идентификаторах:
</para>
    <informaltable frame="all" pgwide="0" align="center">
      <tgroup cols="3" colsep="1" rowsep="1" align="center">
        <colspec colname="c1"/>
        <colspec colname="c2"/>
        <colspec colname="c3"/>
        <thead wordsize="16">
          <row>
            <entry colname="Имя атрибута" role="bord">Идентификатор</entry>
            <entry colname="Тип атрибута" role="caption">Правило именования</entry>
            <entry colname="Тип атрибута" role="caption">Пример</entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry namest="c1" nameend="c3" align="center" role="left">
              <emphasis role="bold">Java и Groovy классы </emphasis>
            </entry>
          </row>
          <row>
            <entry align="left">Название класса, тип перечисления, событие, класс исключения, интерфейс</entry>
            <entry align="left">UpperCamelCase </entry>
            <entry align="left"><code>Buyer</code>, <code>Unit</code>, <code>EditRoleAction</code>, <code>RuntimeException</code>, <code>Editor</code></entry>
          </row>
          <row>
            <entry align="left" role="left">Название класса контроллера</entry>
            <entry align="left" role="special">UpperCamelCase, контроллеры экранов со списком сущностей − <code>&lt;ИмяКлассаСущности&gt;Browser</code>, контроллеры экранов редактирования − <code>&lt;ИмяКлассаСущности&gt;Editor</code></entry>
            <entry align="left" role="right">
              <code>BuyerBrowser</code>
            </entry>
          </row>
          <row>
            <entry align="left">Статическое поле только для чтения</entry>
            <entry align="left">UPPERCASE</entry>
            <entry align="left">
              <code>ENTITY_SPECIAL_KEY</code>
            </entry>
          </row>
          <row>
            <entry align="left" role="left">Метод, переменная</entry>
            <entry align="left" role="special">lowerCamelCase</entry>
            <entry align="left" role="right"><code>setItem</code>, <code>discountsTable</code></entry>
          </row>
          <row>
            <entry namest="c1" nameend="c3" align="center">
              <emphasis role="bold">XML-дескрипторы</emphasis>
            </entry>
          </row>
          <row>
            <entry align="left" role="left">Идентификатор компонента, имена параметров в запросах</entry>
            <entry align="left" role="special">lowerCamelCase, только буквы и цифры</entry>
            <entry align="left" role="right"><code>attributesTable</code>, <code>component$relevantTo</code></entry>
          </row>
          <row>
            <entry align="left">Идентификатор источника данных</entry>
            <entry align="left">lowerCamelCase, только буквы и цифры, оканчивается на <code>Ds</code></entry>
            <entry align="left">
              <code>attributesDs</code>
            </entry>
          </row>
          <row>
            <entry align="left">Имена параметров в запросах</entry>
            <entry align="left">lowerCamelCase, только буквы и цифры</entry>
            <entry align="left">
              <code>component$relevantTo</code>
            </entry>
          </row>
          <row>
            <entry namest="c1" nameend="c3" align="center" role="left">
              <emphasis role="bold">Объекты базы данных</emphasis>
            </entry>
          </row>
          <row>
            <entry align="left">Зарезервированные слова</entry>
            <entry align="left">lowercase</entry>
            <entry align="left">
              <code>create table</code>
            </entry>
          </row>
          <row>
            <entry align="left" role="left">Идентификаторы</entry>
            <entry align="left" role="special">UPPERCASE. Слова в названии разделяются подчеркиванием. В именах таблиц используется либо единственное число, либо множественное, но не оба сразу. Рекомендуем использовать единственное число.</entry>
            <entry align="left" role="right">
              <code>SYS_FTS_QUEUE</code>
            </entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>
  </section>
  <section>
    <title>Отладка и тестирование</title>
    <para>TODO</para>
  </section>
  <section>
    <title>Интеграция со сторонними приложениями</title>
    <para>TODO</para>
  </section>
  <section>
    <title>Практические руководства</title>
    <section>
      <title>Правила создания управляемых бинов</title>
      <itemizedlist>
        <listitem>
          <para>Создать интерфейс бина в пакете <package>app</package> и задать в нем кроме методов поле с именем бина. Имя бина должно иметь префикс с именем проекта. Например:</para>
          <para><programlisting>public interface TaskWorker {
    String NAME = &quot;taskman_TaskWorker&quot;;
    ...</programlisting></para>
        </listitem>
        <listitem>
          <para>Создать класс реализации в пакете <package>app</package> и аннотировать его, указав имя бина:</para>
          <para><programlisting>@ManagedBean(TaskWorker.NAME)
public class TaskWorkerBean implements TaskWorker {
...</programlisting></para>
        </listitem>
      </itemizedlist>
      <para>Данные правила дают возможность в дальнейшем получать ссылки на бин, указывая константу в качестве имени:</para>
      <programlisting>LoginService ls = AppContext.getBean(LoginService.NAME);</programlisting>
      <para>Ссылку на бин в другом управляемом бине (а также  в <link linkend="services">сервисе</link> или <link linkend="mbeans">МБине</link>) можно получить более простым и естественным способом, объявив поле соответствующего типа и добавив ему аннотацию<literal> @Inject</literal>:</para>
      <programlisting>@Inject
private TaskWorker taskWorker;</programlisting>
      <para>В этом случае контейнер автоматически найдет подходящую реализацию и установит ссылку на объект во время разворачивания приложения в памяти.</para>
      <para>Довольно часто программный компонент, реализующий бизнес-логику, должен иметь состояние (например, кэш или конфигурационные данные), и предоставлять интерфейс администратору системы для просмотра и управления этими данными. В этом случае рекомендуется добавить управляемому бину <glossterm linkend="jmx">JMX</glossterm>-интерфейс и превратить его тем самым в <link linkend="mbeans">МБин</link>.</para>
    </section>
    <section>
      <title>Правила создания Мбинов</title>
      <para>Если JMX-методы МБина работают с данными, то ему потребуется пользовательская сессия с правами на доступ. В этом случае рекомендуется наследовать МБин от базового класса <code>ManagementBean</code>, который содержит удобные методы входа в систему/выхода из системы (login/logout).</para>
      <para><emphasis role="bold">Правила создания</emphasis></para>
      <itemizedlist>
        <listitem>
          <para>Создать интерфейс с именем, заканчивающимся на <code>*MBean</code>, например, <code>SampleMBean</code> в пакете <package>app</package></para>
        </listitem>
        <listitem>
          <para>Если нужно обращение к МБину из кода сервера (а не только из <glossterm linkend="jmx">JMX</glossterm>-консоли), создать интерфейс <code>SampleAPI</code>. Создать в интерфейсе поле с именем бина, в качестве префикса использовать имя проекта:</para>
          <programlisting>public interface SampleAPI {
    String NAME = &quot;myproject_Sample&quot;;
    ...</programlisting>
        </listitem>
        <listitem>
          <para>Создать класс реализации с именем, соответствующим интерфейсу, в нашем случае <code>Sample</code> и аннотировать его как <literal>@ManagedBean(SampleAPI.NAME)</literal></para>
        </listitem>
        <listitem>
          <para>Экспортировать <code>*MBean</code> интерфейс в JMX в файле <filename>myproject-spring.xml</filename>, например:</para>
          <programlisting>&lt;bean id=&quot;myproject_MBeanExporter&quot; class=&quot;org.springframework.jmx.export.MBeanExporter&quot; lazy-init=&quot;false&quot;&gt;
        &lt;property name=&quot;beans&quot;&gt;
            &lt;map&gt;
                &lt;entry key=&quot;${cuba.webContextName}:service=Sample&quot; value-ref=&quot;myproject_Sample&quot;/&gt;
            &lt;/map&gt;
        &lt;/property&gt;
        &lt;property name=&quot;assembler&quot;&gt;
            &lt;bean class=&quot;org.springframework.jmx.export.assembler.InterfaceBasedMBeanInfoAssembler&quot;&gt;
                &lt;property name=&quot;interfaceMappings&quot;&gt;
                    &lt;map&gt;
                        &lt;entry key=&quot;myproject_Sample&quot; value=&quot;com.haulmont.myproject.core.app.SampleMBean&quot;/&gt;
                    &lt;/map&gt;
                &lt;/property&gt;
            &lt;/bean&gt;
        &lt;/property&gt;
    &lt;/bean&gt;</programlisting>
        </listitem>
      </itemizedlist>
      <para>Один Spring-объект <code>MBeanExporter</code> может экспортировать несколько МБинов.
Для удобства работы администратора методы JMX-интерфейса должны возвращать строку. В случае успешного выполнения это может быть полезная информация, либо просто строка <computeroutput>Done</computeroutput>. В случае возникновения исключения нужно его записать в журнал и вернуть stacktrace:</para>
      <programlisting>public String jmxMethod1() {
    try {
        return &quot;Done&quot;;
    } catch (Exception e) {
        log.error(&quot;Error executing jmxMethod1&quot;, e);
        return ExceptionUtils.getStackTrace(e);
    } 
}</programlisting>
      <para><emphasis role="bold">Security</emphasis></para>
      <para>Как правило, для выполнения функций МБинов требуется аутентификация в <trademark>CUBA</trademark>-security, а <glossterm linkend="jmx">JMX</glossterm>-интерфейс  ее обеспечить не может. Простой механизм входа в систему/выхода из системы (login/logout) содержится в классе <code>com.haulmont.cuba.core.app.ManagementBean</code>, поэтому желательно наследовать свои классы МБинов, работающих с данными, от этого класса. Пример использования:</para>
      <programlisting>public String jmxMethod2() {
    try {
loginOnce(); // defined in ManagementBean
...
return &quot;Done&quot;;
    } catch (Exception e) {
        log.error(&quot;Error executing jmxMethod2&quot;, e);
return ExceptionUtils.getStackTrace(e);
    } 
}</programlisting>
      <para>Методы <methodname>login()</methodname> и <methodname>loginOnce()</methodname>, определенные в классе <code>ManagementBean</code>, осуществляют вход в систему, используя имя и пароль, заданные в <link>файле свойств</link> в параметрах  <parameter>cuba.jmxUserLogin</parameter> и <parameter>cuba.jmxUserPassword</parameter> соответственно. Пароль должен быть захеширован и указан с префиксом <code>md5:</code>. Простейший способ получить пароль пользователя в <code>md5</code> − скопировать значение из поля <database>SEC_USER.PASSWORD</database> базы данных.</para>
      <para><emphasis role="bold">Работа с JMX-интерфейсом</emphasis></para>
      <para>Обращаться к МБинам можно с помощью утилиты <application>jconsole</application>, входящей в состав <application>JDK</application>, либо с помощью программы <application>VisualVM</application>.</para>
      <para>Для того чтобы увидеть свои МБины, сервер <application>Tomcat</application> должен быть запущен с опциями удаленного подключения к <glossterm linkend="jmx">JMX</glossterm>. В простейшем случае, без аутентификации, параметры запуска <application>JVM</application> должны содержать следующие опции:</para>
      <programlisting>set CATALINA_OPTS=-Dcom.sun.management.jmxremote
-Dcom.sun.management.jmxremote.port=7777
-Dcom.sun.management.jmxremote.ssl=false
-Dcom.sun.management.jmxremote.authenticate=false</programlisting>
    </section>
    <section>
      <title>Управление транзакциями</title>
      <para>Используется интерфейс <code>com.haulmont.cuba.core.Transaction</code>, получаемый из Locator&apos;a




</para>
      <itemizedlist>
        <listitem>
          <para><code>Locator.createTransaction()</code> – старт транзакции</para>
        </listitem>
        <listitem>
          <para><code>Transaction.commit()</code> – коммит, <code>commitRetaining() </code>– коммит и старт новой</para>
        </listitem>
        <listitem>
          <para><code>Transaction.end()</code> – выполняет rollback, если ранее не был вызван коммит</para>
        </listitem>
        <listitem>
          <para><code>Locator.isInTransaction()</code> – есть ли в данный момент транзакция</para>
        </listitem>
        <listitem>
          <para>Обязательно  вызывать <code>Transaction.end()</code> в блоке finally, в противном случае возможно зависание открытых транзакций в БД, что недопустимо</para>
          <programlisting>Transaction tx = Locator.createTransaction();
try {
    …
    tx.commit();
} finally {
    tx.end();
}</programlisting>
        </listitem>
      </itemizedlist>
      <para><emphasis role="bold">Особенности применения</emphasis></para>
      <itemizedlist>
        <listitem>
          <para><code>Locator.createTransaction()</code> всегда создает новую транзакцию. Если в этот момент уже есть открытая транзакция, она приостанавливается (REQUIRES_NEW).</para>
        </listitem>
        <listitem>
          <para><code>Locator.getTransaction()</code> создает новую транзакцию, только если в данный момент нет уже открытой транзакции (REQUIRES). </para>
        </listitem>
        <listitem>
          <para>Варианты использования см. в тесте <code>com.haulmont.cuba.core.TransactionTest</code></para>
        </listitem>
      </itemizedlist>
    </section>
  </section>
</chapter>
