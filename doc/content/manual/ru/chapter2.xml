<?xml version='1.0' encoding='UTF-8'?>
<!-- This document was created with Syntext Serna Free. --><chapter lang="ru" id="chapter2_architecture">
  <title>Архитектура</title>
  <para>В данном разделе описываются различные аспекты архитектуры платформы <trademark>CUBA</trademark> и приложений на ее основе.</para>
  <section>
    <title>Структура проекта</title>
    <para id="text_module_id">Функционально проект приложения содержит зависимости от <firstterm>проектов</firstterm>, входящих в состав платформы. Проект − это структурная единица, содержащая программный код. Каждый проект имеет определенное предназначение. Диаграмма зависимостей проектов платформы изображена на рисунке.</para>
    <mediaobject>
      <imageobject>
        <imagedata align="center" fileref="img/projectStructure.png"/>
      </imageobject>
    </mediaobject>
    <para>Сплошными линиями изображены обязательные зависимости, пунктирными − опциональные.</para>
    <para>Рассмотрим проекты платформы более подробно.</para>
    <para><emphasis role="bold">Проект cuba</emphasis></para>
    <para>Это базовый проект, обязательная часть любого приложения.  Содержит функциональность для работы с базой данных, набор <link linkend="section_services_id">сервисов</link> <link linkend="section_middleware_id">
        <structfield>Middleware</structfield>
      </link>, <link linkend="section_gui_framework">Generic User Interface Framework</link>, функциональность управления пользователями и их доступом к данным. Данный проект может быть собран как полноценное независимое приложение.</para>
    <para><emphasis role="bold">Проект workflow</emphasis></para>
    <para>Опциональный проект для работы с <glossterm linkend="glossary_process_id">бизнес-процессами</glossterm>.</para>
    <para><emphasis role="bold">Проект fts</emphasis></para>
    <para>Опциональный проект  <link>полнотекстового поиска</link>.</para>
    <para><emphasis role="bold">Проект charts</emphasis></para>
    <para>Опциональный проект для отображения диаграмм в Web-клиенте.</para>
    <para><emphasis role="bold">Проект ccpayments</emphasis></para>
    <para>Опциональный проект для приема платежей по картам.</para>
    <para><emphasis role="bold">Проект reports</emphasis></para>
    <para>Опциональный проект подсистемы генерации отчетов.</para>
  </section>
  <section>
    <title>Структура и назначение каталогов и файлов проекта</title>
    <para>Рассмотрим структуру классов и других файлов в проекте.</para>
    <para>В корне проекта расположены скрипты сборки <filename>build.gradle</filename>, <filename>settings.gradle</filename> и проектные файлы <application>IntelliJ IDEA</application>.</para>
    <para id="text_module_id">В каталоге <filename>modules</filename> расположены подкаталоги <firstterm linkend="text_module_id">модулей</firstterm> проекта − <structname>global</structname>, <structname>core</structname>, <structname>gui</structname>, <structname>web</structname>. Модуль – это элемент проекта, в котором хранится программный код.</para>
    <itemizedlist>
      <listitem>
        <para><structname>global</structname></para>
      </listitem>
      <listitem>
        <para><structname>core</structname></para>
      </listitem>
      <listitem>
        <para><structname>gui</structname></para>
      </listitem>
      <listitem>
        <para><structname>client</structname></para>
      </listitem>
      <listitem>
        <para><structname>web</structname></para>
      </listitem>
      <listitem>
        <para><structname>web-portal</structname></para>
      </listitem>
      <listitem>
        <para><structname>desktop</structname></para>
      </listitem>
    </itemizedlist>
    <para>Модуль <structname>global</structname> определяет компоненты, доступные как <link linkend="section_middleware_id">среднему слою</link>, так и <link linkend="section_client_id">клиентскому коду</link>.</para>
    <itemizedlist>
      <listitem>
        <para>В пакете <package>com.haulmont.shop.core.app</package> создаются интерфейсы <link linkend="section_services_id">сервисов</link><link linkend="section_middleware_id"> Middleware</link>. </para>
      </listitem>
      <listitem>
        <para>В пакете <package>com.haulmont.shop.core.entity</package> создаются классы сущностей и <glossterm linkend="glossary_localized_folders_id">файлы локализованных сообщений</glossterm> <filename>messages.properties</filename> для задания названий <link>сущностей</link> и их атрибутов.</para>
      </listitem>
      <listitem>
        <para><filename>shop-persistence.xml</filename> − в этом файле регистрируются новые классы сущностей.</para>
      </listitem>
      <listitem>
        <para><filename>shop-metadata.xml</filename> − в этом файле может быть задано замещение стандартных сущностей новыми.</para>
      </listitem>
    </itemizedlist>
    <mediaobject>
      <imageobject>
        <imagedata align="center" fileref="img/ch2_structure.png" scale="60%"/>
      </imageobject>
    </mediaobject>
    <para>Модуль <structname>core</structname> определяет компоненты <link linkend="section_middleware_id">среднего слоя</link> системы.</para>
    <itemizedlist>
      <listitem>
        <para>Каталог <filename>db</filename> содержит sql-скрипты создания и изменения базы данных в подкаталогах <filename>init</filename> и <filename>update</filename> соответственно.</para>
      </listitem>
      <listitem>
        <para>В пакете <package>com.haulmont.shop.core.app</package> создаются классы реализации <link linkend="section_services_id">сервисов</link><link linkend="section_middleware_id"> Middleware</link>, а также другие компоненты бизнес-логики приложения.</para>
      </listitem>
      <listitem>
        <para>Файл <filename>shop-app.properties</filename> содержит <link>конфигурационные параметры</link> среднего слоя:</para>
        <para><parameter>cuba.springContextConfig</parameter> − определяет набор конфигурационных файлов <link linkend="text_additionally_spring">Spring</link>-фреймворка;</para>
        <para><parameter>cuba.persistenceConfig</parameter> − определяет набор конфигурационных файлов <link linkend="text_additionally_ORM">ORM</link>;</para>
        <para><parameter>cuba.viewsConfig</parameter> − задает набор конфигурационных файлов <link linkend="section_views_id">представлений</link>;</para>
      </listitem>
      <listitem>
        <para>В файле <filename>shop-spring.xml</filename> при необходимости можно подменить реализацию стандартных сервисов или других управляемых фреймворком <link linkend="text_additionally_spring">Spring</link> компонентов, а также зарегистрировать создаваемые <link>JMX</link>-компоненты.</para>
      </listitem>
      <listitem>
        <para>Файл <filename>shop-views.xml</filename> содержит описание <link linkend="section_views_id">представлений</link>. Механизм представлений  обеспечивает извлечение из БД и передачу клиенту графов сущностей, ограниченных в глубину и/или по атрибутам.</para>
      </listitem>
      <listitem>
        <para>Файл <filename>web\META-INF\context.xml</filename> содержит настройки подключения к базе данных.</para>
      </listitem>
      <listitem>
        <para>Файл <filename>web\WEB-INF\web.xml</filename> − это дескриптор Web-приложения <link linkend="section_middleware_id">среднего слоя</link>. Среди прочего содержит список <link>конфигурационных файлов</link> <filename>*-app.properties</filename>, используемых данным приложением.</para>
      </listitem>
    </itemizedlist>
    <para>Модуль <structname>gui</structname> определяет компоненты <link linkend="section_gui_framework">графического пользовательского интерфейса</link>. Этот модуль доступен всем типам клиентов. Модуль <structname>gui</structname> содержит универсальные экраны: классы <glossterm linkend="glossary_controller_id">контроллеров</glossterm>, <glossterm linkend="glossary_xml_descriptor_id">XML-дескрипторы</glossterm> экранов, файлы <glossterm linkend="glossary_localized_folders_id">локализованных сообщений</glossterm>.</para>
    <itemizedlist>
      <listitem>
        <para>В пакете <package>com.haulmont.shop.gui.ui</package> создаются экраны приложения.</para>
      </listitem>
      <listitem>
        <para>В файле <filename>shop-screens.xml</filename> регистрируются экраны приложения.</para>
      </listitem>
    </itemizedlist>
    <para>Модуль <structname>web</structname> определяет компоненты Web-клиента. Зависит от модулей <structname>gui</structname> и <structname>global</structname>. Содержит специфические экраны и/или компаньоны и файлы конфигурации.</para>
    <itemizedlist>
      <listitem>
        <para>Класс  <classname>com.haulmont.shop.App.java</classname> определяет главное окно приложения.</para>
      </listitem>
      <listitem>
        <para>Файл <filename>shop-web-app.properties</filename> содержит конфигурационные параметры Web-клиента:</para>
        <para><parameter>cuba.windowConfig</parameter> − в этом свойстве указывается набор файлов конфигурации экранов приложения;</para>
        <para><parameter>cuba.menuConfig</parameter> содержит список файлов, описывающих меню приложения;</para>
        <para><parameter>cuba.appConfig.messagesPack</parameter>  задает список имен <glossterm linkend="glossary_localized_folders_id">пакетов сообщений</glossterm>, формирующих <glossterm linkend="glossary_main_localized_folder_id">главный пакет</glossterm>, используемый главным меню и другими общими компонентами системы;</para>
      </listitem>
      <listitem>
        <para>Файл <filename>shop-web-menu.xml</filename> содержит описание пунктов главного меню приложения.</para>
      </listitem>
      <listitem>
        <para>В файле <filename>shop-web-screens.xml</filename> регистрируются экраны приложения.</para>
      </listitem>
    </itemizedlist>
  </section>
  <section>
    <title>Структура CUBA-приложения</title>
    <para>На диаграмме ниже приведена структура развернутого приложения, созданного на базе платформы. </para>
    <mediaobject>
      <imageobject>
        <imagedata align="center" fileref="img/DeploymentStructure.png"/>
      </imageobject>
    </mediaobject>
    <para>В приведенном варианте приложение обеспечивает отсутствие единой точки отказа, балансировку нагрузки и подключение различных типов клиентов. В простейшем случае приложение может быть развернуто на одном сервере, в том числе содержащем и базу данных. Стрелками изображено направление запросов &quot;от пользователя к данным&quot;.</para>
    <para>Приложение, основанное на платформе, физически состоит из нескольких <firstterm>уровней</firstterm> (tiers):</para>
    <para><emphasis role="bold">Middleware</emphasis></para>
    <para>Средний слой, содержащий основную бизнес-логику приложения. Представляет собой отдельное Web-приложение под управлением стандартного контейнера Java EE Web Profile.</para>
    <para><emphasis role="bold">Web Client</emphasis></para>
    <para>Основной клиентский уровень, как правило содержащий полнофункциональный интерфейс для Intranet-пользователей. Представляет собой отдельное Web-приложение под управлением стандартного контейнера Java EE Web Profile. Реализация пользовательского интерфейса основана на фреймворке Vaadin.</para>
    <para><emphasis role="bold">Web Portal</emphasis></para>
    <para>Дополнительный клиентский уровень, содержащий интерфейс для внешних (Internet) пользователей. Может использоваться для интеграции с мобильными устройствами или сторонними приложениями. Представляет собой отдельное Web-приложение под управлением стандартного контейнера Java EE Web Profile. Реализация пользовательского интерфейса основана на фреймворке Spring MVC.</para>
    <para><emphasis role="bold">Desktop Client</emphasis></para>
    <para>Дополнительный клиентский уровень, содержащий интерфейс для Intranet-пользователей. Представляет собой десктопное Java-приложение, реализация пользовательского интерфейса основана на фреймворке Java Swing.</para>
    <para>REST API − компонент <structfield>Middleware</structfield>, обеспечивающий интеграцию системы со сторонними приложениями.</para>
    <para>Физически CUBA-приложение всегда состоит как минимум из двух частей:</para>
    <itemizedlist>
      <listitem>
        <para>Web-приложения <structfield>Middleware</structfield></para>
      </listitem>
      <listitem>
        <para>Web-приложения Web-клиента</para>
      </listitem>
    </itemizedlist>
    <para>Оба этих Web-приложения  могут быть развернуты на любом Web-сервере <application>Java</application>. По умолчанию используется <application>Apache Tomcat</application>. </para>
    <para>Web и Desktop клиенты взаимодействуют со средним слоем одинаковым образом посредством протокола <application>HTTP</application>, что позволяет размещать средний слой произвольным образом, в том числе за сетевым брандмауэром. Следует отметить, что при развертывании в простейшем случае среднего слоя и Web-клиента на одном сервере между ними организуется локальное взаимодействие в обход сетевого стека для снижения накладных расходов.</para>
  </section>
  <section id="section_middleware_id">
    <title>Архитектура среднего слоя</title>
    <para>На следующем рисунке приведены основные компоненты среднего слоя CUBA-приложения.</para>
    <mediaobject>
      <imageobject>
        <imagedata align="center" fileref="img/Middleware.png"/>
      </imageobject>
    </mediaobject>
    <para>Компоненты сгруппированы по двум <link linkend="text_module_id">модулям</link>: <structname>core</structname> и <structname>global</structname>. В <structname>global</structname> расположены компоненты, доступные как коду <structfield>Middleware</structfield>, так и клиентскому коду. В <structname>core</structname> расположены компоненты ядра <structfield>Middleware</structfield>.</para>
    <para>Рассмотрим элементы диаграммы более подробно.</para>
    <para><link linkend="section_services_id">
        <emphasis role="bold">Services</emphasis>
      </link> – управляемые <glossterm linkend="glossary_conteiner_id">контейнером</glossterm> компоненты, формирующие <glossterm linkend="glossary_app_boundary_id">границу приложения</glossterm> и предоставляющие интерфейс клиентам <link linkend="section_middleware_id">Middleware</link>. Сервисы могут содержать бизнес-логику сами, либо делегировать выполнение <link linkend="section_managed_beans_id">Managed Beans</link>.</para>
    <para><link linkend="section_managed_beans_id">
        <emphasis role="bold">Managed Beans</emphasis>
      </link> – управляемые <glossterm linkend="glossary_conteiner_id">контейнером</glossterm> компоненты, содержащие бизнес-логику приложения. Вызываются <link linkend="section_services_id">сервисами</link>, другими бинами или через опциональный <glossterm linkend="glossary_jmx_id">JMX</glossterm> интерфейс.</para>
    <para><emphasis role="bold">Entity Classes</emphasis> – классы, моделирующие предметную область приложения.  Представляют собой аннотированные <glossterm linkend="glossary_pojo_id">POJO</glossterm>. Аннотации используются для задания соответствий между столбцами таблицы базы данных и полями объектов с помощью <link linkend="text_additionally_JPA">OpenJPA</link>, а также для формирования метаданных в <link linkend="section_metadata_framework">Metadata Framework</link>.</para>
    <para><emphasis role="bold">Persistence</emphasis> −  центральный интерфейс для доступа к функциональности хранения данных. Позволяет получать ссылки на интерфейсы <classname>EntityManager</classname> и <classname>Transaction</classname>.</para>
    <para><emphasis role="bold">Transaction</emphasis> − интерфейс управления <link linkend="section_transaction_id">транзакциями</link> <link linkend="section_middleware_id">Middleware</link>.</para>
    <para><emphasis role="bold">Entity Manager</emphasis> − интерфейс для работы с данными на уровне <link linkend="section_middleware_id">Middleware</link>. Позволяет извлекать сущности из базы данных по идентификатору и по запросу, а также сохранять и удалять их.</para>
    <para><link linkend="section_metadata_framework">Metadata Framework</link> позволяет создавать описание предметной области в терминах классов, атрибутов и отношений между классами. Метаданные (модель данных) существенно упрощают создание универсальных механизмов работы с данными. Исходной информацией для построения модели являются аннотированные классы сущностей.</para>
    <para><link linkend="section_infrastructure_interfaces_id">Global Infrastructure Interfaces</link> (интерфейсы инфраструктуры) предоставляют доступ к общей часто используемой функциональности. Реализованы в платформе аналогично <link linkend="section_managed_beans_id">Managed Beans</link>.

Все интерфейсы инфраструктуры имеют соответствующие <firstterm>статические фасады</firstterm> − классы со статическими методами, позволяющие иметь доступ к нужной функциональности из статического контекста (при невозможности использовать <link>dependency injection</link>). Статические фасады имеют имена, заканчивающиеся на <classname>*Provider</classname>.</para>
    <para><link linkend="text_additionally_spring">Spring Framework</link> − основа среднего слоя. Используются следующие возможности <link linkend="text_additionally_spring">Spring</link> Framework: </para>
    <itemizedlist>
      <listitem>
        <para>Инверсия управления (IoC container)</para>
      </listitem>
      <listitem>
        <para>Аспектно-ориентированное программирование (AOP)</para>
      </listitem>
      <listitem>
        <para>Управление транзакциями</para>
      </listitem>
      <listitem>
        <para>Remoting − доступ к сервисам среднего слоя по протоколу HTTP</para>
      </listitem>
      <listitem>
        <para>Реализация Web-сервисов и <link>REST API</link></para>
      </listitem>
    </itemizedlist>
    <para><link linkend="text_additionally_JPA">OpenJPA Framework</link> − реализация <link linkend="text_additionally_ORM">ORM</link> по стандарту JPA. Позволяет работать с таблицами базы данных как с объектами Java и создавать запросы на языке <link>JPQL</link>.</para>
    <section id="section_services_id">
      <title>Сервисы</title>
      <para><emphasis role="bold">Назначение</emphasis></para>
      <para>Сервисы представляют собой слой  компонентов, формирующих <glossterm linkend="glossary_app_boundary_id">границу приложения</glossterm>. Все клиенты должны обращаться к уровню <link linkend="section_middleware_id">Middleware</link> только посредством вызова методов сервисов.</para>
      <para>Основные задачи сервисов:</para>
      <itemizedlist>
        <listitem>
          <para>Обеспечить выполнение каждого метода в отдельной <link linkend="section_transaction_id">транзакции</link>. </para>
        </listitem>
        <listitem>
          <para>Обепечивать запись исключений в журнал.</para>
        </listitem>
        <listitem>
          <para>Обеспечивать <firstterm>отказоустойчивость</firstterm> (failover) в <link>кластере</link>  для удаленных клиентов.</para>
        </listitem>
        <listitem>
          <para>В бизнес-методах сервисов могут проверяться права пользователя</para>
        </listitem>
      </itemizedlist>
      <para><emphasis role="bold">Реализация</emphasis></para>
      <para>Диаграмма классов, входящих в состав сервиса:</para>
      <mediaobject>
        <imageobject>
          <imagedata align="center" fileref="img/MiddlewareServices.png"/>
        </imageobject>
      </mediaobject>
      <para>Имена интерфейсов сервисов должны заканчиваться на <classname>...Service</classname>, имена реализаций на <classname>...ServiceBean</classname>.</para>
      <para>При создании сервиса необходимо выполнить следующее:</para>
      <procedure>
        <step>
          <para>Создать интерфейс в модуле <structname>global</structname> в пакете <package>app</package> и задать в нем имя сервиса. Имя должно начинаться с имени проекта, затем через символ нижнего подчеркивания должно идти имя сервиса. Например:</para>
          <programlisting language="java">String NAME = &quot;cuba_DataService&quot;;</programlisting>
        </step>
        <step>
          <para>Создать класс сервиса и добавить ему аннотацию <literal>@Service</literal> с именем, заданным в интерфейсе</para>
          <programlisting>@Service(DataService.NAME)</programlisting>
        </step>
        <step>
          <para>При необходимости обращения к базе данных создавать и завершать <link linkend="section_transaction_id">транзакцию</link></para>
          <programlisting>@Inject
private Persistence persistence;
...
Transaction tx = persistence.createTransaction();
try {
    ...
    tx.commit();
} finally {
    tx.end();
}</programlisting>
        </step>
      </procedure>
      <para>Каждый вызов сервиса перехватывается с помощью <link linkend="text_additionally_spring">Spring AOP</link>  и обрамляется вызовом <acronym>ServiceInterceptor.aroundInvoke()</acronym>.</para>
      <warning>
        <para>Сервисы не должны вызывать методы других сервисов ни напрямую, ни через другие объекты, так как это может нарушить логику работы с транзакциями и другие механизмы. В случае вызова сервиса сервисом в журнале приложения появятся соответствующие сообщения об ошибке.</para>
      </warning>
      <tip>
        <title>Совет</title>
        <para>Если некую бизнес-логику требуется вызывать из разных сервисов либо других компонентов <link linkend="section_middleware_id">Middleware</link>, ее необходимо инкапсулировать внутри соответствующего <link linkend="section_managed_beans_id">Managed Bean</link> либо <glossterm linkend="glossary_pojo_id">POJO</glossterm>.</para>
      </tip>
      <para><emphasis role="bold">Использование на клиенте</emphasis></para>
      <para>Для того чтобы вызывать сервис с клиента, для него должен быть создан соответствующий <firstterm>объект-заместитель</firstterm> (прокси-объект). Делается это путем объявления имени и интерфейса сервиса в параметрах объекта <parameter>WebRemoteProxyBeanCreator</parameter> для Web-клиента или <parameter>RemoteProxyBeanCreator</parameter> для  Desktop-клиента.</para>
      <para>Например, чтобы в приложении <application>RefApp</application> вызвать с Web-клиента сервис <classname>refapp_MyService</classname>, необходимо добавить в файл <filename>refapp-web-spring.xml</filename> следующее:</para>
      <programlisting language="xml">&lt;bean id=&quot;refapp_proxyCreator&quot; class=&quot;com.haulmont.cuba.web.sys.remoting.WebRemoteProxyBeanCreator&quot;&gt;
    &lt;property name=&quot;clusterInvocationSupport&quot; ref=&quot;cuba_clusterInvocationSupport&quot;/&gt;
    &lt;property name=&quot;remoteServices&quot;&gt;
        &lt;map&gt;
            &lt;entry key=&quot;refapp_MyService&quot; value=&quot;com.haulmont.refapp.core.app.MyService&quot;/&gt;
        &lt;/map&gt;
    &lt;/property&gt;
&lt;/bean&gt;</programlisting>
      <para>Все импортируемые сервисы должны быть объявлены в одном <firstterm>словаре</firstterm> (map) бина <classname>refapp_proxyCreator</classname>.</para>
      <para>Получить ссылку на сервис с клиента можно двумя способами:</para>
      <itemizedlist>
        <listitem>
          <para><classname>ServiceLocator</classname> </para>
          <programlisting>BookingService service = ServiceLocator.lookup(BookingService.NAME);</programlisting>
        </listitem>
        <listitem>
          <para>Для <glossterm linkend="glossary_controller_id">контроллеров</glossterm> экранов предпочтительный способ − <glossterm linkend="glossary_injection_id">внедрение зависимости</glossterm>.</para>
        </listitem>
      </itemizedlist>
    </section>
    <section id="section_managed_beans_id">
      <title>Управляемые бины</title>
      <para><firstterm>Управляемые бины (Managed Beans)</firstterm> − это программные компоненты, реализующие бизнес-логику приложения и создаваемые в соответствии с принципами <link linkend="glossary_conteiner_id">Inversion of Control</link>. <glossterm>Контейнером</glossterm> для бинов служит <link linkend="text_additionally_spring">Spring Framework</link>.</para>
      <para>Managed Bean представляет собой <firstterm>singleton</firstterm>, то есть всегда используется один экземпляр данного класса. Соответственно, если создаваемый Вами бин содержит изменяемые данные в полях (имеет состояние), то необходимо синхронизировать обращение к таким данным.</para>
      <para>В простейшем случае Managed Bean может быть просто Java-классом, аннотированным как <literal>@ManagedBean</literal>. Однако рекомендуется придерживаться следующих правил создания бинов:</para>
      <itemizedlist>
        <listitem>
          <para>Создать интерфейс бина в пакете <package>app</package> и задать в нем кроме методов поле с именем бина. Имя бина должно иметь префикс с именем проекта. Например:</para>
          <para><programlisting>public interface TaskWorker {
    String NAME = &quot;taskman_TaskWorker&quot;;
    ...</programlisting></para>
        </listitem>
        <listitem>
          <para>Создать класс реализации в пакете <package>app</package> и аннотировать его, указав имя бина:</para>
          <para><programlisting>@ManagedBean(TaskWorker.NAME)
public class TaskWorkerBean implements TaskWorker {
...</programlisting></para>
        </listitem>
      </itemizedlist>
      <para>Данные правила дают возможность в дальнейшем получать ссылки на бин, указывая константу в качестве имени:</para>
      <programlisting>LoginService ls = AppContext.getBean(LoginService.NAME);</programlisting>
      <para>Ссылку на бин в другом управляемом бине (а также  в <link linkend="section_services_id">сервисе</link> или <link linkend="section_MBean_id">МБине</link>) можно получить более простым и естественным способом, объявив поле соответствующего типа и добавив ему аннотацию<literal> @Inject</literal>:</para>
      <programlisting>@Inject
private TaskWorker taskWorker;</programlisting>
      <para>В этом случае контейнер автоматически найдет подходящую реализацию и установит ссылку на объект во время разворачивания приложения в памяти.</para>
      <para>Довольно часто программный компонент, реализующий бизнес-логику, должен иметь состояние (например кэш или конфигурационные данные), и предоставлять интерфейс администратору системы для просмотра и управления этими данными. В этом случае рекомендуется добавить управляемому бину <glossterm linkend="glossary_jmx_id">JMX</glossterm>-интерфейс и превратить его тем самым в <link linkend="section_MBean_id">МБин</link>.</para>
    </section>
    <section id="section_MBean_id">
      <title>Мбины</title>
      <para><firstterm>МБин</firstterm> − программный компонент, реализующий бизнес-логику, и имеющий <glossterm linkend="glossary_jmx_id">JMX</glossterm>-интерфейс. Как правило, имеет внутреннее состояние (например кэш, конфигурационные данные или статистику), к которому нужно обеспечить доступ через JMX.</para>
      <para>МБин является расширенным вариантом <link linkend="section_managed_beans_id">управляемого бина</link>.</para>
      <mediaobject>
        <imageobject>
          <imagedata align="center" fileref="img/MBeans.png"/>
        </imageobject>
      </mediaobject>
      <para>Как видно из диаграммы, МБин имеет два набора методов, разделенных по интерфейсам <interfacename>...MBean</interfacename> и <interfacename>...API</interfacename>. Первый из них служит для управления через JMX, а второй − для вызова из программного кода.</para>
      <para>Вызовы JMX-интерфейса МБина перехватываются специальным классом − <glossterm linkend="glossary_interceptor_id">интерцептором</glossterm> <methodname>MBeanInterceptor.aroundInvoke()</methodname> (с помощью <link linkend="text_additionally_spring">Spring</link> AOP), который обеспечивает журналирование неперехваченных исключений и установку правильного контекстного <classname>ClassLoader</classname>.</para>
      <para>Если JMX-методы МБина работают с данными, то ему потребуется пользовательская сессия с правами на доступ. В этом случае рекомендуется наследовать МБин от базового класса <classname>ManagementBean</classname>, который содержит удобные методы входа в систему/выхода из системы (login/logout).</para>
      <para><emphasis role="bold">Правила создания</emphasis></para>
      <itemizedlist>
        <listitem>
          <para>Создать интерфейс с именем, заканчивающимся на <classname>*MBean</classname>, например, <classname>SampleMBean</classname> в пакете <package>app</package></para>
        </listitem>
        <listitem>
          <para>Если нужно обращение к МБину из кода сервера (а не только из <glossterm linkend="glossary_jmx_id">JMX</glossterm>-консоли), создать интерфейс <interfacename>SampleAPI</interfacename>. Создать в интерфейсе поле с именем бина, в качестве префикса использовать имя проекта:</para>
          <programlisting>public interface SampleAPI {
    String NAME = &quot;myproject_Sample&quot;;
    ...</programlisting>
        </listitem>
        <listitem>
          <para>Создать класс реализации с именем, соответствующим интерфейсу, в нашем случае <classname>Sample</classname> и аннотировать его как <literal>@ManagedBean(SampleAPI.NAME)</literal></para>
        </listitem>
        <listitem>
          <para>Экспортировать <interfacename>*MBean</interfacename> интерфейс в JMX в файле <filename>myproject-spring.xml</filename>, например:</para>
          <programlisting>&lt;bean id=&quot;myproject_MBeanExporter&quot; class=&quot;org.springframework.jmx.export.MBeanExporter&quot; lazy-init=&quot;false&quot;&gt;
        &lt;property name=&quot;beans&quot;&gt;
            &lt;map&gt;
                &lt;entry key=&quot;${cuba.webContextName}:service=Sample&quot; value-ref=&quot;myproject_Sample&quot;/&gt;
            &lt;/map&gt;
        &lt;/property&gt;
        &lt;property name=&quot;assembler&quot;&gt;
            &lt;bean class=&quot;org.springframework.jmx.export.assembler.InterfaceBasedMBeanInfoAssembler&quot;&gt;
                &lt;property name=&quot;interfaceMappings&quot;&gt;
                    &lt;map&gt;
                        &lt;entry key=&quot;myproject_Sample&quot; value=&quot;com.haulmont.myproject.core.app.SampleMBean&quot;/&gt;
                    &lt;/map&gt;
                &lt;/property&gt;
            &lt;/bean&gt;
        &lt;/property&gt;
    &lt;/bean&gt;</programlisting>
        </listitem>
      </itemizedlist>
      <para>Один <link linkend="text_additionally_spring">Spring</link>-объект <classname>MBeanExporter</classname> может экспортировать несколько МБинов. 
Для удобства работы администратора методы JMX-интерфейса должны возвращать строку. В случае успешного выполнения это может быть полезная информация, либо просто строка <computeroutput>Done</computeroutput>. В случае возникновения исключения нужно его записать в журнал и вернуть stacktrace:</para>
      <programlisting>public String jmxMethod1() {
    try {
        return &quot;Done&quot;;
    } catch (Exception e) {
        log.error(&quot;Error executing jmxMethod1&quot;, e);
        return ExceptionUtils.getStackTrace(e);
    } 
}</programlisting>
      <para><emphasis role="bold">Security</emphasis></para>
      <para>Как правило, для выполнения функций МБинов требуется аутентификация в <trademark>CUBA</trademark>-security, а <glossterm linkend="glossary_jmx_id">JMX</glossterm>-интерфейс  ее обеспечить не может. Простой механизм входа в систему/выхода из системы (login/logout) содержится в классе <classname>com.haulmont.cuba.core.app.ManagementBean</classname>, поэтому желательно наследовать свои классы МБинов, работающих с данными, от этого класса. Пример использования:</para>
      <programlisting>public String jmxMethod2() {
    try {
loginOnce(); // defined in ManagementBean
...
return &quot;Done&quot;;
    } catch (Exception e) {
        log.error(&quot;Error executing jmxMethod2&quot;, e);
return ExceptionUtils.getStackTrace(e);
    } 
}</programlisting>
      <para>Методы <methodname>login()</methodname> и <methodname>loginOnce()</methodname>, определенные в классе <classname>ManagementBean</classname>, осуществляют вход в систему, используя имя и пароль, заданные в <link>файле свойств</link> в параметрах  <parameter>cuba.jmxUserLogin</parameter> и <parameter>cuba.jmxUserPassword</parameter> соответственно. Пароль должен быть захеширован и указан с префиксом <code>md5:</code>. Простейший способ получить пароль пользователя в <code>md5</code> − скопировать значение из поля <database>SEC_USER.PASSWORD</database> базы данных.</para>
      <para><emphasis role="bold">Работа с JMX-интерфейсом</emphasis></para>
      <para>Обращаться к МБинам можно с помощью утилиты <application>jconsole</application>, входящей в состав <application>JDK</application>, либо с помощью программы <application>VisualVM</application>.</para>
      <para>Для того чтобы увидеть свои МБины, сервер <application>Tomcat</application> должен быть запущен с опциями удаленного подключения к <glossterm linkend="glossary_jmx_id">JMX</glossterm>. В простейшем случае, без аутентификации, параметры запуска <application>JVM</application> должны содержать следующие опции:</para>
      <programlisting>set CATALINA_OPTS=-Dcom.sun.management.jmxremote
-Dcom.sun.management.jmxremote.port=7777
-Dcom.sun.management.jmxremote.ssl=false
-Dcom.sun.management.jmxremote.authenticate=false</programlisting>
    </section>
    <section id="section_infrastructure_interfaces_id">
      <title>Интерфейсы инфраструктуры</title>
      <para>Интерфейсы инфраструктуры обеспечивают доступ к часто используемой функциональности платформы. Некоторые из этих интерфейсов расположены в модуле <structname>global</structname> и могут быть использованы как изнутри среднего слоя, так и из любого клиентского кода, другие доступны только коду среднего слоя.</para>
      <para>Интерфейсы инфраструктуры реализуются управляемыми компонентами <link linkend="text_additionally_spring">Spring</link>, поэтому зависимости от интерфейсов могут быть <link>внедрены</link> в любые другие управляемые компоненты (Managed Beans, MiddlewareServices, Screen Controllers).</para>
      <para>Все интерфейсы инфраструктуры имеют соответствующие &quot;статические фасады&quot;, которые называются провайдерами, и могут быть использованы в неуправляемых компонентах (<glossterm linkend="glossary_pojo_id">POJO</glossterm>, utility classes, helpers, etc.).</para>
      <para><emphasis role="bold">Глобальные интерфейсы инфраструктуры</emphasis></para>
      <simpara><emphasis role="bold">TimeSource</emphasis>. Обеспечивает получение текущего времени. Применение <classname>new Date()</classname> и т.п. запрещено. Статический фасад − <classname>TimeProvider</classname>.</simpara>
      <simpara><emphasis role="bold">UuidSource</emphasis>. Обеспечивает получение значений <classname>UUID</classname>, в том числе для идентификаторов сущностей. Статический фасад − <classname>UuidProvider</classname>.</simpara>
    </section>
    <section>
      <title>ORM</title>
    </section>
    <section id="section_metadata_framework">
      <title>Metadata Framework</title>
      <mediaobject>
        <imageobject>
          <imagedata align="center" fileref="img/Metadata Framework.png"/>
        </imageobject>
      </mediaobject>
    </section>
    <section id="section_views_id">
      <title>Представления</title>
    </section>
    <section id="section_transaction_id">
      <title>Управление транзакциями</title>
    </section>
  </section>
  <section id="section_client_id">
    <title>Архитектура клиента</title>
    <mediaobject>
      <imageobject>
        <imagedata align="center" fileref="img/ClientStructure.png"/>
      </imageobject>
    </mediaobject>
  </section>
  <section id="section_gui_framework">
    <title>Графический интерфейс пользователя</title>
    <section>
      <title>Библиотека визуальных компонентов</title>
    </section>
    <section>
      <title>Источники данных</title>
    </section>
    <section>
      <title>Создание экранов</title>
    </section>
  </section>
  <section>
    <title>Интеграция со сторонними приложениями</title>
  </section>
  <section>
    <title>Описание конфигурационных файлов</title>
    <para>Соединение с базой данных</para>
    <para>Большинство приложений используют базы данных, и наше приложение не исключение. Для использования базы данных необходимо настроить подключение. Это делается в конфигурационном файле <filename>core/web/META-INF/context.xml</filename> модуля <structname>core</structname>. Например, так:</para>
    <para><programlisting>&lt;Resource
      name=&quot;jdbc/CubaDS&quot;
      type=&quot;javax.sql.DataSource&quot;
      maxActive=&quot;20&quot;
      maxIdle=&quot;2&quot;
      maxWait=&quot;5000&quot;
      driverClassName=&quot;org.postgresql.Driver&quot;
      username=&quot;root&quot;
      password=&quot;root&quot;
      url=&quot;jdbc:postgresql://localhost/shop&quot;/&gt;

    &lt;!-- Microsoft SQLServer connection
    &lt;Resource
      name=&quot;jdbc/CubaDS&quot;
      type=&quot;javax.sql.DataSource&quot;
      maxActive=&quot;20&quot;
      maxIdle=&quot;2&quot;
      maxWait=&quot;5000&quot;
      driverClassName=&quot;net.sourceforge.jtds.jdbc.Driver&quot;
      username=&quot;sa&quot;
      password=&quot;saPass1&quot;
      url=&quot;jdbc:jtds:sqlserver://localhost/refapp&quot;/&gt;
      --&gt;</programlisting></para>
  </section>
</chapter>
