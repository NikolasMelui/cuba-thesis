<?xml version='1.0' encoding='UTF-8'?>
<!-- This document was created with Syntext Serna Free. --><!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" []>
<chapter id="chapter_framework" lang="ru">
  <title>Устройство платформы</title>
  <section>
    <title>Архитектура</title>
    <para>В данной главе рассмотрена архитектура CUBA-приложений в различных разрезах: по уровням, блокам, модулям, и по используемым базовым проектам.</para>
    <section id="app_tiers">
      <title>Уровни и блоки приложения</title>
      <para>Платформа позволяет строить приложения по классической трехуровневой схеме:  клиентский уровень, средний слой, база данных. <firstterm>Уровень</firstterm> отражает степень &quot;удаленности&quot; пользователя от хранимых данных. </para>
      <para>В дальнейшем речь пойдет в основном о среднем слое и клиентах, поэтому для краткости выражение &quot;все уровни&quot; означает два этих уровня.</para>
      <para>На каждом уровне возможно создание одного или нескольких <firstterm>блоков</firstterm> (units) приложения. Блок представляет собой обособленную исполняемую программу, взаимодействующую с другими блоками приложения. Средства платформы <productname>CUBA</productname> позволяют создавать блоки в виде веб-приложений и десктопных приложений. Разработка блоков для мобильных платформ на данный момент остается за рамками  CUBA, однако такие блоки, созданные другими средствами, могут быть интегрированы со стандартными блоками приложения. </para>
      <figure>
        <title>Уровни и блоки приложения</title>
        <mediaobject>
          <imageobject>
            <imagedata contentwidth="80%" align="center" fileref="img/AppTiers.png"/>
          </imageobject>
        </mediaobject>
      </figure>
      <variablelist>
        <varlistentry>
          <term>Middleware</term>
          <listitem>
            <para>Средний слой, содержащий основную бизнес-логику приложения и выполняющий обращения к базе данных. Представляет собой отдельное веб-приложение под управлением стандартного контейнера <glossterm linkend="javaee_web_profile">Java EE Web Profile</glossterm>. См. <xref linkend="middleware"/></para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Web Client</term>
          <listitem>
            <para>Основной блок клиентского уровня. Содержит  интерфейс, предназначенный, как правило, для внутренних пользователей организации. Представляет собой отдельное веб-приложение под управлением стандартного контейнера <application>Java EE Web Profile</application>. Реализация <link linkend="gui_framework">пользовательского интерфейса</link> основана на фреймворке <application>Vaadin</application>. См. <xref linkend="gui_framework"/></para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Desktop Client</term>
          <listitem>
            <para>Дополнительный блок клиентского уровня. Содержит  интерфейс, предназначенный, как правило, для внутренних пользователей организации. Представляет собой десктопное Java-приложение, реализация пользовательского интерфейса основана на фреймворке <application>Java Swing</application>. См. <xref linkend="gui_framework"/></para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Web Portal</term>
          <listitem>
            <para>Дополнительный блок клиентского уровня. Содержит интерфейс для внешних пользователей и средства интеграции с мобильными устройствами и сторонними приложениями. Представляет собой отдельное веб-приложение под управлением стандартного контейнера <application>Java EE Web Profile</application>. Реализация пользовательского интерфейса основана на фреймворке <application>Spring MVC</application>. См. <xref linkend="portal"/></para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>Обязательным блоком любого приложения является средний слой - <structname>Middleware</structname>. Для реализации пользовательского интерфейса как правило используется один или несколько клиентских блоков, например <structname>Web Client</structname> и <structname>Web Portal</structname>. </para>
      <para>Вышеперечисленные блоки являются стандартными, однако в комплексном приложении для разделения функциональности можно без труда создать произвольное количество как клиентских блоков, так и блоков среднего слоя.</para>
      <para>Все клиентские блоки  взаимодействуют со средним слоем одинаковым образом посредством протокола <application>HTTP</application>, что позволяет размещать средний слой произвольным образом, в том числе за сетевым экраном. Следует отметить, что при развертывании в простейшем случае среднего слоя и веб-клиента на одном сервере между ними организуется локальное взаимодействие в обход сетевого стека для снижения накладных расходов.</para>
    </section>
    <section id="app_modules">
      <title>Модули приложения</title>
      <para>Модуль – наименьшая структурная единица CUBA-приложения. Представляет собой один модуль проекта приложения и соответствующий ему JAR файл с исполняемым кодом.</para>
      <para>Стандартные модули: <itemizedlist>
          <listitem>
            <para><structname>global</structname> – включает в себя классы сущностей, интерфейсы сервисов и другие общие для всех уровней классы. Используется во всех <link linkend="app_tiers">блоках приложения</link>.</para>
          </listitem>
          <listitem>
            <para><structname>core</structname> – реализация сервисов и всех остальных компонентов среднего слоя. Используется только на <structname>Middleware</structname>.</para>
          </listitem>
          <listitem>
            <para><structname>gui</structname> – общие компоненты <link linkend="gui_framework">универсального пользовательского интерфейса</link>. Используется в <structname>Web Client</structname> и <structname>Desktop Client</structname>.</para>
          </listitem>
          <listitem>
            <para><structname>web</structname> – реализация универсального пользовательского интерфейса на <application>Vaadin</application>, а также другие специфичные для веб-клиента классы. Используется в блоке <structname>Web Client</structname>.</para>
          </listitem>
          <listitem>
            <para><structname>desktop</structname> – опциональный модуль – реализация универсального пользовательского интерфейса на <application>Java Swing</application>, а также другие специфичные для десктоп-клиента классы. Используется в блоке <structname>Desktop Client</structname>.</para>
          </listitem>
          <listitem>
            <para><structname>portal</structname> – опциональный модуль – реализация веб-портала на <application>Spring MVC</application>.</para>
          </listitem>
        </itemizedlist>  </para>
      <figure>
        <title>Модули приложения</title>
        <mediaobject>
          <imageobject>
            <imagedata contentwidth="80%" align="center" fileref="img/AppModules.png"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>
    <section id="base_projects">
      <title>Базовые проекты</title>
      <para>Функциональность платформы разделена на несколько так называемых <firstterm>базовых проектов</firstterm>: <itemizedlist>
          <listitem>
            <para><structname>cuba</structname> – основной базовый проект, содержит всю функциональность, описанную в данном руководстве, плюс подсистему безопасности (управление пользователями и их доступом к данным)</para>
          </listitem>
          <listitem>
            <para><structname>reports</structname> – подсистема генерации отчетов</para>
          </listitem>
          <listitem>
            <para><structname>workflow</structname> – подсистема управления потоками работ со встроенным визуальным редактором бизнес-процессов</para>
          </listitem>
          <listitem>
            <para><structname>fts</structname> – подсистема полнотекстового поиска</para>
          </listitem>
          <listitem>
            <para><structname>charts</structname> – подсистема вывода диаграмм</para>
          </listitem>
          <listitem>
            <para><structname>ccpayments</structname> – подсистема работы с кредитными картами</para>
          </listitem>
          <listitem>
            <para><structname>bpmn</structname> – механизм исполнения бизнес-процессов по стандарту <application>BPMN 2.0</application></para>
          </listitem>
        </itemizedlist></para>
      <para>Создаваемое на основе платформы приложение может включать в себя функциональность базовых проектов путем объявления зависимостей от их <glossterm linkend="artifact"> артефактов</glossterm>. Зависимость от артефактов <structname>cuba</structname> является обязательной. Опциональные базовые проекты в свою очередь также зависят от <structname>cuba</structname>, и в принципе могут содержать зависимости между собой.</para>
      <figure>
        <title>Зависимости между проектами</title>
        <mediaobject>
          <imageobject>
            <imagedata contentwidth="80%" align="center" fileref="img/BaseProjects.png"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>Сплошными линиями изображены обязательные зависимости, пунктирными − опциональные.</para>
    </section>
    <section>
      <title>Состав приложения</title>
      <para>Вышеописанные архитектурные принципы напрямую отражаются на составе собранного приложения. Рассмотрим его на примере простого приложения  <application>sales</application>, которое имеет 2 блока – <structname>Middleware</structname> и <structname>Web Client</structname>; и включает в себя функциональность базовых проектов <structname>cuba</structname> и <structname>reports</structname>.</para>
      <figure>
        <title>Состав простого приложения</title>
        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="img/SampleAppArtifacts.png"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>На рисунке изображено содержимое некоторых каталогов сервера <application>Tomcat</application> с развернутым в нем приложением <application>sales</application>. </para>
      <para><link linkend="app_tiers">Блок</link><structname> Middleware</structname> реализован веб-приложением <filename>app-core</filename>, блок <structname>Web Client</structname> – веб-приложением <filename>app</filename>. Исполняемый код веб-приложений содержится в каталогах <filename>WEB-INF/lib</filename> в наборе JAR-файлов. Каждый JAR представляет собой результат сборки (<glossterm linkend="artifact">артефакт</glossterm>) одного из <link linkend="app_modules">модулей</link> приложения или <link linkend="base_projects">базового проекта</link>.</para>
      <para>Например, состав JAR-файлов веб-приложения среднего слоя <filename>app-core</filename> определяется тем, что блок <structname>Middleware</structname> состоит из модулей <structname>global</structname> и <structname>core</structname>, и приложение использует базовые проекты <structname>cuba</structname> и <structname>reports</structname> (в данном случае версии 4.0.0). </para>
    </section>
  </section>
  <section>
    <title>Общие компоненты</title>
    <para>В данной главе рассмотрены компоненты платформы, общие для всех <link linkend="app_tiers">уровней</link> приложения.</para>
    <section id="data_model">
      <title>Модель данных</title>
      <para>Предметная область моделируется в приложении с помощью взаимосвязанных классов Java, называемых классами сущностей или просто сущностями. </para>
      <para>Сущности подразделяются на две категории:<itemizedlist>
          <listitem>
            <para>персистентные – экземпляры таких сущностей хранятся в таблицах базы данных</para>
          </listitem>
          <listitem>
            <para>неперсистентные – экземпляры существуют только в оперативной памяти</para>
          </listitem>
        </itemizedlist></para>
      <para>Сущности характеризуются своими атрибутами. Атрибут соответствует полю класса и паре методов доступа (get / set) к полю. Чтобы атрибут был  неизменяемым (read only), достаточно не создавать метод set. </para>
      <para>Персистентные сущности могут включать в себя атрибуты, не хранящиеся в БД. В случае неперсистентного атрибута можно не создавать поле класса, ограничившись методами доступа.</para>
      <para>Класс сущности должен удовлетворять следующим требованиям: <itemizedlist>
          <listitem>
            <para>наследоваться от одного из базовых классов, предоставляемых платформой (см. ниже)</para>
          </listitem>
          <listitem>
            <para>иметь набор полей и методов доступа, соответствующих атрибутам сущностей</para>
          </listitem>
          <listitem>
            <para>класс и его поля (или методы доступа при отсутствии для атрибута соответствующего поля)  должны быть определенным образом <link linkend="entity_annotations">аннотированы</link> для работы <glossterm linkend="jpa">JPA</glossterm> (в случае персистентной сущности) и <link linkend="metadata_framework">фреймворка метаданных</link> </para>
          </listitem>
          <listitem>
            <para>для поддержки возможного <link linkend="extension">расширения</link> сущностей поля класса необходимо объявлять с модификатором <code>protected</code>, а не <code>private</code></para>
          </listitem>
        </itemizedlist></para>
      <para>Поддерживаются следующие типы атрибутов сущностей:<itemizedlist>
          <listitem>
            <para><code>java.lang.String</code></para>
          </listitem>
          <listitem>
            <para><code>java.lang.Boolean</code></para>
          </listitem>
          <listitem>
            <para><code>java.lang.Integer</code></para>
          </listitem>
          <listitem>
            <para><code>java.lang.Long</code></para>
          </listitem>
          <listitem>
            <para><code>java.lang.Double</code></para>
          </listitem>
          <listitem>
            <para><code>java.math.BigDecimal</code></para>
          </listitem>
          <listitem>
            <para><code>java.util.Date</code></para>
          </listitem>
          <listitem>
            <para><code>java.sql.Date</code></para>
          </listitem>
          <listitem>
            <para><code>java.sql.Time</code></para>
          </listitem>
          <listitem>
            <para><code>java.util.UUID</code></para>
          </listitem>
          <listitem>
            <para><code>byte[]</code></para>
          </listitem>
          <listitem>
            <para><code>enum</code></para>
          </listitem>
          <listitem>
            <para>сущность</para>
          </listitem>
        </itemizedlist></para>
      <section>
        <title>Базовые классы сущностей</title>
        <para>Рассмотрим базовые классы и интерфейсы сущностей более подробно.</para>
        <figure id="entity_base_classes">
          <title>Базовые классы сущностей</title>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/EntityClasses.png"/>
            </imageobject>
          </mediaobject>
        </figure>
        <itemizedlist>
          <listitem>
            <para><code>Instance</code> – декларирует базовые методы работы с объектами предметной области: <itemizedlist>
                <listitem>
                  <para>получение ссылки на мета-класс объекта</para>
                </listitem>
                <listitem>
                  <para>генерация имени экземпляра</para>
                </listitem>
                <listitem>
                  <para>чтение/установка значений атрибутов по имени</para>
                </listitem>
                <listitem>
                  <para>добавление слушателей, получающих уведомления об изменениях атрибутов</para>
                </listitem>
              </itemizedlist></para>
          </listitem>
          <listitem>
            <para><code>Entity</code> – дополняет <code>Instance</code> понятием идентификатора сущности, причем <code>Entity</code> не определяет тип идентификатора, оставляя эту возможность наследникам</para>
          </listitem>
          <listitem>
            <para><code>AbstractInstance</code> – реализует логику работы со слушателями изменения атрибутов</para>
            <warning>
              <para><code>AbstractInstance</code> хранит слушателей в коллекции <code>WeakReference</code>, т.е. при отсутствии внешних ссылок на добавленного слушателя, он будет немедленно уничтожен сборщиком мусора. Как правило, слушателями изменения атрибутов являются <link linkend="gui_vcl">визуальные компоненты</link> и <link linkend="datasources">источники данных</link> UI, на которые всегда имеются ссылки из других объектов, поэтому проблема исчезновения слушателей не возникает. Однако если слушатель создается прикладным кодом и на него никто не ссылается естественным образом, необходимо кроме добавления в <code>Instance</code> сохранить  его в некотором поле объекта.</para>
            </warning>
          </listitem>
          <listitem>
            <para><code>AbstractNotPersistentEntity</code> – базовый класс неперсистентных сущностей с идентификаторами типа <code>UUID</code>.</para>
          </listitem>
          <listitem>
            <para><code>BaseEntity</code> – декларирует присущие всем персистентным сущностям методы работы с информацией о том, кто и когда создал экземпляр сущности в базе данных </para>
          </listitem>
          <listitem>
            <para><code>BaseUuidEntity</code> - реализует <code>BaseEntity</code> с типом идентификатора <code>UUID</code> и поддержкой <glossterm linkend="jpa">JPA</glossterm></para>
          </listitem>
          <listitem>
            <para><code>Versioned</code> – интерфейс сущностей, поддерживающих <glossterm linkend="optimistic_locking">оптимистичную блокировку</glossterm></para>
          </listitem>
          <listitem>
            <para><code>Updatable</code> – интерфейс сущностей, для которых требуется сохранять информацию о том, кто и когда изменял экземпляр в последний раз</para>
          </listitem>
          <listitem>
            <para><code>SoftDelete</code> – интерфейс сущностей, поддерживающих <link linkend="soft_deletion">мягкое удаление</link></para>
          </listitem>
          <listitem>
            <para><code>StandardEntity</code> – наиболее часто используемый базовый класс персистентных сущностей, реализующий вышеперечисленные интерфейсы</para>
          </listitem>
        </itemizedlist>
        <para>При создании классов сущностей рекомендуется выбирать базовый класс по следующим правилам:<itemizedlist>
            <listitem>
              <para>если сущность не хранится в БД, наследуйте ее от <code>AbstractNotPersistentEntity</code></para>
            </listitem>
            <listitem>
              <para>если сущность встраиваемая - наследуйте ее от <code>EmbeddableEntity</code></para>
            </listitem>
            <listitem>
              <para>если сущность только создается в БД, никогда не изменяется, и мягкое удаление не требуется - наследуйте ее от <code>BaseUuidEntity</code></para>
            </listitem>
            <listitem>
              <para>если сущность ведет себя стандартным образом: изменяется в БД, требует оптимистичной блокировки и мягкого удаления   − наследуйте ее от <code>StandardEntity</code></para>
            </listitem>
            <listitem>
              <para>в противном случае наследуйте сущность от <code>BaseUuidEntity</code> и реализуйте в классе тот набор интерфейсов <code>Versioned</code>, <code>Updatable</code>, <code>SoftDelete</code>, который требуется</para>
            </listitem>
          </itemizedlist></para>
        <para/>
      </section>
      <section id="entity_annotations">
        <title>Аннотации сущностей</title>
        <para>В данном разделе описаны все поддерживаемые платформой аннотации классов и атрибутов сущностей. </para>
        <para>Аннотации пакета <code>javax.persistence</code> обеспечивают работу <glossterm linkend="jpa">JPA</glossterm>, аннотации пакетов <code>com.haulmont.*</code> предназначены для управления <link linkend="metadata_framework">метаданными</link> и другими механизмами платформы. </para>
        <para>Если для аннотации указано только простое имя класса, подразумевается что это класс платформы, расположенный в одном  из пакетов <code>com.haulmont.*</code></para>
        <section>
          <title>Аннотации класса</title>
          <variablelist>
            <varlistentry id="entity_annotation">
              <term>
                <code>
                  <ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/Entity.html">@javax.persistence.Entity</ulink>
                </code>
              </term>
              <listitem>
                <para>Объявляет класс сущностью модели данных. </para>
                <para>Параметры:<itemizedlist>
                    <listitem>
                      <para><code>name</code> - имя сущности, обязательно должно начинаться с префикса, отделенного знаком <literal>$</literal>. Желательно использовать в качестве префикса короткое имя проекта для формирования отдельного пространства имен. </para>
                    </listitem>
                  </itemizedlist></para>
                <para>Пример:<programlisting>@Entity(name = &quot;sales$Customer&quot;)</programlisting></para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <code>
                  <ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/MappedSuperclass.html">@javax.persistence.MappedSuperclass</ulink>
                </code>
              </term>
              <listitem>
                <para>Определяет, что данный класс является предком некоторых сущностей, и его атрибуты должны быть использованы в составе сущностей-наследников. Такой класс не сопоставляется никакой отдельной таблице БД.</para>
              </listitem>
            </varlistentry>
            <varlistentry id="table_annotation">
              <term>
                <code>@<ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/Table.html">javax.persistence.Table</ulink></code>
              </term>
              <listitem>
                <para>Определяет таблицу базы данных для данной сущности. </para>
                <para>Параметры:<itemizedlist>
                    <listitem>
                      <para><code>name</code> - имя таблицы</para>
                    </listitem>
                  </itemizedlist></para>
                <para>Пример:<programlisting>@Table(name = &quot;SALES_CUSTOMER&quot;)</programlisting></para>
              </listitem>
            </varlistentry>
            <varlistentry id="embeddable_annotation">
              <term>
                <code>
                  <ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/Embeddable.html">@javax.persistence.Embeddable</ulink>
                </code>
              </term>
              <listitem>
                <para>Определяет встраиваемую сущность, экземпляры которой хранятся вместе с владеющей сущностью в той же таблице. </para>
                <para>Для задания имени сущности тебуется применение аннотации <link linkend="metaclass_annotation">
                    <code>@MetaClass</code>
                  </link>.</para>
              </listitem>
            </varlistentry>
            <varlistentry id="inheritance_annotation">
              <term>
                <code>
                  <ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/Inheritance.html">@javax.persistence.Inheritance</ulink>
                </code>
              </term>
              <listitem>
                <para>Определяет стратегию наследования для иерархии классов сущностей. Данная аннотация должна быть помещена на корневом классе иерархии. </para>
                <para>Параметры:<itemizedlist>
                    <listitem>
                      <para><code>strategy</code> - стратегия, по умолчанию <code>SINGLE_TABLE</code></para>
                    </listitem>
                  </itemizedlist></para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <code>@<ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/DiscriminatorColumn.html">javax.persistence.DiscriminatorColumn</ulink></code>
              </term>
              <listitem>
                <para>Используется для определения колонки БД, отвечающей за различение типов сущностей в случае стратегий наследования <code>SINGLE_TABLE</code> и <code>JOINED</code>. </para>
                <para>Параметры:<itemizedlist>
                    <listitem>
                      <para><code>name</code> - имя колонки-дискриминатора</para>
                    </listitem>
                    <listitem>
                      <para><code>discriminatorType</code> - тип данных колонки-дискриминатора</para>
                    </listitem>
                  </itemizedlist></para>
                <para>Пример:<programlisting>@DiscriminatorColumn(name = &quot;TYPE&quot;, discriminatorType = DiscriminatorType.INTEGER)</programlisting></para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <code>
                  <ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/DiscriminatorValue.html">@javax.persistence.DiscriminatorValue</ulink>
                </code>
              </term>
              <listitem>
                <para>Определяет значение колонки-дискриминатора для данной сущности. Эта аннотация должна быть помещена на конкретном классе сущности. </para>
                <para>Пример:<programlisting>@DiscriminatorValue(&quot;0&quot;)</programlisting></para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <code>
                  <ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/PrimaryKeyJoinColumn.html">@javax.persistence.PrimaryKeyJoinColumn</ulink>
                </code>
              </term>
              <listitem>
                <para>Используется в случае стратегии наследования <code>JOINED</code> для указания колонки внешнего ключа данной сущности, ссылающегося на первичный ключ сущности-предка.  </para>
                <para>Параметры:<itemizedlist>
                    <listitem>
                      <para><code>name</code> - имя колонки внешнего ключа данной сущности</para>
                    </listitem>
                    <listitem>
                      <para><code>referencedColumnName</code> - имя колонки первичного ключа сущности предка</para>
                    </listitem>
                  </itemizedlist></para>
                <para>Пример:<programlisting>@PrimaryKeyJoinColumn(name = &quot;CARD_ID&quot;, referencedColumnName = &quot;ID&quot;)</programlisting></para>
              </listitem>
            </varlistentry>
            <varlistentry id="namePattern">
              <term>
                <code>@NamePattern</code>
              </term>
              <listitem>
                <para>Определяет способ получения имени экземпляра, возвращаемого методом <code>Instance.getInstanceName()</code>.</para>
                <para>Значением аннотации должна быть строка вида <literal>{0}|{1}</literal>, где <itemizedlist>
                    <listitem>
                      <para><literal>{0}</literal> - строка форматирования по правилам  <code>String.format()</code>, или имя метода данного объекта с префиксом <literal>#</literal>. Метод должен возвращать <code>String</code> и не иметь параметров.</para>
                    </listitem>
                    <listitem>
                      <para><literal>{1}</literal> - разделенный запятыми список имен полей класса, соответствующий формату <literal>{0}</literal>. В случае использования в <literal>{0}</literal> метода список полей все равно необходим, так как по нему формируется <link linkend="views">представление</link> <literal>_minimal</literal>.</para>
                    </listitem>
                  </itemizedlist></para>
                <para>Примеры:<programlisting>@NamePattern(&quot;%s|name&quot;)</programlisting><programlisting>@NamePattern(&quot;#getCaption|login,name&quot;)</programlisting></para>
              </listitem>
            </varlistentry>
            <varlistentry id="listeners_annotation">
              <term>
                <code>@Listeners</code>
              </term>
              <listitem>
                <para>Определяет список слушателей, предназначенных для реакции на события жизненного цикла экземпляров сущности на <link linkend="app_tiers">уровне</link><structname> Middleware</structname>. </para>
                <para>Значением аннотации должна быть строка или массив строк с именами классов слушателей - см. <xref linkend="entity_listeners"/></para>
                <para>Строки используются здесь вместо ссылок на классы потому, что классы слушателей находятся только на уровне <structname>Middleware</structname> и не доступны клиентскому коду, в то время как классы самих сущностей используются на всех уровнях.</para>
                <para>Примеры:<programlisting>@Listeners(&quot;com.haulmont.cuba.security.listener.UserEntityListener&quot;)</programlisting><programlisting>@Listeners({&quot;com.abc.sales.entity.FooListener&quot;,&quot;com.abc.sales.entity.BarListener&quot;})</programlisting></para>
              </listitem>
            </varlistentry>
            <varlistentry id="metaclass_annotation">
              <term>
                <code>@MetaClass</code>
              </term>
              <listitem>
                <para>Используется для объявления неперсистентной или <link linkend="embeddable_annotation">встраиваемой</link> сущности (т.е. когда аннотация <code>@javax.persistence.Entity</code> не применима)  </para>
                <para>Параметры:<itemizedlist>
                    <listitem>
                      <para><code>name</code> - имя сущности, обязательно должно начинаться с префикса, отделенного знаком <literal>$</literal>. Желательно использовать в качестве префикса короткое имя проекта для формирования отдельного пространства имен.</para>
                    </listitem>
                  </itemizedlist></para>
                <para>Пример:<programlisting>@MetaClass(name = &quot;sys$LockInfo&quot;)</programlisting></para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <code>@SystemLevel</code>
              </term>
              <listitem>
                <para>Указывает, что данная сущность является системной и не должна быть доступна для выбора пользователем в различных списках сущностей, например как тип параметра универсального фильтра или тип <link linkend="runtime_properties">динамического атрибута</link>.  </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <code>@EnableRestore</code>
              </term>
              <listitem>
                <para>Указывает, что экземпляры данной сущности доступны для восстановления после <link linkend="soft_deletion">мягкого удаления</link> в специальном экране <literal>core$Entity.restore</literal>. </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <code>@TrackEditScreenHistory</code>
              </term>
              <listitem>
                <para>Указывает, что для данной сущности будет запоминаться история открытия экранов редактирования (<literal>{имя_сущности}.edit</literal>) с возможностью отображения в специальном экране <literal>sec$ScreenHistory.browse</literal>.  </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <code>@Extends</code>
              </term>
              <listitem>
                <para>Указывает, что  данная сущность является расширением и должна повсеместно использоваться вместо базовой. См. <xref linkend="extension"/>  </para>
              </listitem>
            </varlistentry>
          </variablelist>
        </section>
        <section>
          <title>Аннотации атрибутов</title>
          <para>Аннотации атрибутов устанавливаются на соответствующие поля класса, за одним исключением: если требуется объявить неизменяемый (read only) неперсистентный атрибут <literal>foo</literal>, то достаточно создать метод доступа <code>getFoo()</code> и поместить на этот метод аннотацию <code>@MetaProperty</code>.</para>
          <variablelist>
            <varlistentry>
              <term>
                <code>
                  <ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/Transient.html">@javax.persistence.Transient</ulink>
                </code>
              </term>
              <listitem>
                <para>Указывает, что данное поле не хранится в БД, т.е. является неперсистентным. </para>
                <para>Поля поддерживаемых <glossterm linkend="jpa">JPA</glossterm> типов (см. <ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/Basic.html">http://docs.oracle.com/javaee/5/api/javax/persistence/Basic.html</ulink>) <emphasis>по умолчанию являются персистентными</emphasis>, поэтому аннотация <code>@Transient</code> обязательна для объявления неперсистентного атрибута такого типа. </para>
                <para>Для включения <code>@Transient</code> атрибута в метаданные, необходимо также указать аннотацию <code>
                    <link linkend="metaProperty_annotation">@MetaProperty</link>
                  </code>. </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <code>@org.apache.openjpa.persistence.Persistent</code>
              </term>
              <listitem>
                <para>Указывает, что данное поле хранится в БД, т.е. является персистентным.</para>
                <para>Данная аннотация требуется только для нестандартного для <glossterm linkend="jpa">JPA</glossterm> типа поля, платформа на данный момент поддерживает  один такой тип - <code>java.util.UUID</code>. Таким образом, <code>@Persistent</code> требуется только в одном случае - при объявлении персистентного поля типа <code>UUID</code>.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <code>
                  <ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/Column.html">@javax.persistence.Column</ulink>
                </code>
              </term>
              <listitem>
                <para>Определяет колонку БД, в которой будут храниться значения данного атрибута. </para>
                <para>Параметры:<itemizedlist>
                    <listitem>
                      <para><code>name</code> - имя колонки</para>
                    </listitem>
                    <listitem>
                      <para><code>length</code> - (необязательный параметр, по умолчанию <literal>255</literal>) - длина колонки. Используется также при формировании <link linkend="metadata_framework">метаданных</link> и в конечном счете может ограничивать максимальныю длину вводимого текста в визуальных компонентах, работающих с данным атрибутом.</para>
                    </listitem>
                    <listitem>
                      <para><code>nullable</code> - (необязательный параметр, по умолчанию <code>true</code>) - может ли атрибут содержать  <code>null</code>. При указании <code>nullable = false</code> <glossterm linkend="jpa">JPA</glossterm> контролирует наличие значения поля при сохранении, кроме того, визуальные компоненты, работающих с данным атрибутом, могут сигнализировать пользователю о необходимости ввода значения.</para>
                    </listitem>
                  </itemizedlist></para>
              </listitem>
            </varlistentry>
            <varlistentry id="manyToOne">
              <term>
                <code>
                  <ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/ManyToOne.html">@javax.persistence.ManyToOne</ulink>
                </code>
              </term>
              <listitem>
                <para>Определяет атрибут-ссылку на сущность с типом ассоциации много-к-одному. </para>
                <para>Параметры:<itemizedlist>
                    <listitem>
                      <para><code>fetch</code> - (по умолчанию <code>EAGER</code>) параметр, определяющий, будет ли JPA <glossterm linkend="eager_fetching">энергично</glossterm> загружать ассоциированную сущность. Данный параметр всегда должен быть установлен в значение <code>LAZY</code>, так как в CUBA-приложении политика загрузки связей определяется динамически на основе механизма <link linkend="views">представлений</link>.</para>
                    </listitem>
                    <listitem>
                      <para><code>optional</code> - (необязательный параметр, по умолчанию <code>true</code>) - может ли атрибут содержать  <code>null</code>. При указании <code>optional = false</code> <glossterm linkend="jpa">JPA</glossterm> контролирует наличие ссылки при сохранении, кроме того, визуальные компоненты, работающих с данным атрибутом, могут сигнализировать пользователю о необходимости ввода значения.</para>
                    </listitem>
                  </itemizedlist></para>
                <para>Например, несколько экземпляров <code>Order</code> (заказов) ссылаются на один экземпляр <code>Customer</code> (покупателя), в этом случае класс <code>Order</code> должен содержать следующее объявление:<programlisting>@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = &quot;CUSTOMER_ID&quot;)
protected Customer customer;</programlisting></para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <code>
                  <ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/OneToMany.html">@javax.persistence.OneToMany</ulink>
                </code>
              </term>
              <listitem>
                <para>Определяет атрибут-коллекцию ссылок на сущность с типом ассоциации один-ко-многим. </para>
                <para>Параметры:<itemizedlist>
                    <listitem>
                      <para><code>mappedBy</code> - поле связанной сущности, определяющее ассоциацию </para>
                    </listitem>
                    <listitem>
                      <para><code>targetEntity</code> - тип связанной сущности. Необязательный параметр, если коллекция объявлена с использованием <application>Java generics</application>. </para>
                    </listitem>
                    <listitem>
                      <para><code>fetch</code> - (необязательный параметр, по умолчанию <code>LAZY</code>) - определяет, будет ли JPA <glossterm linkend="eager_fetching">энергично</glossterm> загружать коллекцию связанных сущностей. Необходимо всегда оставлять значение по умолчанию <code>LAZY</code>, так как в CUBA-приложении политика загрузки связей определяется динамически на основе механизма <link linkend="views">представлений</link>.</para>
                    </listitem>
                    <listitem>
                      <para><code>cascade</code> - (необязательный параметр, по умолчанию <code>{}</code>) - каскадирование операций определяет, какие операции над сущностью должны быть применены к ассоциированным сущностям. Каскадирование на данном уровне не рекомендуется использовать.</para>
                    </listitem>
                  </itemizedlist></para>
                <para>Например, несколько экземпляров <code>Item</code> (пунктов заказа) ссылаются на один экземпляр <code>Order</code> (заказ) с помощью <code>@ManyToOne</code> поля <code>Item.order</code>, в этом случае класс <code>Order</code> может содержать коллекцию экземпляров <code>Item</code>:<programlisting>@OneToMany(mappedBy = &quot;order&quot;)
protected Set&lt;Item&gt; items;</programlisting></para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <code>
                  <ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/OneToOne.html">@javax.persistence.OneToOne</ulink>
                </code>
              </term>
              <listitem>
                <para>Определяет атрибут-ссылку на сущность с типом ассоциации один-к-одному. </para>
                <para>Параметры:<itemizedlist>
                    <listitem>
                      <para><code>fetch</code> - (по умолчанию <code>EAGER</code>) параметр, определяющий, будет ли JPA <glossterm linkend="eager_fetching">энергично</glossterm> загружать ассоциированную сущность. Данный параметр всегда должен быть установлен в значение <code>LAZY</code>, так как в CUBA-приложении политика загрузки связей определяется динамически на основе механизма <link linkend="views">представлений</link>.</para>
                    </listitem>
                    <listitem>
                      <para><code>mappedBy</code> - поле связанной сущности, определяющее ассоциацию. Требуется устанавливать только на ведомой стороне ассоциации. </para>
                    </listitem>
                    <listitem>
                      <para><code>optional</code> - (необязательный параметр, по умолчанию <code>true</code>) - может ли атрибут содержать  <code>null</code>. При указании <code>optional = false</code> <glossterm linkend="jpa">JPA</glossterm> контролирует наличие ссылки при сохранении, кроме того, визуальные компоненты, работающих с данным атрибутом, могут сигнализировать пользователю о необходимости ввода значения.</para>
                    </listitem>
                  </itemizedlist></para>
                <para>Пример ведущей стороны ассоциации, класс <code>Driver</code>:<programlisting>@OneToOne(fetch = FetchType.LAZY)
@JoinColumn(name = &quot;CALLSIGN_ID&quot;)
protected DriverCallsign callsign;</programlisting></para>
                <para>Пример ведомой стороны ассоциации, класс <code>DriverCallsign</code>:<programlisting>@OneToOne(fetch = FetchType.LAZY, mappedBy = &quot;callsign&quot;)
protected Driver driver;</programlisting></para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <code>
                  <ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/ManyToMany.html">@javax.persistence.ManyToMany</ulink>
                </code>
              </term>
              <listitem>
                <para>Определяет атрибут-коллекцию ссылок на сущность с типом ассоциации много-ко-многим.</para>
                <para>Ассоциация много-ко-многим всегда имеет ведущую сторону и может иметь обратную сторону - ведомую. На ведущей строне указывается дополнительная аннотация <code>@JoinTable</code>, на ведомой стороне - параметр <code>mappedBy</code>.</para>
                <para>Параметры:<itemizedlist>
                    <listitem>
                      <para><code>mappedBy</code> - поле связанной сущности, определяющее ассоциацию с ведущей стороны. Необходимо указывать только на ведомой стороне.</para>
                    </listitem>
                    <listitem>
                      <para><code>targetEntity</code> - тип связанной сущности. Необязательный параметр, если коллекция объявлена с использованием <application>Java generics</application>. </para>
                    </listitem>
                    <listitem>
                      <para><code>fetch</code> - (необязательный параметр, по умолчанию <code>LAZY</code>) - определяет, будет ли JPA <glossterm linkend="eager_fetching">энергично</glossterm> загружать коллекцию связанных сущностей. Необходимо всегда оставлять значение по умолчанию <code>LAZY</code>, так как в CUBA-приложении политика загрузки связей определяется динамически на основе механизма <link linkend="views">представлений</link>.</para>
                    </listitem>
                  </itemizedlist></para>
                <para>Пример:<programlisting>TODO</programlisting></para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <code>
                  <ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/JoinColumn.html">@javax.persistence.JoinColumn</ulink>
                </code>
              </term>
              <listitem>
                <para>Используется для указания колонки БД, определяющей ассоциацию между сущностями.  </para>
                <para>Параметры:<itemizedlist>
                    <listitem>
                      <para><code>name</code> - имя колонки</para>
                    </listitem>
                  </itemizedlist></para>
                <para>Пример:<programlisting>@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = &quot;CUSTOMER_ID&quot;)
protected Customer customer;</programlisting></para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <code>
                  <ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/JoinTable.html">@javax.persistence.JoinTable</ulink>
                </code>
              </term>
              <listitem>
                <para>Используется для указания таблицы связи на ведущей стороне <code>@ManyToMany</code> ассоциации. </para>
                <para>Параметры:<itemizedlist>
                    <listitem>
                      <para><code>name</code> - имя таблицы связи</para>
                    </listitem>
                    <listitem>
                      <para><code>joinColumns</code> - элемент <code>@JoinColumn</code>, определяющий колонку таблицы связей, соответствующую первичному ключу ведущей стороны ассоциации (т.е. содержащей аннотацию <code>@JoinTable</code>)</para>
                    </listitem>
                    <listitem>
                      <para><code>inverseJoinColumns</code> - элемент <code>@JoinColumn</code>, определяющий колонку таблицы связей, соответствующую первичному ключу ведомой стороны ассоциации</para>
                    </listitem>
                  </itemizedlist></para>
                <para>Пример атрибута <code>customers</code> класса <code>Group</code>, являющегося ведущей стороной ассоциации:<programlisting>@ManyToMany
@JoinTable(name = &quot;SALES_CUSTOMER_GROUP_LINK&quot;,
    joinColumns = @JoinColumn(name = &quot;GROUP_ID&quot;),
    inverseJoinColumns = @JoinColumn(name = &quot;CUSTOMER_ID&quot;))
protected Set&lt;Customer&gt; customers;</programlisting></para>
                <para>Пример атрибута <code>groups</code> класса <code>Customer</code>, являющегося ведомой стороной этой же ассоциации:<programlisting>@ManyToMany(mappedBy = &quot;customers&quot;)
protected Set&lt;Group&gt; groups;</programlisting></para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <code>
                  <ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/OrderBy.html">@javax.persistence.OrderBy</ulink>
                </code>
              </term>
              <listitem>
                <para>Определяет порядок элементов в атрибуте-коллекции на момент извлечения из базы данных. Данную аннотацию необходимо задавать для упорядоченных коллекций, таких как <code>List</code> или <code>LinkedHashSet</code> для получения предсказуемого порядка следования элементов.</para>
                <para>Параметры:<itemizedlist>
                    <listitem>
                      <para><code>value</code> - строка, определяющая порядок, в формате:<programlisting>orderby_list::= orderby_item [,orderby_item]*
orderby_item::= property_or_field_name [ASC | DESC]</programlisting></para>
                    </listitem>
                  </itemizedlist></para>
                <para>Пример:<programlisting>@OneToMany(mappedBy = &quot;user&quot;)
@OrderBy(&quot;createTs&quot;)
protected List&lt;UserRole&gt; userRoles;</programlisting></para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <code>
                  <ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/Embedded.html">@javax.persistence.Embedded</ulink>
                </code>
              </term>
              <listitem>
                <para>Определяет атрибут типа встраиваемой сущности, в свою очередь аннотированной <code>@Embeddable</code>. </para>
                <para>Пример:<programlisting>@Embedded
protected Address address;</programlisting></para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <code>
                  <ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/Temporal.html">@javax.persistence.Temporal</ulink>
                </code>
              </term>
              <listitem>
                <para>Для атрибута типа <code>java.util.Date</code> уточняет тип хранимого значения: дата, время или дата+время. </para>
                <para>Параметры:<itemizedlist>
                    <listitem>
                      <para><code>value</code> - тип хранимого значения: <code>DATE</code>, <code>TIME</code>, <code> TIMESTAMP</code></para>
                    </listitem>
                  </itemizedlist></para>
                <para>Пример:<programlisting>@Column(name = &quot;START_DATE&quot;)
@Temporal(TemporalType.DATE)
protected Date startDate;</programlisting></para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <code>
                  <ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/Version.html">@javax.persistence.Version</ulink>
                </code>
              </term>
              <listitem>
                <para>Указывает, что данное поле хранит версию для поддержки <glossterm linkend="optimistic_locking">оптимистичной блокировки</glossterm> сущностей. </para>
                <para>Применение такого поля необходимо при реализации классом сущности интерфейса <code>Versioned</code> (базовый класс <code>StandardEntity</code> уже содержит такое поле).</para>
                <para>Пример:<programlisting>@Version
@Column(name = &quot;VERSION&quot;)
private Integer version;</programlisting></para>
              </listitem>
            </varlistentry>
            <varlistentry id="metaProperty_annotation">
              <term>
                <code>@MetaProperty</code>
              </term>
              <listitem>
                <para>Указывает, что данный атрибут должен быть включен в <link linkend="metadata_framework">метаданные</link>. Данная аннотация может быть установлена как на поле класса, так и на метод доступа, в случае отсутствия соответствующего атрибуту поля.</para>
                <para>Данная аннотация не обязательна для полей, снабженных следующими аннотациями пакета <code>javax.persistence</code>: <code>@Column</code>, <code>@OneToOne</code>, <code>@OneToMany</code>, <code>@ManyToOne</code>, <code>@ManyToMany</code>, <code>@Embedded</code>. Такие поля отражаются в метаданных автоматически. Поэтому <code>@MetaProperty</code> в основном применяется для определения неперсистентных атрибутов сущностей. </para>
                <para>Параметры:<itemizedlist>
                    <listitem>
                      <para><code>mandatory</code> - (необязательный параметр, по умолчанию <code>false</code>) - может ли атрибут содержать  <code>null</code>. При указании <code>mandatory = true</code> визуальные компоненты, работающих с данным атрибутом, могут сигнализировать пользователю о необходимости ввода значения.</para>
                    </listitem>
                  </itemizedlist></para>
                <para>Пример использования для поля:<programlisting>@Transient
@MetaProperty
protected String token;</programlisting></para>
                <para>Пример использования для метода:<programlisting>@MetaProperty
public String getLocValue() {
    if (!StringUtils.isBlank(messagesPack)) {
        return AppBeans.get(Messsages.class).getMessage(messagesPack, value);
    } else {
        return value;
    }
}</programlisting></para>
              </listitem>
            </varlistentry>
            <varlistentry id="onDelete_annotation">
              <term>
                <code>@OnDelete</code>
              </term>
              <listitem>
                <para>Определяет политику обработки связи в случае мягкого удаления сущности, содержащей данный атрибут. См. <xref linkend="soft_deletion"/></para>
                <para>Пример:<programlisting>@OneToMany(mappedBy = &quot;group&quot;)
@OnDelete(DeletePolicy.CASCADE)
private Set&lt;Constraint&gt; constraints;</programlisting></para>
              </listitem>
            </varlistentry>
            <varlistentry id="onDeleteInverse_annotation">
              <term>
                <code>@OnDeleteInverse</code>
              </term>
              <listitem>
                <para>Определяет политику обработки связи в случае мягкого удаления сущности с обратной стороны ассоциации. См. <xref linkend="soft_deletion"/> </para>
                <para>Пример:<programlisting>@ManyToOne
@JoinColumn(name = &quot;DRIVER_ID&quot;)
@OnDeleteInverse(DeletePolicy.DENY)
private Driver driver;</programlisting></para>
              </listitem>
            </varlistentry>
            <varlistentry id="composition_annotation">
              <term>
                <code>@Composition</code>
              </term>
              <listitem>
                <para>Указывает на то, что связь является композицией - более тесным вариантом ассоциации. Это означает, что связанная сущность имеет смысл только как часть владеющей сущности, т.е. создается и удаляется вместе с ней. </para>
                <para>Например список пунктов в заказе (класс <code>Order</code> содержит коллекцию экземпляров <code>Item</code>):<programlisting>@OneToMany(mappedBy = &quot;order&quot;)
@Composition
protected List&lt;Item&gt; items;</programlisting></para>
                <para>Указание для связи аннотации <code>@Composition</code> позволяет организовать в <link linkend="screen_edit">экранах редактирования</link> специальный <link linkend="datasource_commitMode">режим коммита</link> источников данных, при котором изменения экземпляров детализирующей сущности сохраняются в базе данных только при коммите основной сущности.</para>
              </listitem>
            </varlistentry>
            <varlistentry id="localizedValue_annotation">
              <term>
                <code>@LocalizedValue</code>
              </term>
              <listitem>
                <para>Служит для описания способа получения локализованного значения некоторого изменяющегося атрибута, которое возвращает метод <code><link linkend="messageTools">MessageTools</link>.getLocValue()</code>. </para>
                <para>Параметры:<itemizedlist>
                    <listitem>
                      <para><code>messagePack</code> - явное указание пакета, из которого будет взято локализованное сообщение, например <code>com.haulmont.cuba.core.entity</code></para>
                    </listitem>
                    <listitem>
                      <para><code>messagePackExpr</code> - выражение в терминах пути к атрибуту, хранящему имя пакета, из которого будет взято локализованное сообщение, например <code>proc.messagesPack</code>. Путь начинается с атрибута текущей сущности. </para>
                    </listitem>
                  </itemizedlist></para>
                <para>Пример аннотации, означающей, что локализованное значение атрибута <code>state</code> будет взято из пакета, имя которого хранится в атрибуте <code>messagesPack</code> связанной сущности <code>proc</code>:<programlisting>@Column(name = &quot;STATE&quot;)
@LocalizedValue(messagePackExpr = &quot;proc.messagesPack&quot;)
protected String state;

@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = &quot;PROC_ID&quot;)
protected Proc proc;</programlisting></para>
              </listitem>
            </varlistentry>
          </variablelist>
        </section>
      </section>
      <section id="enum_attributes">
        <title>Атрибуты типа enum</title>
        <para>В стандартном варианте использования <glossterm linkend="jpa">JPA</glossterm> для атрибутов типа <code>enum</code> в базе данных хранится целое число, получаемое методом <code>ordinal()</code> этого перечисления. Такой подход может привести к следующим проблемам при эксплуатации и развитии системы:<itemizedlist>
            <listitem>
              <para>при появлении в БД значения, не равного ни одному <code>ordinal</code> значению перечисления, экземпляр сущности нельзя загрузить вообще;</para>
            </listitem>
            <listitem>
              <para>невозможно ввести новое значение между имеющимися, что актуально при использовании сортировки по значению перечисления (order by).</para>
            </listitem>
          </itemizedlist></para>
        <para>Чтобы решить эти проблемы, в подходе <productname>CUBA</productname> предлагается отвязать значение, хранимое в БД, от <code>ordinal</code> перечисления. Для этого необходимо поле класса сущности объявлять с типом, хранимым в БД (<code>Integer</code> или <code>String</code>), а методы доступа (getter / setter) создавать для типа самого перечисления.</para>
        <para>Например:<programlisting>@Entity(name = &quot;sales$Customer&quot;)
@Table(name = &quot;SALES_CUSTOMER&quot;)
public class Customer extends StandardEntity {

    @Column(name = &quot;GRADE&quot;)
    protected Integer grade;

    public CustomerGrade getGrade() {
        return grade == null ? null : CustomerGrade.fromId(grade);
    }

    public void setGrade(CustomerGrade grade) {
        this.grade = grade == null ? null : grade.getId();
    }
...
}  </programlisting></para>
        <para>При этом сам класс перечисления может выглядеть следующим образом:<programlisting>public enum CustomerGrade implements EnumClass&lt;Integer&gt; {

    PREMIUM(10),
    HIGH(20),
    MEDIUM(30);

    private Integer id;

    CustomerGrade(Integer id) {
        this.id = id;
    }

    @Override
    public Integer getId() {
        return id;
    }

    public static CustomerGrade fromId(Integer id) {
        for (CustomerGrade grade : CustomerGrade.values()) {
            if (grade.getId().equals(id))
                return grade;
        }
        return null;
    }
}</programlisting></para>
        <para>Для правильного отражения в <link linkend="metadata_framework">метаданных</link> класс перечисления, используемый в качестве типа атрибута сущности, должен реализовывать интерфейс <code>EnumClass</code>.</para>
        <para>Как видно из примеров, для атрибута <code>grade</code> в БД хранится значение типа <code>Integer</code>, задаваемое полем <code>id</code> перечисления <code>CustomerGrade</code>, а конкретно <literal>10</literal>, <literal>20</literal> или <literal>30</literal>. В то же время прикладной код и метаданные работают с самим типом <code>CustomerGrade</code> через методы доступа, которые и осуществляют конвертацию.</para>
        <para>При наличии в поле БД значения, не соответствующего ни одному значению перечисления, метод <code>getGrade()</code> просто вернет <code>null</code>. Для ввода нового значения, например <code>HIGHER</code>, между <code>HIGH</code> и <code>PREMIUM</code>, достаточно добавить это значение в перечисление с идентификатором <literal>15</literal>, при этом сортировка по полю <code>Customer.grade</code> останется верной.</para>
      </section>
      <section id="soft_deletion">
        <title>Мягкое удаление</title>
        <para>Платформа <productname>CUBA</productname> поддерживает режим &quot;мягкого удаления&quot; данных - когда вместо удаления записей из базы данных они только помечаются определенным образом и становятся недоступными для обычного использования. В дальнейшем такие записи можно либо совсем удалить из БД с помощью отдельной регламентной процедуры, либо восстановить.</para>
        <para>Механизм мягкого удаления является &quot;прозрачным&quot; для прикладного программиста - достаточно убедиться что класс сущности реализует интерфейс <code>SoftDelete</code>, и платформа сама нужным образом будет  модифицировать запросы и операции с данными.</para>
        <para>Режим мягкого удаления имеет следующие преимущества:<itemizedlist>
            <listitem>
              <para>значительно снижается риск потери данных вследствие неверных действий пользователей</para>
            </listitem>
            <listitem>
              <para>позволяет быстро сделать некоторые  записи недоступными, даже если на них имеются ссылки. </para>
              <para>Возьмем для примера  модель данных Заказы - Покупатели. Допустим, на некоторого покупателя оформлено несколько заказов, однако нам нужно сделать его недоступным для  дальнейшей работы. Традиционным &quot;жестким&quot; удалением сделать это невозможно, так как для удаления покупателя нам нужно либо удалить все его заказы, либо обнулить в этих заказах ссылки на него (т.е. потерять информацию). При мягком удалении покупателя он становится недоступным для поиска и изменения, однако при просмотре заказов пользователь видит на экране название покупателя, так как при загрузке связей признак удаления намеренно игнорируется.</para>
              <para>Описанное поведение является стандартным, но может быть модифицировано с помощью <link linkend="delete_policy">политики обработки связей</link> при удалении.</para>
            </listitem>
          </itemizedlist></para>
        <para>Отрицательной стороной мягкого удаления является увеличение объема базы данных и потенциальная необходимость дополнительных процедур ее очистки.</para>
        <section>
          <title>Использование</title>
          <para>Для того, чтобы экземпляры сущности удалялись мягко, класс сущности должен реализовывать интерфейс <code>SoftDelete</code>,  а соответствующая таблица БД должна содержать колонки: <itemizedlist>
              <listitem>
                <para><database>DELETE_TS</database> - когда удалена запись</para>
              </listitem>
              <listitem>
                <para><database>DELETED_BY</database> - логин пользователя, который удалил запись</para>
              </listitem>
            </itemizedlist></para>
          <para>Поведение системы по умолчанию - сущности, реализующие <code>SoftDelete</code>, удаляются мягко, удаленные сущности не возвращаются запросами и поиском по идентификатору. При необходимости такое поведение можно динамически отключить следующими способами:<itemizedlist>
              <listitem>
                <para>для текущего экземпляра <link linkend="entityManager">EntityManager</link> - вызовом <code>setSoftDeletion(false)</code></para>
              </listitem>
              <listitem>
                <para>при запросе данных через <code>
                    <link linkend="dataService">DataService</link>
                  </code> или <code>
                    <link linkend="dataService">DataWorker</link>
                  </code> - вызовом у передаваемого объекта <code>LoadContext</code> метода <code>setSoftDeletion(false)</code></para>
              </listitem>
              <listitem>
                <para>на уровне <link linkend="datasources">источников данных</link> - используя метод <code>CollectionDatasource.setSoftDeletion(false)</code> или атрибут <literal>softDeletion=&quot;false&quot;</literal> элемента <sgmltag>collectionDatasource</sgmltag> в <link linkend="screen_xml">XML-дескрипторе</link> экрана.</para>
              </listitem>
            </itemizedlist></para>
          <para>В режиме мягкого удаления платформа автоматически отфильтровывает  удаленные экземпляры при загрузке по идентификатору и по <glossterm linkend="jpql">JPQL-запросу</glossterm>, а также удаленные элементы связанных сущностей в атрибутах-коллекциях. Однако связанные сущности в единичных атрибутах загружаются независимо от того, удален связанный экземпляр или нет.</para>
        </section>
        <section id="delete_policy">
          <title>Политика обработки связей</title>
          <para>Платформа предоставляет средство обработки связей при удалении сущностей, во многом аналогичное правилам <database>ON DELETE</database> внешних ключей в базе данных. Это средство работает на <link linkend="app_tiers">уровне</link><structname> Middleware</structname> и использует аннотации <link linkend="onDelete_annotation">@OnDelete</link>, <link linkend="onDeleteInverse_annotation">@OnDeleteInverse</link> атрибутов сущности.</para>
          <para>Аннотация <code>@OnDelete</code> обрабатывается при удалении той сущности, в которой она встретилась, а не той, на которую указывает аннотированный атрибут (в этом отличие от каскадных удалений на уровне БД).
</para>
          <para>
Аннотация <code>@OnDeleteInverse</code> обрабатывается при удалении той сущности, на которую указывает аннотированный атрибут, (т.е. аналогично каскадному удалению на уровне внешних ключей в БД). Эта аннотация полезна при отсутствии в удаляемом объекте атрибута, который нужно проверять при удалении. При этом, как правило, в проверяемом объекте существует ссылка на удаляемый, на этот атрибут и устанавливается аннотация <code>@OnDeleteInverse</code>. </para>
          <para>Значением аннотации может быть: <itemizedlist>
              <listitem>
                <para><code>DeletePolicy.DENY</code> - запретить удаление сущности, если аннотированный атрибут не <code>null</code> или не пустая коллекция </para>
              </listitem>
              <listitem>
                <para><code>DeletePolicy.CASCADE</code> - каскадно удалить аннотированный атрибут </para>
              </listitem>
              <listitem>
                <para><code>DeletePolicy.UNLINK</code> - разорвать связь с аннотированным атрибутом. Разрыв связи имеет смысл указывать только на ведущей стороне ассоциации - той, которая в  классе сущности аннотирована <code>@JoinColumn</code>. </para>
              </listitem>
            </itemizedlist></para>
          <para>Примеры: <orderedlist>
              <listitem>
                <para>Запрет удаления при наличии ссылки: при попытке удаления экземпляра <code>Customer</code>, на который ссылается хотя бы один <code>Order</code>, будет выброшено исключение <code>DeletePolicyException</code>.</para>
                <para><filename>Order.java</filename><programlisting>@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = &quot;CUSTOMER_ID&quot;)
@OnDeleteInverse(DeletePolicy.DENY)
protected Customer customer;</programlisting></para>
                <para><filename>Customer.java</filename><programlisting>@OneToMany(mappedBy = &quot;customer&quot;)
protected List&lt;Order&gt; orders;</programlisting></para>
              </listitem>
              <listitem>
                <para>Каскадное удаление элементов коллекции: при удалении экземпляра <code>Role</code> все экземпляры <code>Permission</code> также будут удалены.</para>
                <para><filename>Role.java</filename><programlisting>@OneToMany(mappedBy = &quot;role&quot;)
@OnDelete(DeletePolicy.CASCADE)
protected Set&lt;Permission&gt; permissions;</programlisting></para>
                <para><filename>Permission.java</filename><programlisting>@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = &quot;ROLE_ID&quot;)
protected Role role;</programlisting></para>
              </listitem>
              <listitem>
                <para>Разрыв связи с элементами коллекции: удаление экземпляра <code>Role</code> приведет к установке в <code>null</code> ссылок со стороны всех входивших в коллекцию экземпляров <code>Permission</code>.</para>
                <para><filename>Role.java</filename><programlisting>@OneToMany(mappedBy = &quot;role&quot;)
@OnDelete(DeletePolicy.UNLINK)
protected Set&lt;Permission&gt; permissions;</programlisting></para>
                <para><filename>Permission.java</filename><programlisting>@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = &quot;ROLE_ID&quot;)
protected Role role;</programlisting></para>
              </listitem>
            </orderedlist></para>
          <para>Особенности реализации:<orderedlist>
              <listitem>
                <para>Нужно быть  осторожным при использовании <code>@OnDeleteInverse</code> с политиками <code>CASCADE</code> и <code>UNLINK</code>, так как при этом происходит извлечение из БД на сервер приложения всех экземпляров ссылающихся объектов, изменение и затем сохранение. </para>
                <para>Например, в случае ассоциации <code>Customer</code> - <code>Job</code> и большого количества работ для одного заказчика, если поставить на атрибут <code>Job.customer</code> политику <code>@OnDeleteInverse(CASCADE)</code>, то при удалении экземпляра заказчика будет предпринята попытка извлечь и изменить все его работы. Это может привести  к перегрузке сервера приложения и  БД.</para>
                <para>С другой стороны, использование <code>@OnDeleteInverse(DENY)</code> безопасно, так как при этом производится только подсчет количества ссылающихся объектов, и если оно больше <literal>0</literal>, выбрасывается исключение. Поэтому <code>@OnDeleteInverse(DENY)</code> для атрибута <code>Job.customer</code> вполне допустимо. </para>
              </listitem>
              <listitem>
                <para>Политика обработки связей реализуется   с помощью <link linkend="entity_listeners">Entity Listeners</link>, то есть при сохранении данных в БД  на <link linkend="app_tiers">уровне</link> Middleware.</para>
              </listitem>
            </orderedlist> </para>
        </section>
        <section>
          <title>Ограничение уникальности на уровне БД</title>
          <para>В режиме мягкого удаления для ограничения уникальности некоторого значения необходимо обеспечить существование единственной неудаленной записи с этим значением, и произвольного количества удаленных записей с этим же значением.</para>
          <para>Реализуется данная логика путем, специфичным для используемого сервера базы данных:<itemizedlist>
              <listitem>
                <para>Если сервер БД поддерживает частичные (partial) индексы (например <application>PostgreSQL</application>), то ограничение уникальности можно создать следующим образом:<programlisting>create unique index IDX_SEC_USER_UNIQ_LOGIN on SEC_USER (LOGIN_LC) where DELETE_TS is null</programlisting></para>
              </listitem>
              <listitem>
                <para>Если сервер БД не поддерживает частичные индексы (например <application>Microsoft SQL Server 2005</application>), то в уникальный индекс можно включить поле <database>DELETE_TS</database>:<programlisting>create unique index IDX_SEC_USER_UNIQ_LOGIN on SEC_USER (LOGIN_LC, DELETE_TS)</programlisting></para>
              </listitem>
            </itemizedlist></para>
        </section>
      </section>
      <section id="entity_listeners">
        <title>Entity Listeners</title>
        <para><firstterm>Entity Listeners</firstterm> предназначены для реакции на события жизненного цикла экземпляров сущностей на <link linkend="app_tiers">уровне</link><structname> Middleware</structname>.</para>
        <para>Слушатель представляет собой класс, реализующий один или несколько интерфейсов пакета <code>com.haulmont.cuba.core.listener</code>. Слушатель будет реагировать на события  типов, соответствующих реализуемым интерфейсам.</para>
        <variablelist>
          <varlistentry>
            <term>
              <code>BeforeDetachEntityListener</code>
            </term>
            <listitem>
              <para>Метод <code>onBeforeDetach()</code> вызывается  перед отделением объекта от <code>
                  <link linkend="entityManager">EntityManager</link>
                </code> при коммите транзакции.</para>
              <para>Данный слушатель можно использовать например для заполнения неперсистентных атрибутов сущности перед отправкой ее на клиентский уровень.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <code>BeforeInsertEntityListener</code>
            </term>
            <listitem>
              <para>Метод <code>onBeforeInsert()</code> вызывается перед выполнением вставки записи в БД. В данном методе возможны любые операции с текущим <code>
                  <link linkend="entityManager">EntityManager</link>
                </code>.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <code>AfterInsertEntityListener</code>
            </term>
            <listitem>
              <para>Метод <code>onAfterInsert()</code> вызывается после выполнения вставки записи в БД, но до коммита транзакции. В данном методе нельзя модифицировать текущий персистентный контекст, однако можно производить изменения в БД с помощью <link linkend="queryRunner">
                  <code>QueryRunner</code>
                </link>.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <code>BeforeUpdateEntityListener</code>
            </term>
            <listitem>
              <para>Метод <code>onBeforeUpdate()</code> вызывается перед изменением записи в БД. В данном методе возможны любые операции с текущим <code>
                  <link linkend="entityManager">EntityManager</link>
                </code>.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <code>AfterUpdateEntityListener</code>
            </term>
            <listitem>
              <para>Метод <code>onAfterUpdate()</code> вызывается после изменения записи в БД, но до коммита транзакции. В данном методе нельзя модифицировать текущий персистентный контекст, однако можно производить изменения в БД с помощью <link linkend="queryRunner">
                  <code>QueryRunner</code>
                </link>.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <code>BeforeDeleteEntityListener</code>
            </term>
            <listitem>
              <para>Метод <code>onBeforeDelete()</code> вызывается перед удалением записи из БД (или в случае <link linkend="soft_deletion">мягкого удаления</link> - перед изменением записи). В данном методе возможны любые операции с текущим <code>
                  <link linkend="entityManager">EntityManager</link>
                </code>.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <code>AfterDeleteEntityListener</code>
            </term>
            <listitem>
              <para>Метод <code>onAfterDelete()</code> вызывается после удаления записи из БД (или в случае <link linkend="soft_deletion">мягкого удаления</link> - после изменения записи), но до коммита транзакции. В данном методе нельзя модифицировать текущий персистентный контекст, однако можно производить изменения в БД с помощью <link linkend="queryRunner">
                  <code>QueryRunner</code>
                </link>.</para>
            </listitem>
          </varlistentry>
        </variablelist>
        <para>Entity Listener  может быть задан 2-мя способами: <itemizedlist>
            <listitem>
              <para>Статически - имена классов слушателей указываются в аннотации <link linkend="listeners_annotation">
                  <code>@Listeners</code>
                </link> на классе сущности</para>
            </listitem>
            <listitem>
              <para>Динамически - класс сущности и слушателя передаются в метод <code>addListener()</code> бина <code>EntityListenerManager</code>, например: <programlisting>@ManagedBean
public class MyBean implements AppContext.Listener {

    @Inject
    private EntityListenerManager entityListenerManager;

    public ClusterManager() {
        AppContext.addListener(this);
    }

    @Override
    public void applicationStarted() {
        entityListenerManager.addListener(User.class, MyUserListener.class);
    }

    @Override
    public void applicationStopped() {
    }
}</programlisting></para>
            </listitem>
          </itemizedlist></para>
        <para>Для всех экземпляров некоторого класса сущности создается и кэшируется <emphasis>один</emphasis> экземпляр слушателя определенного типа, поэтому слушатель <emphasis>не должен иметь состояния</emphasis>.</para>
        <para>Если для сущности объявлены несколько слушателей одного типа (например аннотациями класса сущности и его предков, плюс динамически), то их вызов будет выполняться в следующем порядке:<orderedlist>
            <listitem>
              <para>Для каждого предка начиная с самого дальнего вызываются его динамически добавленные слушатели, затем статически назначенные.</para>
            </listitem>
            <listitem>
              <para>После всех предков вызываются  динамически добавленные слушатели  данного класса, затем статически назначенные.</para>
            </listitem>
          </orderedlist></para>
      </section>
    </section>
    <section id="metadata_framework">
      <title>Metadata Framework</title>
      <para>Для эффективной работы с <link linkend="data_model">моделью данных</link> в CUBA-приложениях используется фреймворк метаданных, который:</para>
      <itemizedlist>
        <listitem>
          <para>предоставляет удобный интерфейс для получения информации о <glossterm linkend="entity">сущностях</glossterm>, их атрибутах и отношениях между сущностями; а также для навигации по ссылкам</para>
        </listitem>
        <listitem>
          <para>служит специализированной и более удобной в использовании альтернативой <application>Java Reflection API</application></para>
        </listitem>
        <listitem>
          <para>регламентирует допустимые типы данных и отношений между сущностями</para>
        </listitem>
        <listitem>
          <para>позволяет создавать универсальные механизмы работы с данными</para>
        </listitem>
      </itemizedlist>
      <section>
        <title>Интерфейсы метаданных</title>
        <para>Рассмотрим основные интерфейсы метаданных.</para>
        <figure>
          <title>Интерфейсы фреймворка метаданных</title>
          <mediaobject>
            <imageobject>
              <imagedata contentwidth="80%" align="center" fileref="img/MetadataFramework.png"/>
            </imageobject>
          </mediaobject>
        </figure>
        <variablelist>
          <varlistentry>
            <term>
              <code>Session</code>
            </term>
            <listitem>
              <para>Точка входа в фреймворк метаданных. Позволяет получать экземпляры <code>MetaClass</code> по имени и по соответствующему классу Java. Обратите внимание на различие методов <code>getClass()</code> и <code>getClassNN()</code> - первые могут возвращать <code>null</code>, вторые нет (NonNull).</para>
              <para>Объект <code>Session</code> может быть получен через интерфейс инфраструктуры <code>
                  <link linkend="metadata">Metadata</link>
                </code>.</para>
              <para>Пример:<programlisting>@Inject
protected Metadata metadata;
...
Session session = metadata.getSession();
MetaClass metaClass1 = session.getClassNN(&quot;sec$User&quot;);
MetaClass metaClass2 = session.getClassNN(User.class);
assert metaClass1 == metaClass2;</programlisting></para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <code>MetaModel</code>
            </term>
            <listitem>
              <para>Редко используемый интерфейс, служит для группировки мета-классов. </para>
              <para>Группировка осуществляется по первым  трем частям имени пакета Java класса сущности. Например, мета-класс сущности <code>com.abc.sales.entity.Customer</code> принадлежит мета-модели с именем <code>com.abc.sales</code></para>
            </listitem>
          </varlistentry>
          <varlistentry id="metaClass">
            <term>
              <code>MetaClass</code>
            </term>
            <listitem>
              <para>Интерфейс метаданных класса сущности. <code>MetaClass</code> всегда ассоциирован с классом Java, которого он представляет.</para>
              <para>Основные методы:</para>
              <itemizedlist>
                <listitem>
                  <para><code>getName()</code> – имя сущности, по соглашению первой частью имени до знака <code>$</code> является код пространства имен, например, <code>sales$Customer</code></para>
                </listitem>
                <listitem>
                  <para><code>getProperties()</code> – список мета-свойств (<code>MetaProperty</code>)</para>
                </listitem>
                <listitem>
                  <para><code>getProperty()</code>, <code>getPropertyNN()</code> - получение мета-свойства по имени. Первый метод в случае отсутствия атрибута с указанным именем возвращает <code>null</code>, второй выбрасывает исключение.</para>
                  <para>Пример:<programlisting>MetaClass userClass = session.getClassNN(User.class);
MetaProperty groupProperty = userClass.getPropertyNN(&quot;group&quot;);</programlisting></para>
                </listitem>
                <listitem>
                  <para><code>getPropertyPath()</code> - позволяет перемещаться по ссылкам. Данный метод принимает строковый параметр - путь из имен атрибутов, разделенных точкой. Возвращаемый объект <code>MetaPropertyPath</code> позволяет обратиться к искомому (последнему в пути) атрибуту вызовом <code>getMetaProperty()</code>. </para>
                  <para>Пример:<programlisting>MetaClass userClass = session.getClassNN(User.class);
MetaProperty groupNameProp = userClass.getPropertyPath(&quot;group.name&quot;).getMetaProperty();
assert groupNameProp.getDomain().getName().equals(&quot;sec$Group&quot;);</programlisting></para>
                </listitem>
                <listitem>
                  <para><code>getJavaClass()</code> – класс сущности, которому соответствует данный <code>MetaClass</code></para>
                </listitem>
                <listitem>
                  <para><code>getAnnotations()</code> – коллекция <link linkend="meta_annotations">мета-аннотаций</link> </para>
                </listitem>
              </itemizedlist>
            </listitem>
          </varlistentry>
          <varlistentry id="metaProperty">
            <term>
              <code>MetaProperty</code>
            </term>
            <listitem>
              <para>Интерфейс метаданных атрибута сущности. </para>
              <para>Основные методы:</para>
              <itemizedlist>
                <listitem>
                  <para><code>getName()</code> – имя свойства, соответствует имени атрибута сущности</para>
                </listitem>
                <listitem>
                  <para><code>getDomain()</code> – мета-класс, которому принадлежит данное свойство</para>
                </listitem>
                <listitem id="metaProperty.getType">
                  <para><code>getType() </code>– тип свойства:<itemizedlist>
                      <listitem>
                        <para>простой тип: <code>DATATYPE</code></para>
                      </listitem>
                      <listitem>
                        <para>перечисление: <code>ENUM</code></para>
                      </listitem>
                      <listitem>
                        <para>ссылочный тип двух видов:</para>
                        <itemizedlist>
                          <listitem id="associationType">
                            <para><code>ASSOCIATION</code> − простая ссылка на другую сущность. Например, отношение заказа и покупателя − ассоциация.</para>
                          </listitem>
                          <listitem>
                            <para><code>COMPOSITION</code> − ссылка на сущность, которая не имеет самостоятельного значения без владеющей сущности. <code>COMPOSITION</code> можно считать &quot;более тесным&quot; отношением, чем <code>ASSOCIATION</code>. Например, отношение заказа и пункта этого заказа − <code>COMPOSITION</code>, т.к. пункт не может существовать без заказа, которому он принадлежит.</para>
                          </listitem>
                        </itemizedlist>
                        <para>Вид ссылочного атрибута <code>ASSOCIATION</code> или <code>COMPOSITION</code> влияет на режим редактирования сущности: в первом случае сохранение связанной сущности в базу данных происходит независимо, а во втором − связанная сущность сохраняется в БД только вместе с владеющей сущностью.</para>
                      </listitem>
                    </itemizedlist></para>
                </listitem>
                <listitem>
                  <para><code>getRange()</code> –  интерфейс <code>Range</code>, детально описывающий тип данного атрибута</para>
                </listitem>
                <listitem>
                  <para><code>isMandatory()</code> – признак обязательности атрибута. Используется, например, визуальными компонентами для сигнализации пользователю о необходимости ввода значения.</para>
                </listitem>
                <listitem>
                  <para><code>isReadOnly()</code> – признак неизменности атрибута</para>
                </listitem>
                <listitem>
                  <para><code>getInverse()</code> – для ссылочного атрибута возвращает мета-свойство с обратной стороны ассоциации, если таковое имеется</para>
                </listitem>
                <listitem>
                  <para><code>getAnnotatedElement()</code> – поле (<code>java.lang.reflect.Field</code>) или метод (<code>java.lang.reflect.Method</code>), соответствующие данному атрибуту сущности</para>
                </listitem>
                <listitem>
                  <para><code>getJavaType()</code> – класс Java данного атрибута сущности. Это либо тип поля класса, либо тип возвращаемого значения метода.</para>
                </listitem>
                <listitem>
                  <para><code>getDeclaringClass()</code> – класс Java, содержащий данный атрибут</para>
                </listitem>
              </itemizedlist>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <code>Range</code>
            </term>
            <listitem>
              <para>Интерфейс, детально описывающий тип атрибута сущности.</para>
              <para>Основные методы:</para>
              <itemizedlist>
                <listitem>
                  <para><code>isDatatype()</code> – возвращает <code>true</code> для атрибута простого  <link linkend="metaProperty.getType">типа</link></para>
                </listitem>
                <listitem>
                  <para><code>asDatatype()</code> - возвращает <link linkend="datatype">
                      <code>Datatype</code>
                    </link> для атрибута простого <link linkend="metaProperty.getType">типа</link></para>
                </listitem>
                <listitem>
                  <para><code>isEnum()</code> – возвращает <code>true</code> для атрибута <link linkend="metaProperty.getType">типа</link> перечисления</para>
                </listitem>
                <listitem>
                  <para><code>asEnumeration()</code> - возвращает <link linkend="datatype">
                      <code>Enumeration</code>
                    </link> для атрибута  <link linkend="metaProperty.getType">типа</link> перечисления</para>
                </listitem>
                <listitem>
                  <para><code>isClass()</code> – возвращает <code>true</code> для ссылочного атрибута <link linkend="metaProperty.getType"> типа</link>  <code>ASSOCIATION</code> или <code>COMPOSITION</code></para>
                </listitem>
                <listitem>
                  <para><code>asClass()</code> - возвращает <link linkend="metaClass">мета-класс</link> ассоциированной сущности для ссылочного атрибута</para>
                </listitem>
                <listitem>
                  <para><code>isOrdered()</code> – возвращает <code>true</code>  если атрибут представляет собой упорядоченную коллекцию (например <code>List</code>)</para>
                </listitem>
                <listitem>
                  <para><code>getCardinality()</code> – вид отношения для ссылочного атрибута: <code>ONE_TO_ONE</code>, <code>MANY_TO_ONE</code>, <code>ONE_TO_MANY</code>, <code>MANY_TO_MANY</code></para>
                </listitem>
              </itemizedlist>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>
      <section id="metadata_building">
        <title>Формирование метаданных</title>
        <para>Основной источник формирования структуры метаданных - <link linkend="entity_annotations">аннотированные</link> классы сущностей. </para>
        <para>Класс сущности отражается в метаданные в следующих случаях: <itemizedlist>
            <listitem>
              <para>Класс персистентной сущности аннотирован <code>@Entity</code>, <code>@Embeddable</code>, <code>@MappedSuperclass</code> и зарегистрирован в файле <filename>
                  <link linkend="persistence.xml">persistence.xml</link>
                </filename></para>
            </listitem>
            <listitem>
              <para>Класс неперсистентной сущности аннотирован <code>@MetaClass</code> и зарегистрирован в файле <filename>
                  <link linkend="metadata.xml">metadata.xml</link>
                </filename></para>
            </listitem>
          </itemizedlist></para>
        <para>Атрибут сущности отражается в метаданных, если: <itemizedlist>
            <listitem>
              <para>поле класса аннотировано <code>@Column</code>, <code>@OneToOne</code>, <code>@OneToMany</code>, <code>@ManyToOne</code>, <code>@ManyToMany</code>, <code>@Embedded</code></para>
            </listitem>
            <listitem>
              <para>поле класса или метод доступа на чтение (getter) аннотирован <code>@MetaProperty</code></para>
            </listitem>
          </itemizedlist></para>
        <para>Параметры мета-класса и мета-свойств формируются на основе параметров перечисленных <link linkend="entity_annotations">аннотаций</link>, а также типов полей и методов класса. Кроме того, если у атрибута отсутствует метод доступа на запись (setter), атрибут становится неизменяемым (read only). </para>
        <warning>
          <title>Внимание</title>
          <para>Текущая реализация сборки метаданных имеет следующие ограничения:<itemizedlist>
              <listitem>
                <para>Классы сущностей должны размещаться в пакетах, имеющих не менее 3-х уровней иерархии, например <code>com.abc.sales</code>, <code>com.abc.sales.entity</code></para>
              </listitem>
              <listitem>
                <para>Персистентные сущности не могут ссылаться на неперсистентные. Обратное возможно, т.е. неперсистентная сущность может иметь атрибут типа некоторой персистентной сущности.</para>
              </listitem>
            </itemizedlist> </para>
        </warning>
      </section>
      <section id="datatype">
        <title>Datatype</title>
        <para>Интерфейс <code>Datatype</code> описывает тип данных, допустимый для  атрибута сущности, не являющегося ассоциацией. Каждый экземпляр реализации <code>Datatype</code> соответствует одному классу Java, для работы с которым он предназначен.</para>
        <para>Все экземпляры зарегистрированы в репозитории - классе <code>Datatypes</code>, который выполняет загрузку и инициализацию классов реализации <code>Datatype</code> следующим образом:<itemizedlist>
            <listitem>
              <para>в корне <literal>CLASSPATH</literal> ищется файл <filename>
                  <link linkend="datatypes.xml">datatypes.xml</link>
                </filename>, и если он найден, репозиторий <code>Datatypes</code> инициализируется из него</para>
            </listitem>
            <listitem>
              <para>в противном случае инициализация <code>Datatypes</code> производится из файла <filename>/com/haulmont/chile/core/datatypes/<link linkend="datatypes.xml">datatypes.xml</link></filename></para>
            </listitem>
          </itemizedlist></para>
        <para>Экземпляр <code>Datatype</code> может быть получен двумя способами:<itemizedlist>
            <listitem>
              <para>из мета-свойства типа <code>
                  <link linkend="metaProperty.getType">DATATYPE</link>
                </code>, вызовом <code>getRange().asDatatype()</code></para>
            </listitem>
            <listitem>
              <para>статическим методом <code>Datatypes.get()</code>, передавая в него имя реализации <code>Datatype</code> или класс Java, для которого он создан.</para>
            </listitem>
          </itemizedlist></para>
        <para>Основные методы интерфейса <code>Datatype</code>:<itemizedlist>
            <listitem>
              <para><code>getName()</code> - возвращает уникальное имя данной реализации</para>
            </listitem>
            <listitem>
              <para><code>format()</code> - преобразовывает переданное значение в строку</para>
            </listitem>
            <listitem>
              <para><code>parse()</code> - преобразовывает строку в значение нужного типа </para>
            </listitem>
          </itemizedlist></para>
        <para><code>Datatype</code> определяет два набора методов для форматирования/парсинга: с учетом локали и без учета локали. Преобразование с учетом локали используется повсеместно в пользовательском интерфейсе, преобразование без учета локали используется в системных механизмах, например для сериализации в <link linkend="rest_api">REST API</link>. </para>
        <para>Форматы для преобразований без учета локали задаются в вышеупомянутом файле <filename>
            <link linkend="datatypes.xml">datatypes.xml</link>
          </filename>.</para>
        <para>Форматы для преобразований с учетом локали задаются в <link linkend="main_message_pack">главных пакетах локализованных сообщений</link>, в  строках со следующими ключами:<itemizedlist>
            <listitem>
              <para><literal>numberDecimalSeparator</literal></para>
            </listitem>
            <listitem>
              <para><literal>numberGroupingSeparator</literal></para>
            </listitem>
            <listitem>
              <para><literal>integerFormat</literal></para>
            </listitem>
            <listitem>
              <para><literal>doubleFormat</literal></para>
            </listitem>
            <listitem>
              <para><literal>dateTimeFormat</literal></para>
            </listitem>
            <listitem>
              <para><literal>dateFormat</literal></para>
            </listitem>
            <listitem>
              <para><literal>timeFormat</literal></para>
            </listitem>
            <listitem>
              <para><literal>trueString</literal></para>
            </listitem>
            <listitem>
              <para><literal>falseString</literal></para>
            </listitem>
          </itemizedlist>Все перечисленные форматы по умолчанию заданы в <link linkend="main_message_pack">главных пакетах локализованных сообщений</link> <link linkend="base_projects">базового проекта</link> <structname>cuba</structname>, и могут быть переопределены в аналогичных файлах проекта приложения.</para>
        <section>
          <title>Пример форматирования даты в UI</title>
          <para>Рассмотрим отображение атрибута <code>Order.date</code> в таблице браузера заказов.</para>
          <para>order-browse.xml<programlisting>&lt;table id=&quot;ordersTable&quot;&gt;
    ...
    &lt;columns&gt;
        &lt;column id=&quot;date&quot;/&gt;
        ...</programlisting></para>
          <para>Атрибут <code>date</code>  в классе <code>Order</code> определен с типом &quot;дата&quot;:<programlisting>@Column(name = &quot;DATE&quot;, nullable = false)
@Temporal(TemporalType.DATE)
private Date date;</programlisting></para>
          <para>Если текущий пользователь зарегистрирован c русской локалью, то из <link linkend="main_message_pack">главного пакета</link> локализованных сообщений клиентского <link linkend="app_tiers">уровня</link>, из файла <filename>messages_ru.properties</filename> извлекается строка:<programlisting>dateFormat=dd.MM.yyyy</programlisting></para>
          <para>Результат: дата &quot;6 августа 2012 года&quot; конвертируется в строку &quot;06.08.2012&quot; для отображения в ячейке таблицы.</para>
        </section>
        <section>
          <title>Примеры форматирования дат и чисел в коде приложения</title>
          <itemizedlist>
            <listitem>
              <para>Пример форматирования даты<programlisting>@Inject
protected UserSessionSource userSessionSource;
...
Date date = ...;
String dateStr = Datatypes.get(Date.class).format(date, userSessionSource.getLocale());</programlisting></para>
            </listitem>
            <listitem>
              <para>Пример форматирования числового значения с повышенной точностью  (5 знаков после запятой) в <link linkend="app_tiers">блоке</link> <structname>Web Client</structname></para>
              <para><filename>/com/abc/sales/web/messages_ru.properties</filename><programlisting>coordinateFormat = #,##0.00000</programlisting></para>
              <para><filename>SomeClass.java</filename><programlisting>@Inject
protected Messages messages;
@Inject
protected UserSessionSource userSessionSource;
...
String coordinateFormat = messages.getMainMessage(&quot;coordinateFormat&quot;);
FormatStrings formatStrings = Datatypes.getFormatStrings(userSessionSource.getLocale());
NumberFormat format = new DecimalFormat(coordinateFormat, formatStrings.getFormatSymbols());

String formattedValue = format.format(value);</programlisting></para>
            </listitem>
          </itemizedlist>
        </section>
      </section>
      <section id="meta_annotations">
        <title>Мета-аннотации</title>
        <para>Мета-аннотации сущностей - набор пар ключ/значение, содержащих дополнительную информацию о сущностях.</para>
        <para>Обращение к мета-аннотациям  производится с помощью метода <link linkend="metaClass">мета-класса</link> <code>getAnnotations()</code>.</para>
        <para>Источниками мета-аннотаций сущности являются:<itemizedlist>
            <listitem>
              <para><link linkend="entity_annotations">Аннотации</link>  <code>@OnDelete</code>, <code>@OnDeleteInverse</code>, <code>@Extends</code>. При этом в мета-аннотациях создаются служебные объекты связей между сущностями. </para>
            </listitem>
            <listitem>
              <para><link linkend="entity_annotations">Аннотации</link>  <code>@SystemLevel</code>, <code>@EnableRestore</code>, <code>@TrackEditScreenHistory</code>. При этом создаются  мета-аннотации с ключами, соответствующими полному имени класса Java аннотации. </para>
            </listitem>
            <listitem>
              <para>Опционально: в прикладном проекте могут быть определены свои аннотации для сущностей, и в <link linkend="extension">переопределенном</link> методе <code>MetadataImpl.initMetaAnnotations()</code> отображены в соответствующие мета-аннотации. </para>
            </listitem>
            <listitem>
              <para>Опционально: в файлах <filename>
                  <link linkend="metadata.xml">metadata.xml</link>
                </filename> также могут быть определены мета-аннотации сущностей. Если мета-аннотация в XML имеет то же имя, что и мета-аннотация, созданная по Java аннотации класса сущности, первая переопределит значение второй. </para>
              <para>Пример определения мета-аннотаций в <filename>
                  <link linkend="metadata.xml">metadata.xml</link>
                </filename>:<programlisting>&lt;annotations&gt;
    &lt;entity class=&quot;com.haulmont.cuba.security.entity.User&quot;&gt;
        &lt;annotation name=&quot;com.haulmont.cuba.core.entity.annotation.TrackEditScreenHistory&quot; value=&quot;false&quot;/&gt;
        &lt;annotation name=&quot;com.haulmont.cuba.core.entity.annotation.EnableRestore&quot; value=&quot;true&quot;/&gt;
    &lt;/entity&gt;
&lt;/annotations&gt;</programlisting></para>
            </listitem>
          </itemizedlist></para>
      </section>
    </section>
    <section id="views">
      <title>Представления</title>
      <section>
        <title>Общие сведения</title>
        <para>При извлечении сущностей из базы данных обычно встает вопрос - как обеспечить загрузку связанных сущностей на нужную глубину? </para>
        <para>Например,  для браузера Заказов нужно отобразить дату и сумму заказа совместно с названием Покупателя, т.е. загрузить связанный экземпляр Покупателя. А для экрана редактирования Заказа необходимо загрузить еще и коллекцию Пунктов заказа, причем каждый Пункт заказа должен содержать связанный экземпляр Товара для отображения его наименования. </para>
        <para><link linkend="lazy_loading">Загрузка по требованию</link> в большинстве случаев не может помочь, так как обработка данных как правило происходит не в транзакции, в которой загружаются сущности, а, например, на клиентском <link linkend="app_tiers">уровне</link> в пользовательском интерфейсе. В то же время задание <glossterm linkend="eager_fetching">энергичной загрузки</glossterm> в <link linkend="entity_annotations">аннотациях сущностей</link> недопустимо, так как приводит к постоянному извлечению всего графа связанных сущностей, который может быть очень большим.</para>
        <para>Другой похожей проблемой является ограничение набора <glossterm linkend="local_attribute">локальных</glossterm> атрибутов сущностей загружаемого графа: например, некоторая сущность имеет 50 атрибутов, в том числе BLOB, а в экране отображается только 10 атрибутов. Зачем загружать из БД, затем сериализовать и передавать клиенту 40 атрибутов, которые ему в данный момент не нужны?</para>
        <para>Механизм <firstterm>представлений</firstterm> (views)  решает эти проблемы, обеспечивая извлечение из базы данных и передачу клиенту графов сущностей, ограниченных в глубину и по атрибутам. <firstterm>Представление</firstterm> является описателем графа объектов, который требуется в некотором экране UI или другом процессе обработки данных.</para>
        <para>Обработка представлений производится следующим образом:<itemizedlist>
            <listitem>
              <para>все связи в модели данных объявляются с признаком <link linkend="lazy_loading">загрузки по требованию</link> (<code>fetch = FetchType.LAZY</code>, см. <xref linkend="entity_annotations"/>)</para>
            </listitem>
            <listitem>
              <para>в процессе загрузки данных через <link linkend="dataService">DataService</link> клиентский код помимо <glossterm linkend="jpql">JPQL</glossterm> запроса указывает нужное  представление</para>
            </listitem>
            <listitem>
              <para>на основе представления формируется так называемый <firstterm>Fetch Plan</firstterm> - особенность лежащего в основе <link linkend="orm">слоя ORM</link> фреймворка <application>Apache OpenJPA</application>. Fetch Plan влияет на формирование SQL запроса к базе данных: как на список возвращаемых полей, так и на соединения с другими таблицами, содержащими связанные сущности.</para>
            </listitem>
            <listitem>
              <para>ссылки, не включенные в Fetch Plan (иногда это полезно  для упрощения основного SQL запроса), загружаются отдельными SQL запросами, для чего механизм обработки представлений просто обращается к соответствующим методам чтения атрибутов</para>
            </listitem>
            <listitem>
              <para>в результате на момент завершения <link linkend="transactions">транзакции</link>, загружающей данные, в памяти <structname>Middleware</structname> содержится граф объектов, заданный  JPQL запросом и представлением.</para>
            </listitem>
          </itemizedlist></para>
        <figure>
          <title>Классы представления</title>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/View.png"/>
            </imageobject>
          </mediaobject>
        </figure>
        <para>Представление определяется экземпляром класса <code>View</code>, в котором:<itemizedlist>
            <listitem>
              <para><code>entityClass</code> - класс сущности, для  которого определено представление. Другими словами, &quot;корень&quot; дерева загружаемых сущностей.</para>
            </listitem>
            <listitem>
              <para><code>name</code> - имя представления. Должно быть либо <code>null</code>, либо уникальным в пределах данной сущности.</para>
            </listitem>
            <listitem>
              <para><code>properties</code> - коллекция экземпляров класса ViewProperty, соответствующих загружаемым атрибутам сущности.</para>
            </listitem>
            <listitem>
              <para><code>includeSystemProperties</code> - признак включения системных атрибутов (входящих в состав <link linkend="entity_base_classes">базовых интерфейсов</link> персистентных сущностей <code>BaseEntity</code> и  <code>Updatable</code>). Системные атрибуты не перечисляются в <code>properties</code>  явно, а учитываются механизмом обработки представлений в зависимости от того, какие интерфейсы реализует данная сущность.</para>
            </listitem>
          </itemizedlist></para>
        <para>Класс <code>ViewProperty</code> имеет следующие свойства:<itemizedlist>
            <listitem>
              <para><code>name</code> - имя атрибута сущности</para>
            </listitem>
            <listitem>
              <para><code>view</code> - для ссылочных атрибутов задает представление, с которым необходимо загружать связанную сущность</para>
            </listitem>
            <listitem>
              <para><code>lazy</code> - для ссылочных атрибутов признак того, что данный атрибут нужно не  включать в Fetch Plan, а загружать отдельным SQL запросом, инициированным обращением к атрибуту. Следует иметь в виду, что атрибут в любом случае будет загружен на момент окончания транзакции, данный признак влияет только на способ загрузки. </para>
            </listitem>
          </itemizedlist></para>
        <warning>
          <para>Независимо от набора атрибутов, определенного в представлении, всегда загружаются следующие атрибуты:<itemizedlist>
              <listitem>
                <para><code>id</code> - идентификатор сущности</para>
              </listitem>
              <listitem>
                <para><code>version</code> - для оптимистично блокируемых сущностей, реализующих <code>Versioned</code></para>
              </listitem>
              <listitem>
                <para><code>deleteTs</code>, <code>deletedBy</code> - для сущностей, реализующих <code>
                    <link linkend="soft_deletion">SoftDelete</link>
                  </code></para>
              </listitem>
            </itemizedlist></para>
        </warning>
      </section>
      <section>
        <title>Создание представлений</title>
        <para>Представление может быть создано двумя путями:<itemizedlist>
            <listitem>
              <para><emphasis role="bold">программно</emphasis> - созданием экземпляра <code>View</code>, например:<programlisting>View view = new View(Order.class)
        .addProperty(&quot;date&quot;)
        .addProperty(&quot;amount&quot;)
        .addProperty(&quot;customer&quot;, new View(Customer.class)
            .addProperty(&quot;name&quot;)
        );</programlisting></para>
              <para>Как правило, таким способом создаются представления, используемые только в каком-то одном месте бизнес-логики.</para>
              <warning>
                <para>Механизм обработки представлений кэширует создаваемые для <emphasis>именованных</emphasis> представлений объекты Fetch Plan. Это означает, что если Вы <emphasis>программно</emphasis> создадите два представления для одной сущности с одинаковыми именами, но с разным набором атрибутов, то выборка со вторым представлением окажется неверной.</para>
                <para>Поэтому никогда не задавайте имен для &quot;одноразовых&quot; представлений, создаваемых программно.</para>
              </warning>
            </listitem>
            <listitem>
              <para><emphasis role="bold">декларативно</emphasis> - путем создания описателя на XML и его развертывания в репозитории представлений <code>ViewRepository</code>. При развертывании на основе XML-описателя создаются и кэшируются экземпляры <code>View</code>. В дальнейшем в любом месте кода приложения требуемое представление можно получить вызовом репозитория с указанием класса сущности и имени представления.</para>
            </listitem>
          </itemizedlist></para>
        <para>Рассмотрим подробнее декларативный способ создания и работы с представлениями.</para>
        <para><code>ViewRepository</code> является бином <application>Spring</application>, доступным для всех блоков приложения. Ссылка на <code>ViewRepository</code> может быть также получена через интерфейс инфраструктуры <code>
            <link linkend="metadata">Metadata</link>
          </code>. Для получения экземпляра <code>View</code>, содержащегося в репозитории, используются методы <code>getView()</code>. Для развертывания XML-описателей представлений в репозитории используются методы  <code>deployViews()</code> базовой реализации <code>AbstractViewRepository</code>.</para>
        <para>В репозитории для каждой сущности по умолчанию доступны два  представления с именами <filename>_local</filename> и <filename>_minimal</filename>:<itemizedlist>
            <listitem>
              <para><filename>_local</filename> включает в себя все <glossterm linkend="local_attribute">локальные</glossterm> атрибуты сущности</para>
            </listitem>
            <listitem>
              <para><filename>_minimal</filename> включает в себя атрибуты, входящие в имя экземпляра сущности, и задаваемые аннотацией <code>
                  <link linkend="namePattern">@NamePattern</link>
                </code>. Если аннотация <code>@NamePattern</code>  для сущности не указана, данное представление не включает никаких атрибутов.</para>
            </listitem>
          </itemizedlist></para>
        <para>Подробная структура XML-описателей изложена в <xref linkend="views.xml"/></para>
        <para>Пример описателя представления для сущности Заказ, которое должно обеспечить загрузку всех локальных атрибутов, ассоциированного Покупателя и коллекции Пунктов заказа:<programlisting>&lt;view class=&quot;com.sample.sales.entity.Order&quot;
      name=&quot;orderWithCustomer&quot;
      extends=&quot;_local&quot;&gt;
    &lt;property name=&quot;customer&quot; view=&quot;_minimal&quot;/&gt;
    &lt;property name=&quot;items&quot; view=&quot;itemsInOrder&quot;/&gt;
&lt;/view&gt;</programlisting></para>
        <para>Рекомендуемый способ группировки и развертывания описателей представлений:<itemizedlist>
            <listitem>
              <para>В <link linkend="app_modules">модуле</link> <structname>core</structname>  в корне <filename>src</filename>  создать файл <filename>{имя_проекта}-views.xml</filename> и поместить в него все описатели представлений, которые должны быть доступны глобально, т.е. на всех <link linkend="app_tiers">уровнях приложения</link>.</para>
            </listitem>
            <listitem>
              <para>Зарегистрировать данный файл в свойстве <property>
                  <link linkend="cuba.viewsConfig">cuba.viewsConfig</link>
                </property> блока <structname>Middleware</structname>, т.е. в файле <filename>{имя_проекта}-app.properties</filename> модуля <structname>core</structname>. Это обеспечит автоматическое развертывание представлений на старте приложения в репозитории <structname>Middleware</structname> (см. метод <code>AbstractViewRepository.init()</code>). Развернутые представления будут доступны и для <structname>Middleware</structname>, и для  клиентских <link linkend="app_tiers">блоков</link>, которые получат соответствующие экземпляры <code>View</code> при подключении к среднему слою.</para>
            </listitem>
            <listitem>
              <para>Если существуют представления, которые необходимы только какому-то одному клиентскому блоку приложения, то можно определить их в аналогичном файле этого блока, например <filename>{имя_проекта}-web-views.xml</filename>, и зарегистрировать в свойстве <property>
                  <link linkend="cuba.viewsConfig">cuba.viewsConfig</link>
                </property> этого блока, т.е. в данном случае в  файле <filename>{имя_проекта}-web-app.properties</filename>. Тогда клиентский блок сначала загрузит все имеющиеся представления с <structname>Middleware</structname>,  а затем развернет свои собственные (см. <code>ViewRepositoryClientImpl.init()</code>).</para>
              <para>Возможна также ситуация, когда некоторому клиентскому блоку не нужны глобальные представления, зарегистрированные на среднем слое, или нужны редко. В этом случае имеет смысл объявить в этом клиентском блоке свойство <link linkend="cuba.lazyLoadServerViews">
                  <property>cuba.lazyLoadServerViews</property>
                </link>, тогда глобальные представления будут загружаться на клиентский уровень не все сразу, а по необходимости.</para>
            </listitem>
          </itemizedlist></para>
        <para>Если на момент развертывания некоторого представления в репозитории уже есть представление для этого же класса сущности и с таким же именем, то новое будет проигнорировано. Для того, чтобы представление заменило имеющееся в репозитории и гарантированно было развернуто, в XML-описателе должен быть явно указан атрибут <literal>overwrite = &quot;true&quot;</literal>. В частности, развертывание представлений клиентского уровня производится после загрузки представлений со среднего слоя, поэтому некоторое клиентское представление может оказаться &quot;замаскированным&quot; одноименным представлением <structname>Middleware</structname>.</para>
        <tip>
          <para>Рекомендуется давать представлениям &quot;описательные&quot; имена. Например, не &quot;browse&quot;, а &quot;customerBrowse&quot;. Это упрощает поиск XML-описателей представлений по имени в процессе разработки приложения.</para>
        </tip>
      </section>
    </section>
    <section id="infrastructure_interfaces">
      <title>Интерфейсы инфраструктуры</title>
      <para>Интерфейсы инфраструктуры обеспечивают доступ к часто используемой функциональности платформы. Большинство из этих интерфейсов расположены в <link linkend="app_modules">модуле</link> <structname>global</structname> и могут быть использованы как на среднем слое, так и в <link linkend="app_tiers">блоках</link> клиентского уровня, но некоторые доступны только коду среднего слоя.</para>
      <para>Интерфейсы инфраструктуры реализуются бинами <application>Spring Framework</application>, поэтому они могут быть инжектированы в любые другие управляемые компоненты (<link linkend="managed_beans">Managed Beans</link>, <link linkend="services">сервисы среднего слоя</link>, <link linkend="screen_controller">контроллеры</link> экранов универсального пользовательского интерфейса.</para>
      <para>Кроме того, как и любые другие бины, интерфейсы инфраструктуры могут быть получены с помощью статических методов класса <code>AppBeans</code>, и использоваться в неуправляемых компонентах (<glossterm linkend="pojo">POJO</glossterm>, вспомогательных классах и пр.).</para>
      <section id="configuration">
        <title>Configuration</title>
        <para>Позволяет получать ссылки на <link linkend="config_interfaces">конфигурационные интерфейсы</link>.</para>
        <para>Примеры:<programlisting>@Inject
protected Configuration configuration;
...
String tempDir = configuration.getConfig(GlobalConfig.class).getTempDir();</programlisting><programlisting>protected GlobalConfig globalConfig;

@Inject
public void setConfiguration(Configuration configuration) {
    this.globalConfig = configuration.getConfig(GlobalConfig.class);
}</programlisting><programlisting>String tempDir = AppBeans.get(Configuration.class).getConfig(GlobalConfig.class).getTempDir();</programlisting></para>
      </section>
      <section id="messages">
        <title>Messages</title>
        <para>Интерфейс <code>Messages</code> обеспечивает получение <link linkend="localization">локализованных строк сообщений</link>.</para>
        <para>Рассмотрим методы интерфейса подробнее.</para>
        <itemizedlist>
          <listitem>
            <para><code>getMessage()</code> - возвращает локализованное сообщение по ключу, имени пакета сообщений и требуемой локали. Существует несколько модификаций данного метода в зависимости от набора параметров. Если локаль не указана в параметре метода, используется локаль текущего пользователя. </para>
            <para>Примеры:<programlisting>@Inject
protected Messages messages;
...
String message1 = messages.getMessage(getClass(), &quot;someMessage&quot;);
String message2 = messages.getMessage(&quot;com.abc.sales.web.customer&quot;, &quot;someMessage&quot;);
String message3 = messages.getMessage(RoleType.STANDARD);</programlisting></para>
          </listitem>
          <listitem>
            <para><code>formatMessage()</code> - находит локализованное сообщение по ключу, имени пакета сообщений и требуемой локали, и использует его для форматирования переданных параметров. Формат задается по правилам метода <code>String.format()</code>. Существует несколько модификаций данного метода в зависимости от набора параметров. Если локаль не указана в параметре метода, используется локаль текущего пользователя.</para>
            <para>Пример:<programlisting>String formattedValue = messages.formatMessage(getClass(), &quot;someFormat&quot;, someValue);</programlisting></para>
          </listitem>
          <listitem>
            <para><code>getMainMessage()</code> - возвращает локализованное сообщение из главного пакета данного <link linkend="app_tiers">блока</link> приложения.</para>
            <para>Пример:<programlisting>protected Messages messages = AppBeans.get(Messages.class);
...
messages.getMainMessage(&quot;actions.Ok&quot;);</programlisting></para>
          </listitem>
          <listitem>
            <para><code>getMainMessagePack()</code> - возвращает имя главного пакета сообщений данного блока приложения.</para>
            <para>Пример:<programlisting>String formattedValue = messages.formatMessage(messages.getMainMessagePack(), &quot;someFormat&quot;, someValue);</programlisting></para>
          </listitem>
          <listitem>
            <para><code>getTools()</code> - возвращает экземпляр интерфейса  <code>MessageTools</code>  (см. ниже).</para>
          </listitem>
        </itemizedlist>
        <section id="messageTools">
          <title>MessageTools</title>
          <para><link linkend="managed_beans">ManagedBean</link>, содержащий вспомогательные методы работы с <link linkend="localization">локализованными сообщениями</link>. Интерфейс <code>MessageTools</code> можно получить либо методом <code>Messages.getTools()</code>, либо как любой другой бин - инжекцией или через класс <code>AppBeans</code>. </para>
          <para>Методы <code>MessageTools</code>:<itemizedlist>
              <listitem id="messageTools.loadString">
                <para><code>loadString()</code> - возвращает локализованное сообщение, заданное ссылкой вида <literal>msg://{messagePack}/{key}</literal></para>
                <para>Составные части ссылки:<itemizedlist>
                    <listitem>
                      <para><literal>msg://</literal> - обязательный префикс</para>
                    </listitem>
                    <listitem>
                      <para><literal>{messagePack}</literal> - необязательное имя пакета сообщения. Если не указано, предполагается, что имя пакета передается в <code>loadString()</code> отдельным параметром</para>
                    </listitem>
                    <listitem>
                      <para><literal>{key}</literal> - ключ сообщения в пакете</para>
                    </listitem>
                  </itemizedlist></para>
                <para>Примеры ссылок на сообщения:<programlisting>msg://someMessage
msg://com.abc.sales.web.customer/someMessage</programlisting></para>
              </listitem>
              <listitem>
                <para><code>getEntityCaption()</code> - возвращает локализованное название сущности</para>
              </listitem>
              <listitem>
                <para><code>getPropertyCaption()</code> - возвращает локализованное название атрибута сущности</para>
              </listitem>
              <listitem>
                <para><code>hasPropertyCaption()</code> - определяет, задано ли для атрибута сущности локализованное название </para>
              </listitem>
              <listitem>
                <para><code>getLocValue()</code> - возвращает локализованное значение атрибута сущности, основываясь на определении аннотации <code>
                    <link linkend="localizedValue_annotation">@LocalizedValue</link>
                  </code></para>
              </listitem>
              <listitem>
                <para><code>getMessageRef()</code> - формирует для <link linkend="metaProperty">мета-свойства</link> <link linkend="messageTools.loadString">ссылку на сообщение</link>, по которой  можно получить локализованное название атрибута сущности</para>
              </listitem>
            </itemizedlist></para>
          <para>Для расширения набора вспомогательных методов в конкретном приложении бин <code>MessageTools</code> можно <link linkend="bean_extension">переопределить</link>. Примеры работы с  расширенным интерфейсом:<programlisting>MyMessageTools tools = messages.getTools();
tools.foo();</programlisting><programlisting>((MyMessageTools) messages.getTools()).foo();</programlisting> </para>
        </section>
      </section>
      <section id="metadata">
        <title>Metadata</title>
        <para>Интерфейс <code>Metadata</code> обеспечивает доступ к сессии <link linkend="metadata_framework">метаданных</link> и репозиторию <link linkend="views">представлений</link>.</para>
        <para>Методы интерфейса:<itemizedlist>
            <listitem>
              <para><code>getSession()</code> - возвращает экземпляр сессии <link linkend="metadata_framework">метаданных</link> </para>
            </listitem>
            <listitem>
              <para><code>getViewRepository()</code> - возвращает экземпляр репозитория <link linkend="views">представлений</link></para>
            </listitem>
            <listitem>
              <para><code>getExtendedEntities()</code> - возвращает экземпляр <code>ExtendedEntities</code>, предназначенный для работы с расширенными сущностями. Подробнее см. <xref linkend="entity_extension"/></para>
            </listitem>
            <listitem>
              <para><code>create()</code> - создать экземпляр сущности, учитывая возможность расширения. Подробнее см. <xref linkend="entity_extension"/> </para>
            </listitem>
            <listitem>
              <para><code>getTools()</code> - возвращает экземпляр интерфейса  <code>MetadataTools</code>  (см. ниже).</para>
            </listitem>
          </itemizedlist></para>
        <section>
          <title>MetadataTools</title>
          <para><link linkend="managed_beans">ManagedBean</link>, содержащий вспомогательные методы работы с метаданными. Интерфейс <code>MetadataTools</code> можно получить либо методом <code>Metadata.getTools()</code>, либо как любой другой бин - инжекцией или через класс <code>AppBeans</code>.</para>
          <para>Методы <code>MetadataTools</code>:<itemizedlist>
              <listitem>
                <para><code>getAllPersistentMetaClasses()</code> - возвращает коллекцию <link linkend="metaClass">мета-классов</link> персистентных сущностей</para>
              </listitem>
              <listitem>
                <para><code>getAllEmbeddableMetaClasses()</code> - возвращает коллекцию <link linkend="metaClass">мета-классов</link> встраиваемых сущностей</para>
              </listitem>
              <listitem>
                <para><code>getAllEnums()</code> - возвращает коллекцию классов перечислений, используемых в качестве типов атрибутов сущностей</para>
              </listitem>
              <listitem>
                <para><code>format()</code> - форматирует переданное значение в соответствии с типом данных заданного <link linkend="metaProperty">мета-свойства</link></para>
              </listitem>
              <listitem>
                <para><code>isSystem()</code> - определяет, является ли переданное <link linkend="metaProperty">мета-свойство</link> системным, т.е. заданным в одном из <link linkend="entity_base_classes">базовых интерфейсов сущностей</link></para>
              </listitem>
              <listitem>
                <para><code>isPersistent()</code> - определяет, является ли переданное мета-свойство персистентным, т.е. хранимым в БД</para>
              </listitem>
              <listitem>
                <para><code>isTransient()</code> - определяет, является ли переданное мета-свойство или произвольный атрибут неперсистентным</para>
              </listitem>
              <listitem>
                <para><code>isEmbedded()</code> - определяет, является ли переданное мета-свойство встроенным объектом</para>
              </listitem>
              <listitem>
                <para><code>isAnnotationPresent()</code> - определяет наличие указанной аннотации на классе или его предках</para>
              </listitem>
              <listitem>
                <para><code>getNamePatternProperties()</code> - возвращает коллекцию мета-свойств атрибутов, входящих в  имя экземпляра, возвращаемого методом <code>Instance.getInstanceName()</code>. См. <code>
                    <link linkend="namePattern">@NamePattern</link>
                  </code>.</para>
              </listitem>
            </itemizedlist></para>
          <para>Для расширения набора вспомогательных методов в конкретном приложении бин <code>MetadataTools</code> можно <link linkend="bean_extension">переопределить</link>. Примеры работы с  расширенным интерфейсом:<programlisting>MyMetadataTools tools = metadata.getTools();
tools.foo();</programlisting><programlisting>((MyMetadataTools) metadata.getTools()).foo();</programlisting></para>
        </section>
      </section>
      <section id="persistence">
        <title>Persistence</title>
        <para>Интерфейс <link linkend="app_tiers">уровня</link> <structname>Middleware</structname>, являющийся точкой входа в функциональность хранения данных в БД.<tip>
            <para>Интерфейс <code>Persistence</code> доступен только в <link linkend="app_modules">модуле</link> <structname>core</structname> проекта приложения.</para>
          </tip></para>
        <para>Методы интерфейса:<itemizedlist>
            <listitem>
              <para><code>createTransaction()</code>, <code>getTransaction()</code> - получить интерфейс управления <link linkend="transactions">транзакциями</link></para>
            </listitem>
            <listitem>
              <para><code>isInTransaction()</code> - определяет, существует ли в данный момент активная транзакция</para>
            </listitem>
            <listitem>
              <para><code>getEntityManager()</code> - возвращает экземпляр <code>
                  <link linkend="entityManager">EntityManager</link>
                </code> для текущей транзакции</para>
            </listitem>
            <listitem>
              <para><code>isSoftDeletion()</code> - позволяет определить, активен ли режим <link linkend="soft_deletion">мягкого удаления</link></para>
            </listitem>
            <listitem>
              <para><code>setSoftDeletion()</code> - устанавливает или отключает режим мягкого удаления. Влияет на аналогичный признак всех создаваемых экземпляров <code>EntityManager</code>. По умолчанию мягкое удаление включено.</para>
            </listitem>
            <listitem>
              <para><code>getDbDialect()</code> - возвращает диалект используемой в данный момент базы данных. Интерфейс <code>DbDialect</code> определяет тип БД и некоторые специфические для данной БД параметры.</para>
              <para>В прикладном коде данный метод можно использовать для определения типа используемой БД, например:<programlisting>@Inject
protected Persistence persistence;
...
if (persistence.getDbDialect() instanceof PostgresDbDialect) 
...</programlisting></para>
            </listitem>
            <listitem>
              <para><code>getDataSource()</code> - получить <code>javax.sql.DataSource</code> для используемой в данный момент базы данных.</para>
              <warning>
                <para>Для всех объектов <code>javax.sql.Connection</code>, получаемых методом <code>getDataSource().getConnection()</code>, необходимо после использования соединения вызвать метод <code>close()</code> в секции <code>finally</code>. В противном случае соединение не вернется в пул, через какое-то время пул переполнится, и приложение не сможет выполнять запросы к базе данных. </para>
              </warning>
            </listitem>
            <listitem>
              <para><code>getTools()</code> - возвращает экземпляр интерфейса  <code>PersistenceTools</code> (см. ниже).</para>
            </listitem>
          </itemizedlist></para>
        <section id="persistenceTools">
          <title>PersistenceTools</title>
          <para><link linkend="managed_beans">ManagedBean</link>, содержащий вспомогательные методы работы с хранилищем данных. Интерфейс <code>PersistenceTools</code> можно получить либо методом <code>Persistence.getTools()</code>, либо как любой другой бин - инжекцией или через класс <code>AppBeans</code>.</para>
          <para>Методы <code>PersistenceTools</code>:<itemizedlist>
              <listitem>
                <para><code>getDirtyFields()</code> - возвращает коллекцию имен атрибутов сущности, измененных со времени последней загрузки экземпляра из БД. Для новых экземпляров возвращает пустую коллекцию.</para>
              </listitem>
              <listitem>
                <para><code>isLoaded()</code> - определяет, загружен ли из БД указанный атрибут экземпляра. Атрибут может быть <emphasis>не</emphasis> загружен, если он не указан в примененном при загрузке <link linkend="views">представлении</link>. </para>
                <para>Данный метод работает только для экземпляров в  состоянии <link linkend="entity_states">Managed</link>.</para>
              </listitem>
              <listitem>
                <para><code>getReferenceId()</code> - возвращает идентификатор связанной сущности без загрузки ее из БД. </para>
                <para>Предположим, в <glossterm linkend="persistence_context">персистентный контекст</glossterm> загружен экземпляр <code>Order</code>, и нужно получить значение идентификатора экземпляра <code>Customer</code>, связанного с данным Заказом. Стандартное решение <code>order.getCustomer().getId()</code> приведет к выполнению SQL запроса к БД для загрузки экземпляра <code>Customer</code>, что в данном случае избыточно, так как значение идентификатора Покупателя физически находится также и в таблице Заказов. Выполнение же <programlisting>persistence.getTools().getReferenceId(order, &quot;customer&quot;)</programlisting>не вызывет никаких дополнительных запросов к базе данных. </para>
                <para>Данный метод работает только для экземпляров в  состоянии <link linkend="entity_states">Managed</link>.</para>
              </listitem>
              <listitem>
                <para><code>reloadEntity()</code> - перезагрузить экземпляр сущности с указанным <link linkend="views">представлением</link>. Данный метод должен вызываться внутри активной <link linkend="transactions">транзакции</link>.</para>
              </listitem>
            </itemizedlist></para>
          <para>Для расширения набора вспомогательных методов в конкретном приложении бин <code>PersistenceTools</code> можно <link linkend="bean_extension">переопределить</link>. Примеры работы с  расширенным интерфейсом:<programlisting>MyPersistenceTools tools = persistence.getTools();
tools.foo();</programlisting><programlisting>((MyPersistenceTools) persistence.getTools()).foo();</programlisting></para>
        </section>
        <section id="persistenceHelper">
          <title>PersistenceHelper</title>
          <para>Вспомогательный класс для получения информации о персистентных сущностях. В отличие от бинов <code>Persistence</code> и <code>PersistenceTools</code> доступен на всех <link linkend="app_tiers">уровнях</link> приложения.</para>
          <para>Методы <code>PersistenceHelper</code>:<itemizedlist>
              <listitem>
                <para><code>isNew()</code> - определяет, является ли переданный экземпляр только что созданным, т.е. находящимся в состоянии <link linkend="entity_states">New</link>. Возвращает <code>true</code> также если экземпляр не является персистентной сущностью.</para>
              </listitem>
              <listitem>
                <para><code>isDetached()</code> - определяет, находится ли переданный экземпляр в состоянии <link linkend="entity_states">Detached</link>. Возвращает <code>true</code> также если экземпляр не является персистентной сущностью.</para>
              </listitem>
              <listitem>
                <para><code>isSoftDeleted()</code> - определяет, поддерживает ли переданный класс сущности <link linkend="soft_deletion">мягкое удаление</link></para>
              </listitem>
              <listitem>
                <para><code>getEntityName()</code> - возвращает имя сущности, заданное в <link linkend="entity_annotations">аннотации</link> <code>@Entity</code></para>
              </listitem>
              <listitem>
                <para><code>getTableName()</code> - возвращает имя таблицы БД, хранящей экземпляры сущности, заданное в <link linkend="entity_annotations">аннотации</link> <code>@Table</code></para>
              </listitem>
            </itemizedlist></para>
        </section>
      </section>
      <section id="resources">
        <title>Resources</title>
        <para>Обеспечивает загрузку ресурсов по следующим правилам:<orderedlist>
            <listitem>
              <para>если указанное местонахождение представляет собой URL, ресурс загружается из этого URL;</para>
            </listitem>
            <listitem>
              <para>если указанное местонахождение начинается с префикса <literal>classpath:</literal>, ресурс загружается из classpath;</para>
            </listitem>
            <listitem>
              <para>если не URL и не начинается с <literal>classpath:</literal>, то:<orderedlist>
                  <listitem>
                    <para>в <link linkend="conf_dir">каталоге конфигурации</link> приложения ищется файл, используя указанное местонахождение как относительный путь. Если файл найден, ресурс загружается из него;</para>
                  </listitem>
                  <listitem>
                    <para>если ресурс не найден на предыдущих этапах, он загружается из classpath.</para>
                  </listitem>
                </orderedlist></para>
            </listitem>
          </orderedlist></para>
        <para>На практике явное указание URL или префикса <code>classpath:</code> используется редко, т.е. обычно ресурсы загружаются либо из <link linkend="conf_dir">конфигурационного каталога</link>, либо из classpath. Ресурс в конфигурационном каталоге замещает одноименный ресурс в classpath.</para>
        <para>Методы <code>Resources</code>:<itemizedlist>
            <listitem>
              <para><code>getResourceAsStream()</code> - возвращает <code>InputStream</code> для указанного ресурса, либо <code>null</code>, если ресурс не найден. Поток должен быть закрыт после использования, например:<programlisting>@Inject
protected Resources resources;
...
InputStream stream = null;
try {
    stream = resources.getResourceAsStream(resourceLocation);
    ...
} finally {
    IOUtils.closeQuietly(stream);
}</programlisting></para>
              <para>Возможно использование &quot;try with resources&quot;:<programlisting>try (InputStream stream = resources.getResourceAsStream(resourceLocation)) {
    ...
}</programlisting></para>
            </listitem>
            <listitem>
              <para><code>getResourceAsString()</code> - возвращает указанный ресурс в виде строки, либо <code>null</code>, если ресурс не найден</para>
            </listitem>
          </itemizedlist></para>
      </section>
      <section id="scripting">
        <title>Scripting</title>
        <para>Интерфейс <code>Scripting</code> позволяет динамически (т.е. во время работы приложения) компилировать и загружать классы Java и Groovy, а также выполнять скрипты и выражения на Groovy.</para>
        <para>Методы <code>Scripting</code>:<itemizedlist>
            <listitem>
              <para><code>evaluateGroovy()</code> - выполняет выражение на Groovy и возвращает его результат. </para>
              <para>Свойство приложения <property>
                  <link linkend="cuba.groovyEvaluatorImport">cuba.groovyEvaluatorImport</link>
                </property> позволяет определить общий набор импортируемых классов, подставляемых в каждое выполняемое выражение. По умолчанию все стандартные блоки приложения импортируют класс <code>
                  <link linkend="persistenceHelper">PersistenceHelper</link>
                </code>.</para>
              <para>Скомпилированные выражения кэшируются, что значительно ускоряет повторное выполнение.</para>
              <para>Пример:<programlisting>@Inject
protected Scripting scripting;
...
Integer intResult = scripting.evaluateGroovy(&quot;2 + 2&quot;, new Binding());

Binding binding = new Binding();
binding.setVariable(&quot;instance&quot;, new User());
Boolean boolResult = scripting.evaluateGroovy(&quot;return PersistenceHelper.isNew(instance)&quot;, binding);</programlisting></para>
            </listitem>
            <listitem id="scripting.runGroovyScript">
              <para><code>runGroovyScript()</code> - выполняет скрипт Groovy и возвращает его результат.</para>
              <para>Скрипт должен быть расположен либо в <link linkend="conf_dir">конфигурационном каталоге</link> приложения, либо в classpath (текущая реализация <code>Scripting</code> поддерживает ресурсы classpath только внутри JAR-файлов). Скрипт в конфигурационном каталоге замещает одноименный скрипт в classpath.</para>
              <para>Путь к скрипту указывается с разделителями <literal>/</literal>, в начале пути символ <literal>/</literal> не требуется.</para>
              <para>Пример:<programlisting>@Inject
protected Scripting scripting;
...
Binding binding = new Binding();
binding.setVariable(&quot;itemId&quot;, itemId);
BigDecimal amount = scripting.runGroovyScript(&quot;com/abc/sales/CalculatePrice.groovy&quot;, binding);</programlisting></para>
            </listitem>
            <listitem>
              <para><code>loadClass()</code> - загружает Java или Groovy класс, используя следующую последовательность действий:<orderedlist>
                  <listitem>
                    <para>Если класс уже загружен, возвращает его.</para>
                  </listitem>
                  <listitem>
                    <para>Ищет исходный текст Groovy (файл <filename>*.groovy</filename>) в каталоге конфигурации. Если найден, компилирует его, загружает  и возвращает класс.</para>
                  </listitem>
                  <listitem>
                    <para>Ищет исходный текст Java (файл <filename>*.java</filename>) в каталоге конфигурации. Если найден, компилирует его, загружает и возвращает класс.</para>
                  </listitem>
                  <listitem>
                    <para>Ищет скомпилированный класс в classpath, если найден - загружает и возвращает его.</para>
                  </listitem>
                  <listitem>
                    <para>Если ничего не найдено, возвращает <code>null</code>.</para>
                  </listitem>
                </orderedlist></para>
              <para>Файлы исходных текстов Java и Groovy  в каталоге конфигурации можно изменять во время работы приложения. При следующем вызове <code>loadClass()</code> соответствующий класс будет перекомпилирован и возвращен новый, однако существуют следующие ограничения:<itemizedlist>
                  <listitem>
                    <para>нельзя изменять тип исходного текста с Groovy на Java</para>
                  </listitem>
                  <listitem>
                    <para>если существовал исходный текст Groovy, и был однажды скомпилирован, то удаление файла исходного текста не приведет к загрузке другого класса из classpath - будет по прежнему возвращаться класс, скомпилированный из  удаленного исходника.</para>
                  </listitem>
                </itemizedlist></para>
              <para>Пример:<programlisting>@Inject
protected Scripting scripting;
...
Class calculatorClass = scripting.loadClass(&quot;com.abc.sales.PriceCalculator&quot;);</programlisting></para>
            </listitem>
            <listitem>
              <para><code>getClassLoader()</code> - возвращает <code>ClassLoader</code>, способный работать по правилам, описанным выше для метода <code>loadClass()</code>.</para>
            </listitem>
          </itemizedlist></para>
        <para>Кэш скомпилированных классов можно очистить во время выполнения с помощью JMX-бинов <link linkend="cachingMBean">CachingMBean</link> и <link linkend="cachingFacadeMBean">CachingFacadeMBean</link>.</para>
        <para>См. также <xref linkend="scriptingManagerMBean"/></para>
      </section>
      <section>
        <title>Security</title>
        <para>Обеспечивает авторизацию - проверку прав пользователя на различные объекты системы. Большинство методов просто получают текущую пользовательскую сессию через <link linkend="userSessionSource">UserSessionSource</link> и делегируют ей выполнение авторизации. Подробнее см. <xref linkend="authentication"/></para>
      </section>
      <section id="timeSource">
        <title>TimeSource</title>
        <para>Обеспечивает получение текущего времени. Применение <code>new Date()</code> и т.п. в прикладном коде не рекомендуется.</para>
        <para>Примеры:<programlisting>@Inject
protected TimeSource timeSource;
...
Date date = timeSource.currentTimestamp();</programlisting><programlisting>long startTime = AppBeans.get(TimeSource.class).currentTimeMillis();</programlisting></para>
      </section>
      <section id="userSessionSource">
        <title>UserSessionSource</title>
        <para>Обеспечивает получение объекта сессии текущего пользователя. Подробнее см. <xref linkend="authentication"/></para>
      </section>
      <section>
        <title>UuidSource</title>
        <para>Обеспечивает получение значений <code>UUID</code>, в том числе для идентификаторов сущностей. Применение <code>UUID.randomUUID()</code> в прикладном коде не рекомендуется.</para>
      </section>
    </section>
    <section id="appContext">
      <title>AppContext</title>
      <para><code>AppContext</code> - системный класс, в статических полях которого хранятся ссылки на некоторые общие для любого <link linkend="app_tiers">блока</link> приложения компоненты:<itemizedlist>
          <listitem>
            <para><code>ApplicationContext</code> фреймворка <application>Spring</application></para>
          </listitem>
          <listitem>
            <para>Набор <link linkend="app_properties">свойств приложения</link>, загруженных из файлов <filename>app.properties</filename></para>
          </listitem>
          <listitem>
            <para><code>ThreadLocal</code> переменная, хранящая экземпляры <code>SecurityContext</code></para>
          </listitem>
          <listitem>
            <para>Коллекция слушателей жизненного цикла приложения ( <code>AppContext.Listener</code>)</para>
          </listitem>
        </itemizedlist></para>
      <para><code>AppContext</code> инициализируется на запуске приложения классами-загрузчиками, специфичными для типа <link linkend="app_tiers">блока</link> приложения:<itemizedlist>
          <listitem>
            <para>загрузчик <structname>Middleware</structname> - <code>AppContextLoader</code></para>
          </listitem>
          <listitem>
            <para>загрузчик <structname>Web Client</structname> - <code>WebAppContextLoader</code></para>
          </listitem>
          <listitem>
            <para>загрузчик <structname>Web Portal</structname> - <code>PortalAppContextLoader</code></para>
          </listitem>
          <listitem>
            <para>загрузчик <structname>Desktop Client</structname> - <code>DesktopAppContextLoader</code></para>
          </listitem>
        </itemizedlist></para>
      <para><code>AppContext</code> может быть использован в прикладном коде для решения следующих задач:<itemizedlist>
          <listitem>
            <para>Регистрации слушателей, срабатывающих после полной инициализации и перед закрытием приложения, например:<programlisting>AppContext.addListener(new AppContext.Listener() {
    @Override
    public void applicationStarted() {
        System.out.println(&quot;Application is ready&quot;);
    }

    @Override
    public void applicationStopped() {
        System.out.println(&quot;Application is closing&quot;);
    }
});</programlisting>  </para>
          </listitem>
          <listitem>
            <para>Проверки того, что данный <link linkend="app_tiers">блок</link> приложения полностью инициализирован и готов к выполнению. Такая проверка обычно необходима в методах бинов, автоматически запускаемых <link linkend="scheduled_tasks_spring">планировщиком</link> <application>Sping</application>.</para>
            <para>Пример:<programlisting>if (!AppContext.isStarted())
    return;</programlisting></para>
          </listitem>
          <listitem>
            <para>Получения значений <link linkend="app_properties">свойств приложения</link>, хранимых в файлах <filename>app.properties</filename>, если они недоступны через <link linkend="config_interfaces">конфигурационные интерфейсы</link>.</para>
          </listitem>
          <listitem>
            <para>Передачи <code>SecurityContext</code> в новые потоки выполнения, см. <xref linkend="authentication"/>.</para>
          </listitem>
        </itemizedlist></para>
      <tip>
        <para>Для получения ссылок на <application>Spring</application>-бины используйте инжекцию или статические методы класса <code>AppBeans</code>.</para>
        <para>Использование <code>AppContext.getApplicationContext().getBean()</code> не рекомендуется.</para>
      </tip>
    </section>
    <section id="app_properties">
      <title>Свойства приложения</title>
      <section>
        <title>Основные понятия</title>
        <para>Свойства приложения − именованные данные различных типов, определяющие всевозможные аспекты конфигурации и функционирования приложения.</para>
        <para>По назначению свойства приложения можно классифицировать следующим образом:</para>
        <itemizedlist>
          <listitem>
            <para><firstterm>Конфигурационные параметры</firstterm> - задают наборы конфигурационных файлов и некоторые параметры пользовательского интерфейса, т.е. определяют функциональность приложения. </para>
            <para>Например: <property>cuba.springContextConfig</property>, <property>cuba.web.useLightHeader</property>.</para>
          </listitem>
          <listitem>
            <para><firstterm>Параметры развертывания</firstterm> - различные URL для соединения <link linkend="app_tiers">блоков</link> приложения, тип используемой БД, настройки подсистемы безопасности и т.д. </para>
            <para>Например: <property>cuba.connectionUrl</property>, <property>cuba.dbmsType</property>, <property>
                <link linkend="cuba.userSessionExpirationTimeoutSec">cuba.userSessionExpirationTimeoutSec</link>
              </property>.</para>
          </listitem>
          <listitem>
            <para><firstterm>Параметры времени выполнения</firstterm> - активность аудита, параметры отсылки email и т.д. </para>
            <para>Например: <property>cuba.security.EntityLog.enabled</property>, <property>cuba.email.smtpHost</property>.</para>
          </listitem>
        </itemizedlist>
        <para>Как правило, некоторое свойство принадлежит только одному или нескольким <link linkend="app_tiers">блокам</link> приложения. Например, <property>
            <link linkend="cuba.persistenceConfig">cuba.persistenceConfig</link>
          </property> имеет смысл только для <structname>Middleware</structname>, <property> cuba.web.useLightHeader</property> − только для <structname>Web Client</structname>, а <property>
            <link linkend="cuba.springContextConfig">cuba.springContextConfig</link>
          </property> − для всех блоков. </para>
        <para>Принадлежность к блоку означает, что если нужно задать значение некоторому свойству, это необходимо сделать <emphasis>во всех блоках</emphasis>, которым данное свойство принадлежит (и которые используются в приложении). </para>
        <para>Принадлежность можно выяснить следующими способами:<itemizedlist>
            <listitem>
              <para>Из документации: см. <xref linkend="app_properties_reference"/> </para>
            </listitem>
            <listitem>
              <para>Проследив использование свойства в коде приложения</para>
            </listitem>
            <listitem>
              <para>Если к свойству есть доступ через <link linkend="config_interfaces">конфигурационный интерфейс</link>, то по принадлежности интерфейса <link linkend="app_modules">модулю</link> проекта.</para>
            </listitem>
          </itemizedlist></para>
      </section>
      <section>
        <title>Доступ к свойствам</title>
        <para><para>Основной способ доступа к свойствам приложения из прикладного кода − использование механизма <link linkend="config_interfaces">конфигурационных интерфейсов</link>. Кроме того, все параметры конфигурации и развертывания доступны через методы класса <code>
              <link linkend="appContext">AppContext</link>
            </code>.</para></para>
        <para>Некоторые блоки приложения определяют JMX-интерфейсы для доступа к свойствам приложения. В частности, в блоках Middleware, Web Client и Web Portal имеется JMX-интерфейс <code>
            <link linkend="configStorageMBean">ConfigStorageMBean</link>
          </code>, позволяющий получить и задать значение любого свойства во время работы приложения. </para>
      </section>
      <section id="app_properties_files">
        <title>Хранение свойств в файлах</title>
        <para>Свойства, определяющие конфигурацию и параметры развертывания, задаются в специальных файлах свойств, имеющих имя вида <filename>*-app.properties</filename>. Каждый <link linkend="app_tiers">блок</link> приложения имеет набор таких файлов, включающий в себя файлы из <link linkend="base_projects">базовых проектов</link> платформы и файл текущего приложения. Набор файлов свойств  определяется следующим образом:</para>
        <itemizedlist>
          <listitem>
            <para>Для блоков, являющихся веб-приложениями (<structname>Middleware</structname>, <structname>Web Client</structname>, <structname>Web Portal</structname>) набор файлов свойств задается в <filename>web.xml</filename> в параметре <literal>appPropertiesConfig</literal>.</para>
          </listitem>
          <listitem>
            <para>Для блока <structname>Desktop Client</structname> основной способ задания набора файлов свойств − переопределение в приложении метода <methodname>getDefaultAppPropertiesConfig()</methodname> в классе-наследнике <code>com.haulmont.cuba.desktop.App</code>.</para>
          </listitem>
        </itemizedlist>
        <para>Например, набор файлов свойств блока <structname>Middleware</structname> проекта <application>sales</application> задается в файле  <filename>web/WEB-INF/web.xml</filename>  модуля <structname>core</structname>, и выглядит следующим образом:</para>
        <programlisting>classpath:cuba-app.properties
classpath:app.properties
file:${catalina.home}/conf/app-core/local.app.properties</programlisting>
        <para>Здесь префикс <literal>classpath:</literal> означает, что данный файл нужно искать в Java classpath, префикс <literal>file:</literal> − в файловой системе. Возможно использование системных свойств Java, в данном случае это <literal>catalina.home</literal> − путь к корню <application>Tomcat</application>.</para>
        <para>Порядок перечисления файлов важен, так как значения, указанные в каждом последующем файле заменяют значения одноименных свойств, заданные в предыдущих файлах. Этим достигается переопределение свойств платформы в конкретном приложении.</para>
        <para>Последний файл в приведенном наборе − <filename>local.app.properties</filename>. Он может использоваться для переопределения свойств приложения при развертывании. Если этого файла нет, он игнорируется. Если же во время инсталляции системы требуется переопределение некоторых параметров (как правило различных URL), достаточно создать этот файл и поместить в него переопределяемые свойства. При последующих обновлениях системы такой файл с локальными настройками легко сохранить.</para>
        <para>Аналогом <filename>local.app.properties</filename> для <structname>Desktop Client</structname> служат аргументы командной строки запуска JVM. Загрузчик свойств данного блока воспринимает все аргументы, содержащие знак &quot;<literal>=</literal>&quot;, как пары ключ-значение, и заменяет ими соответствующие свойства приложения, заданные в файлах <filename>app.properties</filename>.</para>
        <tip>
          <para>Правила задания информации в файлах  <filename>*.properties</filename>:</para>
          <itemizedlist>
            <listitem>
              <para>Кодировка файла - <literal>UTF-8</literal></para>
            </listitem>
            <listitem>
              <para>Ключ может состоять из латинских букв, цифр, точек  и знаков подчеркивания</para>
            </listitem>
            <listitem>
              <para>Значение пишется после знака равно (<literal>=</literal>)</para>
            </listitem>
            <listitem>
              <para>Значение  не нужно брать в кавычки &quot; или &apos;</para>
            </listitem>
            <listitem>
              <para>Файловые пути записываются либо в UNIX виде (<filename>/opt/haulmont/</filename>), либо в Windows виде (<filename>c:\\haulmont\\</filename>)</para>
            </listitem>
            <listitem>
              <para>Возможно использование кодов <literal>\n \t \r</literal>. Символ <literal>\</literal>  является зарезервированным, для вставки в значение экранируется сам собой (<literal>\\</literal>).
Подробнее см.: <ulink url="http://docs.oracle.com/javase/tutorial/java/data/characters.html">http://docs.oracle.com/javase/tutorial/java/data/characters.html</ulink></para>
            </listitem>
            <listitem>
              <para>Для ввода значения в нескольких строках файла используйте символ <literal>\</literal> в конце строки, для того чтобы данное значение продолжалось на следующей строке.</para>
            </listitem>
          </itemizedlist>
        </tip>
      </section>
      <section>
        <title>Хранение свойств в базе данных</title>
        <para>Параметры времени выполнения хранятся в таблице <database>SYS_CONFIG</database> базы данных. </para>
        <para>Такие свойства имеют следующие особенности:<itemizedlist>
            <listitem>
              <para>так как значение свойства хранится в базе данных, оно задается в одном месте, независимо от того, в каких  блоках приложения оно используется</para>
            </listitem>
            <listitem>
              <para>значение может быть изменено и сохранено во время работы приложения, как через <link linkend="config_interfaces">конфигурационный интерфейс</link>, содержащий это свойство, так и через <link linkend="configStorageMBean">ConfigStorageMBean</link>.</para>
            </listitem>
            <listitem>
              <para>значение свойства может быть переопределено для конкретного блока приложения в его файле <filename>app.properties</filename>. Поиск значения всегда происходит в два этапа - сначала в <filename>app.properties</filename>, если не найдено - то в базе данных. Поэтому изменять значение нужно в обоих местах хранения.</para>
            </listitem>
          </itemizedlist></para>
        <para>Хранящиеся в БД свойства кэшируются на уровне <structname>Middleware</structname>. Очистить кэш можно с помощью JMX-интерфейсов <code>
            <link linkend="configStorageMBean">ConfigStorageMBean</link>
          </code> методом <code>clearCache()</code> или <code>
            <link linkend="cachingFacadeMBean">CachingFacadeMBean</link>
          </code> методом <code>clearConfigStorageCache()</code>.</para>
        <para>Следует иметь в виду, что на клиентском уровне чтение свойства, хранящегося в БД, приводит к запросу к <structname>Middleware</structname>, что менее эффективно, чем чтение локального свойства из <filename>app.properties</filename>. Для уменьшения количества таких запросов клиент кэширует все свойства, хранящиеся в БД, на время жизни экземпляра реализации конфигурационного интерфейса. Поэтому если например в некотором экране UI необходимо несколько раз обратиться к свойствам одного конфигурационного интерфейса, лучше получить ссылку на него при инициализации экрана, и сохранить в поле для последующих обращений к одному и тому же экземпляру. </para>
      </section>
      <section id="config_interfaces">
        <title>Конфигурационные интерфейсы</title>
        <para>Данный механизм позволяет работать  со свойствами приложения через методы Java-интерфейсов, что дает следующие преимущества:<itemizedlist>
            <listitem>
              <para>типизированность - прикладной код работает с нужными типами (String, Boolean, Integer и пр.), а не только со строками</para>
            </listitem>
            <listitem>
              <para>в прикладном коде вместо строковых идентификаторов свойств используются методы интерфейсов, имена которых подсказываются средой разработки</para>
            </listitem>
          </itemizedlist></para>
        <para>Пример получения значения таймаута транзакции в блоке <structname>Middleware</structname>:<programlisting>@Inject
protected Configuration configuration;
...
ServerConfig serverConfig = configuration.getConfig(ServerConfig.class);
int timeout = serverConfig.getDefaultQueryTimeoutSec();</programlisting></para>
        <para>Или при невозможности инжекции <link linkend="configuration">Configuration</link>:<programlisting>int timeout = AppBeans.get(Configuration.class)
    .getConfig(ServerConfig.class)
    .getDefaultQueryTimeoutSec();</programlisting></para>
        <section>
          <title>Использование</title>
          <para>Для создания конфигурационного интерфейса необходимо:</para>
          <itemizedlist>
            <listitem>
              <para>Создать интерфейс, унаследованный от <code>com.haulmont.cuba.core.config.Config</code> (не путать с классом сущности <code>com.haulmont.cuba.core.entity.Config</code>)</para>
            </listitem>
            <listitem>
              <para>Добавить интерфейсу  аннотацию <code>@Source</code> для указания источника (способа хранения) параметров:<itemizedlist>
                  <listitem>
                    <para><code>SourceType.SYSTEM</code> - значение свойства будет взято из системных свойств данной JVM, т.е. методом <code> System.getProperty()</code></para>
                  </listitem>
                  <listitem>
                    <para><code>SourceType.APP</code> - значение свойства будет взято из файлов <filename>app.properties</filename></para>
                  </listitem>
                  <listitem>
                    <para><code>SourceType.DATABASE</code> - значение свойства будет взято из таблицы <database>SYS_CONFIG</database></para>
                  </listitem>
                </itemizedlist></para>
            </listitem>
            <listitem>
              <para>Создать методы доступа к свойству (getter / setter). Если значение свойства не предполагается изменять во время выполнения, метод доступа на запись не нужен. Возможный тип свойства рассмотрен ниже.</para>
            </listitem>
            <listitem>
              <para>Добавить методу доступа на чтение аннотацию <code>@Property</code>, определяющую имя свойства.</para>
            </listitem>
            <listitem>
              <para>Опционально аннотацию <code>@Source</code> можно задать для отдельного свойства в интерфейсе, если его источник отличается от заданного для всего интерфейса.</para>
            </listitem>
          </itemizedlist>
          <para>Например:<programlisting>@Source(type = SourceType.DATABASE)
public interface SalesConfig extends Config {

    @Property(&quot;sales.companyName&quot;)
    String getCompanyName();
}</programlisting></para>
          <para>Создавать класс реализации конфигурационного интерфейса не нужно - при получении ссылки на интерфейс через <link linkend="configuration">Configuration</link> будет автоматически создан необходимый прокси-объект.</para>
        </section>
        <section>
          <title>Типы свойств</title>
          <para>Без дополнительных усилий поддерживаются следующие типы свойств: <itemizedlist>
              <listitem>
                <para><code>String</code></para>
              </listitem>
              <listitem>
                <para>простые типы либо их объектные обертки (<code>boolean</code>, <code>Boolean</code>, <code>int</code>, <code>Integer</code>, etc.)</para>
              </listitem>
              <listitem>
                <para>классы персистентных <link linkend="data_model">сущностей</link>. При обращении к свойству типа сущности происходит загрузка из БД экземпляра, заданного значением свойства.</para>
              </listitem>
            </itemizedlist></para>
          <para>Для поддержки произвольного типа необходимо реализовать классы <code>TypeStringify</code> и <code>TypeFactory</code> для преобразования значения в строку и из нее, и указать эти классы для свойства с помощью аннотаций <code>@Stringify</code> и <code>@Factory</code>.</para>
          <para>Рассмотрим этот процесс на примере типа <code>UUID</code>.</para>
          <itemizedlist>
            <listitem>
              <para>Создаем класс <code>com.haulmont.cuba.core.config.type.UuidTypeFactory</code> унаследованный от <code>com.haulmont.cuba.core.config.type.TypeFactory</code> и реализуем в нем метод:<programlisting>public Object build(String string) {
    if (string == null)
        return null;
    return UUID.fromString(string);
}</programlisting></para>
            </listitem>
            <listitem>
              <para><code>TypeStringify</code> создавать не нужно, т.к. по умолчанию будет использован метод <code>toString()</code> − в данном случае он нам подходит.</para>
            </listitem>
            <listitem>
              <para>Аннотируем свойство в конфигурационном интерфейсе:<programlisting>@Factory(factory = UuidTypeFactory.class)
UUID getUuidProp();
void setUuidProp(UUID value);</programlisting></para>
            </listitem>
          </itemizedlist>
        </section>
        <section>
          <title>Значения по умолчанию</title>
          <para>Для свойств конфигурационных интерфейсов могут быть заданы значения по умолчанию. Эти значения будут возвращаться, если данный параметр не задан в месте хранения - в БД или в <filename>app.properties</filename>.</para>
          <para>Значение по умолчанию может быть задано в виде строки с помощью аннотации <code>@Default</code>, либо в виде конкретного типа с помощью других аннотаций пакета <code>com.haulmont.cuba.core.config.defaults</code>:<programlisting>@Property(&quot;cuba.email.adminAddress&quot;)
@Default(&quot;address@company.com&quot;)
String getAdminAddress();

@Property(&quot;cuba.email.delayCallCount&quot;)
@Default(&quot;2&quot;)
int getDelayCallCount();

@Property(&quot;cuba.email.defaultSendingAttemptsCount&quot;)
@DefaultInt(10)
int getDefaultSendingAttemptsCount();</programlisting></para>
          <para>Для сущностей  значение по умолчанию задается строкой вида <literal>{entity_name}-{id}-{optional_view_name}</literal>, например:<programlisting>@Default(&quot;sec$User-98e5e66c-3ac9-11e2-94c1-3860770d7eaf-browse&quot;)
User getAdminUser();

@Default(&quot;sec$Role-a294aef0-3ac9-11e2-9433-3860770d7eaf&quot;)
Role getAdminRole();</programlisting></para>
        </section>
      </section>
    </section>
    <section id="localization">
      <title>Локализация сообщений</title>
      <para>Приложение на основе платформы CUBA поддерживает локализацию сообщений, то есть вывод всех элементов пользовательского интерфейса на языке, выбранном пользователем.</para>
      <para>Возможности выбора языка определяются комбинацией свойств приложения <link linkend="cuba.localeSelectVisible">cuba.localeSelectVisible</link> и <link linkend="cuba.availableLocales">cuba.availableLocales</link>.</para>
      <para>Для того, чтобы некоторое сообщение могло быть локализовано, т.е. представлено пользователю на нужном языке, его необходимо поместить в так называемый <firstterm>пакет сообщений</firstterm>. </para>
      <section id="message_packs">
        <title>Пакеты сообщений</title>
        <para>Пакет сообщений представляет собой набор файлов свойств с именами вида <filename>messages{_XX}.properties</filename>, расположенных в одном Java-пакете. Суффикс <literal>XX</literal> определяет язык, для которого в данном файле содержатся сообщения, и соответствует коду языка в <code>Locale.getLanguage()</code>. Возможно также использование остальных атрибутов <code>Locale</code>, например <code>country</code>. В этом случая файл пакета будет иметь вид <filename>messages{_XX_YY}.properties</filename>. Один из файлов пакета может быть без суффикса языка - это <firstterm>файл по умолчанию</firstterm>. Именем пакета сообщений считается имя Java-пакета, в котором расположены файлы пакета.</para>
        <para>Рассмотрим пример:<programlisting>/com/abc/sales/gui/customer/messages.properties
/com/abc/sales/gui/customer/messages_fr.properties
/com/abc/sales/gui/customer/messages_ru.properties</programlisting></para>
        <para>Данный пакет состоит из 3-х файлов - один для русского языка, один для французского, и один по умолчанию. Имя пакета - <code>com.abc.sales.gui.customer</code> </para>
        <para>Файлы сообщений содержат пары ключ-значение,  где ключ - это идентификатор сообщения, на который ссылается код приложения, а значение - само сообщение на языке данного файла. Правила задания пар аналогичны правилам файлов свойств<code>java.util.Properties</code>, со следующими особенностями:<itemizedlist>
            <listitem>
              <para>Кодировка файла - обязательно <code>UTF-8</code></para>
            </listitem>
            <listitem>
              <para>Поддерживается включение других пакетов сообщений с помощью ключа <literal>@include</literal>, в том числе нескольких сразу - перечислением через запятую. При этом если некоторый ключ сообщения встречается и во включаемом пакете, и в текущем, будет использовано сообщение из текущего. Пример включения пакетов:<programlisting>@include=com.haulmont.cuba.web, com.abc.sales.web

someMessage=Some Message
...</programlisting></para>
            </listitem>
          </itemizedlist></para>
        <para>Получение сообщений из пакетов производится с помощью методов интерфейса <code>
            <link linkend="messages">Messages</link>
          </code> по следующим правилам:<itemizedlist>
            <listitem>
              <para>Сначала производится поиск в <link linkend="conf_dir">конфигурационном каталоге</link> приложения<itemizedlist>
                  <listitem>
                    <para>Ищется файл <filename>messages_XX.properties</filename> в каталоге, задаваемом именем пакета сообщений, где <literal>XX</literal> - код требуемого языка</para>
                  </listitem>
                  <listitem>
                    <para>Если такого файла нет, в этом же каталоге ищется файл по умолчанию <filename>messages.properties</filename></para>
                  </listitem>
                  <listitem>
                    <para>Если найден или файл нужного языка, или файл по умолчанию, он загружается вместе со всеми <literal>@include</literal>, и в нем ищется ключ сообщения</para>
                  </listitem>
                  <listitem>
                    <para>Если файл не найден, либо нужный ключ в нем отсутствует, производится смена каталога на родительский, и процедура поиска повторяется. И так до достижения корня конфигурационного каталога.</para>
                  </listitem>
                </itemizedlist></para>
            </listitem>
            <listitem>
              <para>Если в конфигурационном каталоге сообщение не найдено, производится поиск в classpath по такому-же алгоритму.</para>
            </listitem>
            <listitem>
              <para>На клиентском <link linkend="app_tiers">уровне</link>, если сообщение не найдено на предыдущих шагах, отправляется запрос на <structname>Middleware</structname>, и сообщение ищется там аналогичным способом.</para>
            </listitem>
            <listitem>
              <para>Если сообщение найдено, оно кэшируется и возвращается. Если не найдено - кэшируется факт отсутствия сообщения и возвращается ключ, который был передан для поиска. Таким образом, сложная процедура поиска выполняется только один раз, в дальнейшем результат загружается из локального для блока приложения кэша.</para>
            </listitem>
          </itemizedlist></para>
        <tip>
          <para>Рекомендуется организовывать пакеты сообщений следующим образом:<itemizedlist>
              <listitem>
                <para>Если приложение не предполагает интернационализации, то можно не использовать пакеты и включать строки сообщений прямо в код приложения, либо пользоваться файлами по умолчанию <filename>messages.properties</filename> для отделения ресурсов от кода.</para>
              </listitem>
              <listitem>
                <para>Если приложение  интернациональное, логично файлы по умолчанию использовать для языка основной аудитории приложения, либо для английского языка. Именно сообщения из файлов по умолчанию будут показаны пользователю, если сообщений для нужного языка не найдено.</para>
              </listitem>
            </itemizedlist></para>
        </tip>
      </section>
      <section id="main_message_pack">
        <title>Главный пакет сообщений</title>
        <para>Каждый стандартный <link linkend="app_tiers">блок</link> приложения определяет для себя один <firstterm>главный</firstterm> пакет сообщений. Для блоков клиентского уровня этот пакет содержит названия пунктов главного меню и общих элементов UI (например названия кнопок <guibutton>OK</guibutton> и <guibutton>Cancel</guibutton>). Для всех блоков приложения, включая <structname>Midleware</structname>, главный пакет  определяет форматы преобразований <link linkend="datatype">
            <code>Datatype</code>
          </link>.</para>
        <para>Для указания главного пакета соощений используется свойство приложения <property>
            <link linkend="cuba.mainMessagePack">cuba.mainMessagePack</link>
          </property>. Значением свойства может быть либо один пакет, либо список пакетов, разделенный пробелами. Например:<programlisting>cuba.mainMessagePack=com.haulmont.cuba.web com.abc.sales.web</programlisting></para>
        <para>В данном случае сообщения, заданные во втором пакете списка будут перекрывать сообщений из первого пакета. Таким образом в проекте приложения можно переопределять сообщения, заданные в пакетах <link linkend="base_projects">базовых проектов</link>.</para>
      </section>
      <section>
        <title>Локализация названий сущностей и атрибутов</title>
        <para>Для отображения в UI локализованных названий сущностей и их атрибутов необходимо создать специальные пакеты сообщений в тех же Java-пакетах, что и сами сущности. Формат файлов сообщений должен быть следующим:<itemizedlist>
            <listitem>
              <para>Ключ названия сущности - простое имя класса (без пакета)</para>
            </listitem>
            <listitem>
              <para>Ключ названия атрибута - простое имя класса, затем через точку имя атрибута</para>
            </listitem>
          </itemizedlist></para>
        <para>Пример русской локализации сущности <code>com.abc.sales.entity.Customer</code> - файл <filename>/com/abc/sales/entity/messages_ru.properties</filename>:<programlisting>Customer=Покупатель
Customer.name=Имя
Customer.email=Email

Order=Заказ
Order.customer=Покупатель
Order.date=Дата
Order.amount=Сумма</programlisting></para>
        <para>Такие пакеты сообщений как правило используются неявно для  разработчика, например визуальными компонентами <code>
            <link linkend="gui_Table">Table</link>
          </code> и <code>
            <link linkend="gui_FieldGroup">FieldGroup</link>
          </code>. Кроме того, названия сущностей и атрибутов могут быть также получены следующими методами:<itemizedlist>
            <listitem>
              <para>программно - методами <code>
                  <link linkend="messageTools">MessageTools</link>
                </code> <code>getEntityCaption()</code>, <code>getPropertyCaption()</code></para>
            </listitem>
            <listitem>
              <para>в XML дескрипторе экрана - указанием ссылки на сообщение по правилам <code>MessageTools.<link linkend="messageTools.loadString">loadString</link>()</code>: <literal>msg://{entity_package}/{key}</literal>, например <programlisting>caption=&quot;msg://com.abc.sales.entity/Customer.name&quot;</programlisting></para>
            </listitem>
          </itemizedlist></para>
      </section>
      <section>
        <title>Локализация enum</title>
        <para>Для локализации названий  и значений перечислений необходимо в пакет сообщений, находящийся в Java-пакете класса перечисления добавить сообщения со следующими ключами:<itemizedlist>
            <listitem>
              <para>Ключ названия перечисления - простое имя класса (без пакета)</para>
            </listitem>
            <listitem>
              <para>Ключ значения - простое имя класса, затем через точку имя значения</para>
            </listitem>
          </itemizedlist></para>
        <para>Например, для перечисления <programlisting>package com.abc.sales;

public enum CustomerGrade { PREMIUM, HIGH, STANDARD }</programlisting></para>
        <para>файл русской локализации <filename>/com/abc/sales/messages_ru.properties</filename> должен содержать строки:<programlisting>CustomerGrade=Уровень покупателя
CustomerGrade.PREMIUM=Премиум
CustomerGrade.HIGH=Высокий
CustomerGrade.STANDARD=Стандартный</programlisting></para>
        <para>Локализованные значения перечислений автоматически используются различными визуальными компонентами, например <code>
            <link linkend="gui_LookupField">LookupField</link>
          </code>. Для программного получения локализованного значения перечисления можно использовать метод <code>getMessage()</code> интерфейса <code>
            <link linkend="messages">Messages</link>
          </code>, просто передавая в него экземпляр <code>enum</code>.</para>
      </section>
    </section>
    <section id="authentication">
      <title>Аутентификация пользователей</title>
      <para>В данном разделе рассмотрены некоторые аспекты управления доступом с точки зрения разработчика приложения. Для получения полной информации о возможностях и настройке доступа пользователей к данным  обратитесь к руководству <productname>Платформа CUBA. Подсистема безопасности</productname>. </para>
      <section id="userSession">
        <title>UserSession</title>
        <para>Основной элемент подсистемы контроля доступа в CUBA-приложении - пользовательская сессия. Это объект класса <code>UserSession</code>, который ассоциирован с аутентифицированным в данный момент в системе пользователем, и содержит информацию о правах доступа пользователя к данным. Объект текущей сессии может быть получен в любом <link linkend="app_tiers">блоке</link> приложения через интерфейс инфраструктуры <code>
            <link linkend="userSessionSource">UserSessionSource</link>
          </code>. </para>
        <para>Пользовательская сессия создается на <structname>Middleware</structname> при выполнении метода <code>LoginService.login()</code> после аутентификации пользователя по переданному имени и паролю. Объект <code>UserSession</code> затем кэшируется в данном блоке <structname>Middleware</structname>, и возвращается на клиентский уровень. При работе в кластере объект сессии реплицируется на соседние узлы кластера <structname>Middleware</structname>. Клиентский блок, получив объект сессии, также сохраняет его у себя, так или иначе ассоциируя с активным пользователем (например в HTTP сессии). Далее все вызовы <structname>Middleware</structname> для данного пользователя сопровождаются передачей идентификатора сессии (типа <code>UUID</code>), причем прикладному коду не нужно об этом заботиться - идентификатор сессии передается автоматически, независимо от сигнатуры вызываемых методов среднего слоя. Обработка вызовов клиентов на <structname>Middleware</structname> начинается с извлечения из кэша сессии по полученному идентификатору и установки ее в потоке выполнения. Объект сессии удаляется из кэша при вызове метода <code>LoginService.logout()</code>, либо при истечения времени бездействия, определяемого свойством  приложения <property>
            <link linkend="cuba.userSessionExpirationTimeoutSec">cuba.userSessionExpirationTimeoutSec</link>
          </property>.</para>
        <para>Таким образом, идентификатор сессии, создаваемой при входе пользователя в систему, служит для аутентификации пользователя при каждом вызове среднего слоя.</para>
        <para>Объект <code>UserSession</code> содержит также методы для <firstterm>авторизации</firstterm> текущего пользователя, т.е. проверки его прав на объекты системы: <code>isScreenPermitted()</code>, <code>isEntityOpPermitted()</code>, <code>isEntityAttrPermitted()</code>, <code>isSpecificPermitted()</code>.</para>
        <para>С объектом <code>UserSession</code> могут быть ассоциированы именованные атрибуты произвольного сериализуемого типа. Атрибуты устанавливаются методом <code>setAttribute()</code> и возвращаются методом <code>getAttribute()</code>. Последний может также возвращать следующие параметры сессии, как если бы они были атрибутами:<itemizedlist>
            <listitem>
              <para><code>userId</code> - ID текущего зарегистрированного или замещенного пользователя;</para>
            </listitem>
            <listitem>
              <para><code>userLogin</code> - логин текущего зарегистрированного или замещенного пользователя в нижнем регистре.</para>
            </listitem>
          </itemizedlist></para>
        <para>Атрибуты реплицируются в кластере Middleware так же как и  все остальные данные сессии.</para>
      </section>
      <section id="login">
        <title>Вход в систему</title>
        <para>Стандартный вариант входа пользователя: <itemizedlist>
            <listitem>
              <para>пользователь вводит свой логин и пароль</para>
            </listitem>
            <listitem>
              <para>клиентский блок приложения хэширует пароль, вызывая метод <code>getPlainHash()</code> бина <code>PasswordEncryption</code> и вызывает на <structname>Middleware</structname> метод <code>LoginService.login()</code>, передавая ему логин пользователя и хэш пароля</para>
            </listitem>
            <listitem>
              <para><code>LoginService</code> делегирует выполнение бину <code>LoginWorker</code>, который загружает объект <code>User</code> по полученному логину, хэширует полученный хэш пароля повторно, используя в качестве соли идентификатор пользователя, и сравнивает полученный хэш с сохраненным в БД хэшем пароля. В случае несовпадения выбрасывается исключение <code>LoginException</code>.</para>
            </listitem>
            <listitem>
              <para>После успешной аутентификации в созданный экземпляр <code>
                  <link linkend="userSession">UserSession</link>
                </code> загружаются все параметры доступа данного пользователя: список ролей, права, ограничения и атрибуты сессии.</para>
            </listitem>
          </itemizedlist></para>
        <para>Алгоритм хэширования паролей реализуется бином типа <code>EncryptionModule</code> и задается в свойстве приложения <property>
            <link linkend="cuba.passwordEncryptionModule">cuba.passwordEncryptionModule</link>
          </property>. По умолчанию - SHA-1.</para>
        <para>Возможен вариант, когда пароль пользователя (точнее, хэш пароля) не хранится в базе данных, а проверяется внешними средствами, например, путем интеграции с <application>ActiveDirectory</application>. В этом случае фактически аутентификацию выполняет клиентский блок, а <structname> Middleware</structname> &quot;доверяет&quot; клиенту, создавая сессию по одному только логину пользователя без пароля методом <code>LoginService.loginTrusted()</code>. Метод <code>loginTrusted()</code> требует выполнения следующих условия:<itemizedlist>
            <listitem>
              <para>клиентский блок должен передать так называемый доверенный пароль, задаваемый на <structname>Middleware</structname> и на клиентском блоке свойством приложения <property>
                  <link linkend="cuba.trustedClientPassword">cuba.trustedClientPassword</link>
                </property></para>
            </listitem>
            <listitem>
              <para>IP адрес клиентского блока должен соответствовать маске, задаваемой свойством приложения <property>
                  <link linkend="cuba.trustedClientPermittedIpMask">cuba.trustedClientPermittedIpMask</link>
                </property></para>
            </listitem>
          </itemizedlist></para>
        <para>Вход в систему требуется также для автоматических процессов, запускаемых по расписанию, а также при подключении к бинам <structname>Middleware</structname> через JMX-интерфейс. Строго говоря, такие действия считаются административными и не требуют аутентификации до тех пор, пока не выполняется каких-либо изменений сущностей в базе данных. При записи сущностей в БД требуется проставить логин пользователя, который выполнил изменения, поэтому для работы таких процессов должен быть указан пользователь, от лица которого выполняются изменения. </para>
        <para>Дополнительным плюсом входа в систему для автоматического процесса и для JMX-вызова является то, что вывод в журнал сообщений от логгеров сопровождается указанием логина текущего пользователя, если пользовательская сессия установлена в потоке выполнения. Это упрощает поиск сообщений от конкретного процесса при разборе журнала.</para>
        <para>Вход в систему для процессов внутри <structname>Middleware</structname> выполняется вызовом <code>LoginWorker.loginSystem()</code> с передачей логина пользователя (без пароля), от имени которого будет работать данный процесс. В результате создается объект <code>
            <link linkend="userSession">UserSession</link>
          </code>, который будет закэширован в данном блоке <structname>Middleware</structname> и не будет реплицироваться в кластере. </para>
        <para>Более подробно аутентификация процессов внутри Middleware рассмотрена в разделе <xref linkend="system_authentication"/></para>
      </section>
      <section id="securityContext">
        <title>SecurityContext</title>
        <para>Экземпляр класса <code>SecurityContext</code> хранит информацию о пользовательской сессии для текущего потока выполнения. Он создается и передается в метод <code>AppContext.setSecurityContext()</code> в следующие моменты:<itemizedlist>
            <listitem>
              <para>для блоков <structname>Web Client</structname>  и <structname>Web Portal</structname> - в начале обработки каждого HTTP-запроса от пользовательского браузера</para>
            </listitem>
            <listitem>
              <para>для блока <structname>Middleware</structname> - в начале обработки каждого запроса от клиентского уровня</para>
            </listitem>
            <listitem>
              <para>для блока <structname>Desktop Client</structname> - один раз после входа пользователя, так как десктопное приложение является однопользовательским</para>
            </listitem>
          </itemizedlist></para>
        <para>По окончании выполнения запроса в первых двух случаях  <code>SecurityContext</code> удаляется из потока выполнения.</para>
        <para>При создании прикладным кодом нового потока выполнения в него необходимо передать текущий экземпляр <code>SecurityContext</code>, например:<programlisting>final SecurityContext securityContext = AppContext.getSecurityContext();
executor.submit(new Runnable() {
    public void run() {
        AppContext.setSecurityContext(securityContext);
        // business logic here
    }
});</programlisting></para>
      </section>
    </section>
    <section>
      <title>Обработка исключений</title>
      <section>
        <title>Классы исключений</title>
        <para>При создании собственных классов исключений следует придерживаться следующих правил:<itemizedlist>
            <listitem>
              <para>Если исключение является нормальной частью бизнес-логики и при его возникновении требуется предпринимать некоторые нетривиальные действия, то класс исключения следует делать декларируемым (наследником <code>Exception</code>). Обработка таких исключений производится вызывающим кодом.</para>
            </listitem>
            <listitem>
              <para>Если исключение сигнализирует об  ошибочной ситуации, и реакцией на него должно быть прерывание хода выполнения и простое действие типа отображения информации об ошибке пользователю, то класс исключения следует делать недекларируемым (наследником <code>RuntimeException</code>). Обработка таких исключений производится специальными классами-обработчиками, зарегистрированными в клиентских блоках приложения.</para>
            </listitem>
            <listitem>
              <para>Если исключение выбрасывается и обрабатывается в рамках одного <link linkend="app_tiers">блока</link> приложения, то класс исключения следует объявлять в соответствующем <link linkend="app_modules">модуле</link>. Если же исключение выбрасывается на Middleware, а обрабатывается на клиентском уровне, то класс исключения необходимо объявлять в модуле <structname>global</structname>.</para>
            </listitem>
          </itemizedlist></para>
      </section>
      <section>
        <title>Передача исключений Middleware</title>
        <para>Если при выполнении запроса от клиента на Middleware возникает исключение, выполнение прерывается и на клиента возвращается объект исключения, как правило включающий цепочку порождающих друг друга исключений. Так как цепочка исключений может содержать классы, недоступные клиентскому блоку (например, исключения JDBC-драйвера), на клиента передается не сама эта цепочка, а ее представление внутри специального создаваемого исключения <code>RemoteException</code>. </para>
        <para>Информация об исключениях-причинах сохраняется в виде списка объектов <code>RemoteException.Cause</code>. Каждый объект <code>Cause</code> хранит обязательно имя класса исключения и его сообщение. Кроме того, если класс исключения &quot;поддерживается клиентом&quot;, то <code>Cause</code> содержит также и сам объект исключения. Это дает возможность передать на клиента информацию в полях исключения. </para>
        <para>Класс исключения, объекты которого нужно передавать на клиентский уровень именно в виде Java-объектов, нужно аннотировать <code>@SupportedByClient</code>, например: <programlisting>@SupportedByClient
public class WorkflowException extends RuntimeException {
...</programlisting></para>
        <para>Таким образом, при возникновении на Middleware исключения, не аннотированного <code>@SupportedByClient</code>, вызывающий клиентский код получит <code>RemoteException</code>, внутри которого будет находится исходное исключение  в виде строки. Если же исходное исключение аннотировано <code>@SupportedByClient</code>, то вызывающий код получит именно его. Это дает возможность в прикладном коде организовывать обработку декларируемых <link linkend="services">сервисами</link> Middleware исключений традиционным образом - с помощью блоков <code>try...catch</code>.</para>
        <para>Упаковку объектов исключений в <code>RemoteException</code> перед передачей на клиентский уровень выполняет перехватчик вызовов <link linkend="services">сервисов</link> - класс <code>ServiceInterceptor</code>. Кроме того, он же выполняет логгирование исключений. По умолчанию в журнал выводится вся информация об исключении, включая полный stacktrace. Если это нежелательно, можно добавить классу исключения аннотацию <code>@Logging</code>, указав в ней тип логгирования:<itemizedlist>
            <listitem>
              <para><code>FULL</code> - (по умолчанию) полная информация, включая stacktrace</para>
            </listitem>
            <listitem>
              <para><code>BRIEF</code> - только имя класса исключения и сообщение</para>
            </listitem>
            <listitem>
              <para><code>NONE</code> - не выводить ничего</para>
            </listitem>
          </itemizedlist></para>
        <para>Например:<programlisting>@SupportedByClient
@Logging(Logging.Type.BRIEF)
public class FinancialTransactionException extends Exception {
...</programlisting></para>
      </section>
      <section>
        <title>Обработчики исключений клиентского уровня</title>
        <para>Необработанные исключения в <link linkend="app_tiers">блоках</link> Web Client и Desktop Client, возникшие на клиентском уровне или переданные с Middleware, попадают в специальный механизм обработчиков. Этот механизм схож для обоих блоков, однако использует разные (хотя и в основном одноименные) классы реализации. </para>
        <para>Рассмотрим механизм на примере блока Web Client. </para>
        <para>В файле <filename>
            <link linkend="spring.xml">spring.xml</link>
          </filename> блока объявляется бин класса <code>ExceptionHandlersConfiguration</code>, в свойстве <code>handlerClasses</code> которого задается список имен классов обработчиков. Например: <programlisting>&lt;bean id=&quot;sales_exceptionHandlersConf&quot; class=&quot;com.haulmont.cuba.web.exception.ExceptionHandlersConfiguration&quot;&gt;
    &lt;property name=&quot;handlerClasses&quot;&gt;
        &lt;list&gt;
            &lt;value&gt;com.sample.sales.web.exception.ZeroBalanceExceptionHandler&lt;/value&gt;
            &lt;value&gt;com.sample.sales.web.exception.InvalidCustomerStateExceptionHandler&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;</programlisting></para>
        <para>Идентификатор бина должен быть уникальным и не совпадать ни с одним из бинов <link linkend="base_projects">базовых проектов</link>, так как базовые проекты в свою очередь могут содержать аналогичные конфигурационные бины с собственными идентификаторами. </para>
        <para>Обработчик должен реализовывать интерфейс <code>ExceptionHandler</code>, в методе <code>handle()</code> которого производить обработку и возвращать <code>true</code>, либо сразу возвращать <code>false</code>, если данный обработчик не может обработать переданное ему исключение. Такое поведение позволяет организовать &quot;цепочку ответственности&quot; обработчиков. </para>
        <para>Рекомендуется наследовать класс своего обработчика от базового класса <code>AbstractExceptionHandler</code>, который умеет разбирать цепочку исключений (с учетом упакованных внутри <code>RemoteException</code>) и реагировать на конкретные типы исключений. Типы исключений, для которых предназначен данный обработчик, указываются в массиве строк, передаваемом в конструкторе обработчика базовому конструктору. Каждая строка массива должна содержать одно полное имя класса обрабатываемого исключения, например:<programlisting>public class ReportExceptionHandler extends AbstractExceptionHandler {

    public ReportExceptionHandler() {
        super(ReportingException.class.getName(),
              FailedToConnectToOpenOfficeException.class.getName(),
              UnsupportedFormatException.class.getName());
    }
...</programlisting></para>
        <para>Если класс исключения недоступен на клиенте, следует указывать его имя строковым литералом:<programlisting>public class OptimisticExceptionHandler extends AbstractExceptionHandler {

    public OptimisticExceptionHandler() {
        super(&quot;org.springframework.orm.jpa.JpaOptimisticLockingFailureException&quot;);
    }
...</programlisting></para>
        <para>В случае использования в качестве базового класса <code>AbstractExceptionHandler</code> логика обработки располагается в методе <code>doHandle()</code>, и для блока Web Client может выглядеть следующим образом:<programlisting>@Override
protected void doHandle(App app, String className, String message, @Nullable Throwable throwable) {
    String msg = messages.getMainMessage(&quot;zeroBalance.message&quot;);
    app.getAppWindow().showNotification(msg, Window.Notification.TYPE_ERROR_MESSAGE);
}</programlisting></para>
      </section>
    </section>
  </section>
  <section id="middleware">
    <title>Компоненты среднего слоя</title>
    <para>На следующем рисунке приведены основные компоненты среднего слоя CUBA-приложения.</para>
    <figure>
      <title>Компоненты среднего слоя</title>
      <mediaobject>
        <imageobject>
          <imagedata contentwidth="80%" align="center" fileref="img/Middleware.png"/>
        </imageobject>
      </mediaobject>
    </figure>
    <para><link linkend="services">Services</link> – управляемые <glossterm linkend="container">контейнером</glossterm> компоненты, формирующие границу приложения и предоставляющие интерфейс клиентскому <link linkend="app_tiers">уровню</link> приложения. Сервисы могут содержать бизнес-логику сами, либо делегировать выполнение <link linkend="managed_beans">Managed Beans</link>.</para>
    <para><link linkend="managed_beans">Managed Beans</link> – управляемые <glossterm linkend="container">контейнером</glossterm> компоненты, содержащие бизнес-логику приложения. Вызываются <link linkend="services">сервисами</link>, другими бинами или через опциональный <glossterm linkend="jmx">JMX</glossterm> интерфейс.</para>
    <para><code>
        <link linkend="persistence">Persistence</link>
      </code> − инфраструктурный интерфейс для доступа к функциональности хранения данных: управлению <link linkend="transactions">транзакциями</link> и <link linkend="orm">ORM</link>. </para>
    <section id="services">
      <title>Сервисы</title>
      <para>Сервисы образуют слой  компонентов, определяющий множество операций <structname>Middleware</structname>, доступных клиентскому <link linkend="app_tiers">уровню</link> приложения. Внутри сервисов  инкапсулируется бизнес-логика и  управление <link linkend="transactions">транзакциями</link>.</para>
      <para>Основные задачи сервисов:</para>
      <itemizedlist>
        <listitem>
          <para>Предоставляют удаленный (remote) интерфейс для вызова с клиентского уровня</para>
        </listitem>
        <listitem>
          <para>Проверяют наличие активной <link linkend="userSession">пользовательской сессии</link>, соответствующей идентификатору сессии, переданному с клиента</para>
        </listitem>
        <listitem>
          <para>Записывают в журнал  необработанные исключения среднего слоя</para>
        </listitem>
      </itemizedlist>
      <para>Кроме того, именно в слое сервисов рекомендуется выполнять авторизацию текущего пользователя, т.е. проверять его права на ту или иную функциональность.</para>
      <para>Общие для всех сервисов задачи решаются следующим образом:<itemizedlist>
          <listitem>
            <para>Проверка наличия пользовательской сессии и логгирование исключений производится классом-<glossterm linkend="interceptor">интерцептором</glossterm> <code>ServiceInterceptor</code>, который перехватывает выполнение каждого метода сервиса с помощью <application>Spring AOP</application></para>
          </listitem>
          <listitem>
            <para>Удаленный интерфейс для доступа к сервису через <application>Spring HTTP Invoker</application> создается бином <code>RemoteServicesBeanCreator</code>, который конфигурируется в файле <filename>
                <link linkend="remoting-spring.xml">remoting-spring.xml</link>
              </filename> модуля <structname>core</structname>. </para>
          </listitem>
        </itemizedlist></para>
      <figure>
        <title>Диаграмма классов сервиса</title>
        <mediaobject>
          <imageobject>
            <imagedata contentwidth="80%" align="center" fileref="img/MiddlewareServices.png"/>
          </imageobject>
        </mediaobject>
      </figure>
      <section>
        <title>Создание сервиса</title>
        <para>Имена интерфейсов сервисов должны заканчиваться на <code>Service</code>, имена классов реализации на <code>ServiceBean</code>.</para>
        <para>При создании сервиса необходимо выполнить следующее:</para>
        <procedure>
          <step>
            <para>Создать интерфейс в <link linkend="app_modules">модуле</link> <structname>global</structname> (т.к. интерфейс сервиса должен быть доступен на всех <link linkend="app_tiers">уровнях</link>) и задать в нем имя сервиса. Имя рекомендуется задавать в формате <literal>{имя_проекта}_{имя_интерфейса}</literal>. Например:</para>
            <programlisting language="java">package com.sample.sales.core;

import com.sample.sales.entity.Order;

public interface OrderService {
    String NAME = &quot;sales_OrderService&quot;;

    void calculateTotals(Order order);
}</programlisting>
          </step>
          <step>
            <para>Создать класс сервиса в модуле <structname>core</structname> и добавить ему аннотацию <code>@org.springframework.stereotype.Service</code> с именем, заданным в интерфейсе</para>
            <programlisting>package com.sample.sales.core;

import com.sample.sales.entity.Order;
import org.springframework.stereotype.Service;

@Service(OrderService.NAME)
public class OrderServiceBean implements OrderService {
    @Override
    public void calculateTotals(Order order) {
    }
}</programlisting>
            <para>Класс сервиса, как и класс любого другого <link linkend="managed_beans">управляемого бина</link>, должен находиться внутри дерева пакетов с корнем, заданным в элементе <literal>context:component-scan</literal> файла <filename>
                <link linkend="spring.xml">spring.xml</link>
              </filename>. В нашем случае файл <filename>spring.xml</filename> содержит элемент:<programlisting>&lt;context:component-scan base-package=&quot;com.sample.sales&quot;/&gt;</programlisting>что означает, что поиск аннотированных бинов для данного блока приложения будет происходить начиная с пакета <code>com.sample.sales</code>.</para>
          </step>
        </procedure>
        <warning>
          <para>Сервисы предназначены только для вызова &quot;снаружи&quot; Middleware. Не рекомендуется вызывать методы сервисов из других компонентов среднего слоя. При обнаружении факта вызова сервиса из другого сервиса в журнал  выводится сообщение об ошибке.</para>
          <para>Если некоторую бизнес-логику требуется вызывать из разных сервисов либо других компонентов <structname>Middleware</structname>, ее необходимо выделить и инкапсулировать внутри соответствующего <link linkend="managed_beans">Managed Bean</link>.</para>
        </warning>
      </section>
      <section id="service_import">
        <title>Использование сервиса</title>
        <para>Для того чтобы вызывать сервис, в клиентском  блоке приложения для него должен быть создан соответствующий прокси-объект. Делается это путем объявления имени и интерфейса сервиса в параметрах фабрики прокси-объектов. Для блока <structname>Web Client</structname> это бин класса <code>WebRemoteProxyBeanCreator</code>, для <structname>Web Portal</structname> - <code>PortalRemoteProxyBeanCreator</code> , для <structname>Desktop Client</structname> - <code>RemoteProxyBeanCreator</code> .</para>
        <para>Фабрика прокси-объектов конфигурируется в файле <filename>
            <link linkend="spring.xml">spring.xml</link>
          </filename> ссответствующего клиентского блока.</para>
        <para>Например, чтобы в приложении <application>sales</application> вызвать с веб-клиента сервис <code>sales_OrderService</code>, необходимо добавить в файл <filename>web-spring.xml</filename> модуля <structname>web</structname> следующее:</para>
        <programlisting language="xml">&lt;bean id=&quot;sales_proxyCreator&quot; class=&quot;com.haulmont.cuba.web.sys.remoting.WebRemoteProxyBeanCreator&quot;&gt;
    &lt;property name=&quot;clusterInvocationSupport&quot; ref=&quot;cuba_clusterInvocationSupport&quot;/&gt;
    &lt;property name=&quot;remoteServices&quot;&gt;
        &lt;map&gt;
            &lt;entry key=&quot;sales_OrderService&quot; value=&quot;com.sample.sales.core.OrderService&quot;/&gt;
        &lt;/map&gt;
    &lt;/property&gt;
&lt;/bean&gt;</programlisting>
        <para>Все импортируемые сервисы объявляются в одном свойстве <code>remoteServices</code>  в элементах <literal>map/entry</literal>.</para>
        <para>С точки зрения прикладного кода прокси-объект сервиса на клиентском уровне является обычным бином <application>Spring</application> и может быть получен либо инжекцией, либо с помощью класса <code>AppBeans</code>, например:<programlisting>@Inject
protected OrderService orderService;
...
orderService.calculateTotals(order);</programlisting></para>
      </section>
    </section>
    <section id="managed_beans">
      <title>Управляемые бины</title>
      <para><firstterm>Управляемые бины (Managed Beans)</firstterm> − это программные компоненты, предназначенные для реализации бизнес-логики приложения. Термин &quot;управляемые&quot; в данном случае означает, что созданием экземпляров и установкой связей между такими компонентами управляет <glossterm linkend="container">контейнер</glossterm>, который является основной частью фреймворка <application>Sping</application>.</para>
      <warning>
        <para>Managed Bean представляет собой <firstterm>singleton</firstterm>, то есть в некотором блоке приложения существует только один экземпляр данного класса. Поэтому, если бин содержит изменяемые данные в полях (другими словами, имеет состояние), то обращение к таким данным необходимо синхронизировать.</para>
      </warning>
      <section>
        <title>Создание бина</title>
        <para>Для создания  управляемого бина достаточно добавить классу  Java аннотацию  <literal>@javax.annotation.ManagedBean</literal>. Например:<programlisting>package com.sample.sales.core;

import com.sample.sales.entity.Order;
import javax.annotation.ManagedBean;

@ManagedBean(OrderWorker.NAME)
public class OrderWorker {
    public static final String NAME = &quot;sales_OrderWorker&quot;;

    public void calculateTotals(Order order) {
    }
}</programlisting></para>
        <para>Рекомендуется присваивать бину уникальное имя вида <literal>{имя_проекта}_{имя_класса}</literal>, и определять его в константе <code>NAME</code>. </para>
        <para>Класс управляемого бина должен находиться внутри дерева пакетов с корнем, заданным в элементе <literal>context:component-scan</literal> файла <filename>
            <link linkend="spring.xml">spring.xml</link>
          </filename>. В нашем случае файл <filename>spring.xml</filename> содержит элемент:<programlisting>&lt;context:component-scan base-package=&quot;com.sample.sales&quot;/&gt;</programlisting>что означает, что поиск аннотированных бинов для данного блока приложения будет происходить начиная с пакета <code>com.sample.sales</code>.</para>
        <para>Если нужно обеспечить возможность подмены реализации,  рекомендуется  выделять бизнес-интерфейс бина, например следующим образом:</para>
        <programlisting>package com.sample.sales.core;

import com.sample.sales.entity.Order;

public interface OrderWorker {
    String NAME = &quot;sales_OrderWorker&quot;;

    void calculateTotals(Order order);
}</programlisting>
        <programlisting>package com.sample.sales.core;

import com.sample.sales.entity.Order;
import javax.annotation.ManagedBean;

@ManagedBean(OrderWorker.NAME)
public class OrderWorkerBean implements OrderWorker {
    @Override
    public void calculateTotals(Order order) {
    }
}</programlisting>
        <para>Управляемые бины можно создавать на любом <link linkend="app_tiers">уровне</link>, так как контейнер <application>Spring Framework</application> используется во всех стандартных блоках приложения.</para>
      </section>
      <section>
        <title>Использование бина</title>
        <para>Ссылку на бин можно получить с помощью инжекции или класса <code>AppBeans</code>. В качестве примера использования бина рассмотрим реализацию сервиса <code>OrderService</code>, делегирующего выполнение бину <code>OrderWorker</code>:<programlisting>package com.sample.sales.core;

import com.haulmont.cuba.core.Persistence;
import com.sample.sales.entity.Order;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import javax.inject.Inject;

@Service(OrderService.NAME)
public class OrderServiceBean implements OrderService {
    
    @Inject
    protected Persistence persistence;
    
    @Inject
    protected OrderWorker orderWorker;
    
    @Transactional
    @Override
    public BigDecimal calculateTotals(Order order) {
        Order entity = persistence.getEntityManager().merge(order);
        orderWorker.calculateTotals(entity);
    }
}</programlisting></para>
        <para>В данном примере сервис стартует <link linkend="transactions">транзакцию</link>, вносит полученный с клиентского уровня экземпляр сущности в <link linkend="entityManager">персистентный контекст</link>, и передает управление бину <code>OrderWorker</code>, который и содержит основную бизнес-логику. </para>
      </section>
    </section>
    <section id="jmx_beans">
      <title>JMX-бины</title>
      <para>Иногда требуется  предоставить администратору системы возможность просматривать и изменять  состояние некоторого <link linkend="managed_beans">управляемого бина</link> во время выполнения. В этом случае рекомендуется создать  JMX-бин - программный компонент, имеющий <glossterm linkend="jmx">JMX</glossterm>-интерфейс. Такой бин как правило делегирует вызовы управляемому бину, содержащему кэш, конфигурационные данные или статистику, к которым нужно обеспечить доступ через JMX.</para>
      <figure>
        <title/>
        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="img/JMXBeans.png"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>Как видно из диаграммы, JMX-бин состоит из интерфейса и класса реализации. Класс должен представлять собой <link linkend="managed_beans">управляемый бин</link>, то есть иметь аннотацию <code>@ManagedBean</code> и уникальное имя. Интерфейс JMX-бина специальным образом регистрируется в <link linkend="spring.xml">spring.xml</link> для создания в текущей JVM собственно JMX-интерфейса.</para>
      <para>Вызовы всех методов интерфейса JMX-бина перехватываются с помощью <application>Spring AOP</application> классом−<glossterm linkend="interceptor">интерцептором</glossterm> <methodname>MBeanInterceptor</methodname>, который обеспечивает установку правильного <code>ClassLoader</code> в контексте потока выполнения, и журналирование необработанных исключений.</para>
      <warning>
        <para>Интерфейс JMX-бина обязательно должен иметь имя вида <literal>{имя_класса}MBean</literal>.</para>
      </warning>
      <section>
        <title>Создание JMX-бина</title>
        <para>Рассмотрим процесс создания JMX-бина на примере.</para>
        <itemizedlist>
          <listitem>
            <para>Интерфейс JMX-бина:<programlisting>package com.sample.sales.core;

import org.springframework.jmx.export.annotation.*;

@ManagedResource(description = &quot;Performs operations on Orders&quot;)
public interface OrdersMBean {

    @ManagedOperation(description = &quot;Recalculates an order amount&quot;)
    @ManagedOperationParameters({@ManagedOperationParameter(name = &quot;orderId&quot;, description = &quot;&quot;)})
    String calculateTotals(String orderId);
}</programlisting></para>
            <para>Интерфейс и его методы могут содержать аннотации для задания описания JMX-бина и его операций. Это описание будет отображаться во всех инструментах, работающих с данным JMX-интерфейсом, тем самым помогая администратору системы.</para>
            <para>Так как инструменты JMX поддерживают ограниченный набор типов данных,  параметры и результат метода желательно задавать типа <code>String</code>, и при необходимости выполнять конвертацию внутри метода.</para>
          </listitem>
          <listitem>
            <para>Класс JMX-бина:<programlisting>package com.sample.sales.core;

import com.haulmont.cuba.core.*;
import com.haulmont.cuba.core.app.*;
import com.sample.sales.entity.Order;
import org.apache.commons.lang.exception.ExceptionUtils;
import javax.annotation.ManagedBean;
import javax.inject.Inject;
import java.util.UUID;

@ManagedBean(&quot;sales_OrdersMBean&quot;)
public class Orders implements OrdersMBean {

    @Inject
    protected OrderWorker orderWorker;

    @Inject
    protected Persistence persistence;

    @Authenticated
    @Override
    public String calculateTotals(final String orderId) {
        try {
            persistence.createTransaction().execute(new Transaction.Runnable() {
                @Override
                public void run(EntityManager em) {
                    Order entity = em.find(Order.class, UUID.fromString(orderId));
                    orderWorker.calculateTotals(entity);
                }
            });
            return &quot;Done&quot;;
        } catch (Throwable e) {
            return ExceptionUtils.getStackTrace(e);
        }
    }
}</programlisting></para>
            <para>Аннотация <code>@ManagedBean</code> определяет, что данный класс является управляемым бином с именем <literal>sales_OrdersMBean</literal>. Имя указано напрямую в аннотации, а не в константе, так как доступ к JMX-бину из кода Java не требуется.</para>
            <para>Рассмотрим реализацию метода <code>calculateTotals()</code>.<itemizedlist>
                <listitem>
                  <para>Метод имеет аннотацию <code>@Authenticated</code>, т.е. при входе в метод и при отсутствии в потоке выполнения <link linkend="userSession">пользовательской сессии</link> выполняется <link linkend="system_authentication">системная аутентификация</link>.</para>
                </listitem>
                <listitem>
                  <para>Тело метода обернуто в блок <code>try/catch</code>, так что метод в случае успешного выполнения возвращает строку &quot;Done&quot;, а в случае ошибки - stacktrace исключения в виде строки. </para>
                  <para>Следует иметь в виду, что в данном случае все исключения обрабатываются, а значит, не попадают в <code>MBeanInterceptor</code> и не выводятся в журнал автоматически. Поэтому при необходимости логгировать исключения здесь нужно добавить вызов логгера в секции <code>catch</code>.</para>
                </listitem>
                <listitem>
                  <para>Логика метода заключается в том, что он стартует транзакцию, загружает экземпляр сущности <code> Order</code> по  идентификатору, и передает управление бину <code>OrderWorker</code> для обработки.</para>
                </listitem>
              </itemizedlist></para>
          </listitem>
          <listitem>
            <para>Регистрация JMX-бина в <filename>spring.xml</filename>:</para>
            <programlisting>&lt;bean id=&quot;sales_MBeanExporter&quot; lazy-init=&quot;false&quot; 
      class=&quot;com.haulmont.cuba.jmxcontrol.export.MBeanExporter&quot;&gt;
    &lt;property name=&quot;beans&quot;&gt;
        &lt;map&gt;
            &lt;entry key=&quot;${cuba.webContextName}.sales:type=Orders&quot;
                   value-ref=&quot;sales_OrdersMBean&quot;/&gt;
        &lt;/map&gt;
    &lt;/property&gt;
&lt;/bean&gt;</programlisting>
          </listitem>
        </itemizedlist>
        <para>Все JMX-бины проекта объявляются в одном экземпляре <code>MBeanExporter</code>  в элементах <literal>map/entry</literal> свойства <code>beans</code>. Ключом элемента здесь является JMX ObjectName, значением - имя бина, заданное
в аннотации <code>@ManagedBean</code>. ObjectName начинается с имени веб-приложения, так как в одном экземпляре <application>Tomcat</application> (т.е. в одной JVM) может быть развернуто несколько веб-приложений, экспортирующих одинаковые JMX-интерфейсы.</para>
      </section>
      <section>
        <title>JMX-бины платформы</title>
        <para>В данном разделе описаны некоторые имеющиеся в платформе JMX-бины.</para>
        <section id="cachingFacadeMBean">
          <title>CachingFacadeMBean</title>
          <para><code>CachingFacadeMBean</code> предоставляет методы очистки различных кэшей в блоках <structname>Middleware</structname> и  <structname>Web Client</structname>.</para>
          <para>JMX ObjectName: <literal>app-core.cuba:type=CachingFacade</literal> и <literal>app.cuba:type=CachingFacade</literal></para>
        </section>
        <section id="configStorageMBean">
          <title>ConfigStorageMBean</title>
          <para><code>ConfigStorageMBean</code> позволяет просматривать и задавать значения <link linkend="app_properties">свойствам приложения</link> в блоках <structname>Middleware</structname>, <structname>Web Client</structname> и <structname>Web Portal</structname>.</para>
          <para>Данный интерфейс имеет отдельные наборы методов для работы  с параметрами конфигурации и развертывания (<code>*AppProperties</code>) и с параметрами времени выполнения (<code>*DbProperties</code>), что обусловлено различием механизмов хранения этих категорий свойств.</para>
          <warning>
            <para>Существуют следующие ограничения в использовании интерфейса <code>ConfigStorageMBean</code>:<itemizedlist>
                <listitem>
                  <para>Отображаются только явно установленные в месте хранения свойства. Если значение свойства не задано, то в случае обращения к нему из кода программы через <link linkend="config_interfaces">конфигурационный интерфейс</link>, возвращается значение по умолчанию. Однако через <code>ConfigStorageMBean</code> значение по умолчанию не может быть получено. </para>
                </listitem>
                <listitem>
                  <para>Измененные значения для свойств, хранящихся в файлах, не сохраняются, и действуют только до рестарта данного блока.</para>
                </listitem>
              </itemizedlist></para>
          </warning>
          <para>JMX ObjectName: <literal>app-core.cuba:type=ConfigStorage</literal>, <literal>app.cuba:type=ConfigStorage</literal>, <literal>app-portal.cuba:type=ConfigStorage</literal></para>
        </section>
        <section>
          <title>EmailerMBean</title>
          <para><code>EmailerMBean</code> позволяет просмотреть текущие значения параметров <link linkend="email_sending">отсылки email</link>, а также отправить тестовое сообщение.</para>
          <para>JMX ObjectName: <literal>app-core.cuba:type=Emailer</literal></para>
        </section>
        <section id="persistenceManagerMBean">
          <title>PersistenceManagerMBean</title>
          <para><code>PersistenceManagerMBean</code> предоставляет следующие возможности:<itemizedlist>
              <listitem>
                <para>управление механизмом <link linkend="entity_statistics">статистики сущностей</link></para>
              </listitem>
              <listitem>
                <para>отображение новых скриптов обновления БД методом <code>findUpdateDatabaseScripts()</code> и запуск обновления методом <code>updateDatabase()</code></para>
              </listitem>
              <listitem>
                <para>запуск произвольных JPQL запросов в контексте <structname>Middleware</structname> методами <code>jpqlLoadList()</code>, <code>jpqlExecuteUpdate()</code></para>
              </listitem>
            </itemizedlist></para>
          <para>JMX ObjectName: <literal>app-core.cuba:type=PersistenceManager</literal></para>
        </section>
        <section id="scriptingManagerMBean">
          <title>ScriptingManagerMBean</title>
          <para><code>ScriptingManagerMBean</code> является JMX-фасадом для интерфейса инфраструктуры <code>
              <link linkend="scripting">Scripting</link>
            </code>.</para>
          <para>JMX ObjectName: <literal>app-core.cuba:type=ScriptingManager</literal></para>
          <para>JMX атрибуты:<itemizedlist>
              <listitem>
                <para><code>RootPath</code> - абсолютный путь к <link linkend="conf_dir">конфигурационному каталогу</link> <link linkend="app_tiers">блока приложения</link>, в котором запущен данный бин</para>
              </listitem>
            </itemizedlist></para>
          <para>JMX операции:<itemizedlist>
              <listitem>
                <para><code>runGroovyScript()</code> - выполнить скрипт Groovy в контексте <structname>Middleware</structname> и вернуть результат. Для отображения в JMX-интерфейсе результат должен быть типа <code>String</code>. В остальном аналогичен методу <code>Scripting.<link linkend="scripting.runGroovyScript">runGroovyScript()</link></code>. </para>
              </listitem>
            </itemizedlist></para>
        </section>
        <section id="serverInfoMBean">
          <title>ServerInfoMBean</title>
          <para><code>ServerInfoMBean</code> предоставляет общую информацию о данном блоке Middleware: номер и дату сборки, <link linkend="serverId">идентификатор сервера</link>.</para>
          <para>JMX ObjectName: <literal>app-core.cuba:type=ServerInfo</literal></para>
        </section>
      </section>
    </section>
    <section id="system_authentication">
      <title>Системная аутентификация</title>
      <para>При выполнении пользовательских запросов программному коду <structname>Middleware</structname>  через интерфейс <code>
          <link linkend="userSessionSource">UserSessionSource</link>
        </code> всегда доступна информация о текущем пользователе. Это возможно потому, что при получении запроса с клиентского уровня в потоке выполнения автоматически устанавливается соответствующий объект <code>
          <link linkend="securityContext">SecurityContext</link>
        </code>.</para>
      <para>Однако существуют ситуации, когда текущий поток выполнения  не связан ни с каким пользователем системы: например, при вызове метода бина из <link linkend="scheduled_tasks_spring">планировщика</link>, либо через JMX-интерфейс. Если при этом бин выполняет изменение сущностей в базе данных, то ему потребуется информация о том, кто выполняет изменения, то есть аутентификация.</para>
      <para>Такого рода аутентификация называется системной, так как не требует участия пользователя - средний слой приложения просто создает (или использует имеющуюся) пользовательскую сессию, и устанавливает в потоке выполнения соответствующий объект <code>SecurityContext</code>. </para>
      <para>Обеспечить системную аутентификацию некоторого участка кода можно следующими способами:<itemizedlist>
          <listitem>
            <para>явно используя бин <code>com.haulmont.cuba.security.app.Authentication</code>, например:<programlisting>@Inject
protected Authentication authentication;
...
authentication.begin();
try {
    // authenticated code
} finally {
    authentication.end();
}</programlisting></para>
          </listitem>
          <listitem>
            <para>добавив методу бина аннотацию <code>@Authenticated</code>, например:<programlisting>@Authenticated
public String foo(String value) {
    // authenticated code
}</programlisting></para>
          </listitem>
        </itemizedlist></para>
      <para>Во втором случае также используется бин <code>Authentication</code>, но неявно, через интерцептор <code>AuthenticationInterceptor</code>, который перехватывает вызовы всех методов бинов с аннотацией <code>@Authenticated</code>.</para>
      <para>В приведенных примерах пользовательская сессия будет создаваться от лица пользователя, логин которого указан в свойстве приложения <property>
          <link linkend="cuba.jmxUserLogin">cuba.jmxUserLogin</link>
        </property>. Если требуется аутентификация от имени другого пользователя, нужно воспользоваться первым вариантом и передать в метод <code>begin()</code> логин нужного пользователя.</para>
      <warning>
        <para>Если в момент выполнения <code>Authentication.begin()</code> в текущем потоке выполнения присутствует активная пользовательская сессия, то она не заменяется - соответственно, код, требующий аутентификации, будет выполняться с имеющейся сессией, и последующий метод <code>end()</code> не будет очищать поток.</para>
        <para>Например,  вызов метода JMX-бина из встроенной в <structname>Web Client</structname> консоли JMX, если бин находится в той же JVM, что и блок WebClient, к которому в данный момент подключен пользователь, будет выполнен от имени текущего зарегистрированного в системе пользователя, независимо от наличия системной аутентификации.</para>
      </warning>
    </section>
    <section id="orm">
      <title>Слой ORM</title>
      <section>
        <title>Общие сведения</title>
        <para>Object-Relational Mapping - объектно-реляционное отображение - технология связывания таблиц реляционной базы данных с объектами языка программирования. </para>
        <variablelist>
          <varlistentry>
            <term>Преимущества использования ORM:</term>
            <listitem>
              <itemizedlist>
                <listitem>
                  <para>Позволяет работать с  данными реляционной СУБД, манипулируя объектами Java</para>
                </listitem>
                <listitem>
                  <para>Упрощает программирование, избавляя от рутины написания тривиальных SQL-запросов</para>
                </listitem>
                <listitem>
                  <para>Упрощает программирование, позволяя извлекать и сохранять целые графы объектов одной командой</para>
                </listitem>
                <listitem>
                  <para>Обеспечивает легкое портирование приложения на различные СУБД</para>
                </listitem>
                <listitem>
                  <para>Использует лаконичный язык запросов <glossterm linkend="jpql">JPQL</glossterm></para>
                </listitem>
                <listitem>
                  <para>Оптимизирует количество выполняемых SQL-запросов на команды insert и update</para>
                </listitem>
              </itemizedlist>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Недостатки:</term>
            <listitem>
              <itemizedlist>
                <listitem>
                  <para>Требует понимания особенностей работы с ORM</para>
                </listitem>
                <listitem>
                  <para>Не позволяет напрямую оптимизировать SQL или использовать особенности применяемой СУБД</para>
                </listitem>
              </itemizedlist>
            </listitem>
          </varlistentry>
        </variablelist>
        <para>В платформе <productname>CUBA</productname> используется реализация ORM по стандарту Java Persistence API на основе фреймворка <application>Apache OpenJPA</application>.</para>
      </section>
      <section id="entityManager">
        <title>EntityManager</title>
        <para><code>EntityManager</code> - основной интерфейс ORM, служит для управления персистентными <link linkend="data_model">сущностями</link>.
</para>
        <para>Ссылку на <code>EntityManager</code>  можно получить через интерфейс <code>Persistence</code>,  вызовом метода  <code>getEntityManager()</code>.
Полученный экземпляр <code>EntityManager</code> привязан к текущей <link linkend="transactions">транзакции</link>, то есть все вызовы <code>getEntityManager()</code> в рамках одной транзакции возвращают один и тот же экземпляр <code>EntityManager</code>. После завершения транзакции обращения к данному экземпляру невозможны.
</para>
        <para>Экземпляр <code>EntityManager</code> содержит в себе &quot;персистентный контекст&quot; – набор экземпляров сущностей, загруженных из БД или только что созданных. Персистентный контекст является своего рода кэшем данных в рамках  транзакции.
<code>EntityManager</code> автоматически сбрасывает в БД все изменения, сделанные в его персистентном контексте, в момент коммита транзакции, либо при явном вызове метода  <code>flush()</code>.</para>
        <para>Интерфейс <code>EntityManager</code>, используемый в CUBA-приложениях, в основном повторяет стандартный <ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/EntityManager.html">javax.persistence.EntityManager</ulink>. Рассмотрим специфичные методы:<itemizedlist>
            <listitem>
              <para><code>setView()</code> - устанавливает <link linkend="views">представление</link>, с которым будет производиться последующая загрузка сущностей методом <code>find()</code> либо JPQL запросами. В результате <glossterm linkend="eager_fetching">энергично загружены</glossterm> будут все не-<literal>lazy</literal> атрибуты представления.</para>
              <para>Если в данный метод передать <code>null</code>, либо не вызывать его вообще, загрузка будет производиться в соответствие с правилами <link linkend="entity_annotations">аннотаций сущностей</link>.</para>
            </listitem>
            <listitem>
              <para><code>addView()</code> - аналогичен методу <code>setView()</code>, но в случае наличия уже установленного в <code>EntityManager</code> представления, не заменяет его, а добавляет атрибуты переданного представления.</para>
            </listitem>
            <listitem>
              <para><code>fetch()</code> - обеспечивает для экземпляра сущности загрузку всех атрибутов указанного <link linkend="views">представления</link>, включая <literal>lazy</literal> атрибуты. Экземпляр сущности должен быть в <link linkend="entity_states">Managed</link> состоянии.</para>
              <para>Данный метод рекомендуется вызывать перед коммитом транзакции, если представление содержит <literal>lazy</literal> атрибуты, а экземпляр сущности нужно отправить на клиентский уровень. В этом случае только после вызова <code>fetch()</code> можно быть уверенным, что все нужные клиентсткому коду атрибуты действительно загружены.</para>
            </listitem>
            <listitem>
              <para><code>isSoftDeletion()</code> - проверяет, находится ли данный <code>EntityManager</code> в режиме <link linkend="soft_deletion">мягкого удаления</link>.</para>
            </listitem>
            <listitem>
              <para><code>setSoftDeletion()</code> - устанавливает режим <link linkend="soft_deletion">мягкого удаления</link> для данного экземпляра <code>EntityManager</code>.</para>
            </listitem>
            <listitem>
              <para><code>getConnection()</code> - возвращает  <code>java.sql.Connection</code>, через который выполняет запросы данный экземпляр <code>EntityManager</code>, и, соответственно, текущая транзакция. Закрывать такое соединение не нужно, оно будет закрыто при завершении транзакции.</para>
            </listitem>
            <listitem>
              <para><code>getDelegate()</code> - возвращает <code>javax.persistence.EntityManager</code>, предоставляемый реализацией ORM. </para>
            </listitem>
          </itemizedlist></para>
      </section>
      <section id="entity_states">
        <title>Состояния сущности</title>
        <para><variablelist>
            <varlistentry>
              <term>New</term>
              <listitem>
                <para>Только что созданный в памяти экземпляр, например: <code>Car car = new Car()</code></para>
                <para>Новый экземпляр может быть передан в <methodname>EntityManager.persist()</methodname> для сохранения в БД, при этом он переходит в состояние Managed.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>Managed</term>
              <listitem>
                <para>Загруженный из БД или новый, переданный в <methodname>EntityManager.persist()</methodname>, экземпляр. Принадлежит некоторому экземпляру <code>EntityManager</code>, другими словами, находится в его персистентном контексте.</para>
                <para>Любые изменения  экземпляра в состоянии Managed будут сохранены в БД в случае коммита транзакции, к которой принадлежит данный <code>EntityManager</code></para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>Detached</term>
              <listitem>
                <para>Экземпляр, загруженный из БД и отсоединенный от своего персистентного контекста (вследствие закрытия транзакции или сериализации).</para>
                <para>Изменения, вносимые в Detached экземпляр, запоминаются в самом этом экземпляре (в полях, добавленных с помощью bytecode enhancement).
Эти изменения будут сохранены в БД, только если данный экземпляр будет снова переведен в состояние Managed путем передачи в метод <methodname>EntityManager.merge()</methodname>. </para>
                <para>Метод <methodname>merge()</methodname> выполняет следующее: загружает из БД экземпляр с тем же идентификатором, переносит в него состояние переданного Detached экземпляра и возвращает загруженный Managed экземпляр. Далее надо работать именно с возвращенным Managed экземпляром.</para>
              </listitem>
            </varlistentry>
          </variablelist></para>
      </section>
      <section id="lazy_loading">
        <title>Загрузка по требованию</title>
        <para>Загрузка по требованию (lazy loading) позволяет загружать связанные сущности отложенно, т.е. только в момент первого обращения к их свойствам.</para>
        <para>Загрузка по требованию  в сумме порождает больше запросов к БД, чем <glossterm linkend="eager_fetching">энергичная загрузка (eager fetching)</glossterm>, однако нагрузка при этом растянута во времени.<itemizedlist>
            <listitem>
              <para>Например, при извлечении списка N экземпляров сущности A, содержащих ссылку на экземпляр сущности B, в случае загрузки по требованию будет выполнено N+1 запросов к базе данных.</para>
            </listitem>
            <listitem>
              <para>Для минимизации времени отклика и снижения нагрузки необходимо стремиться к меньшему количеству обращений к БД. Для этого  в платформе  используется механизм <link linkend="views">представлений</link>, с помощью которого в вышеописанном случае ORM может сформировать один  запрос к БД с объединением таблиц.</para>
            </listitem>
            <listitem>
              <para>Если A содержит коллекцию B, в случае энергичной загрузки  ORM сформирует SQL запрос, возвращающий произведение строк A и B. </para>
            </listitem>
            <listitem>
              <para>Иногда загрузка по требованию с точки зрения производительности предпочтительнее, чем энергичная загрузка. Например, когда работает асинхронный процесс, выполняющий некоторую бизнес-логику, общее время выполнения некритично и желательно распределить во времени  нагрузку на БД.</para>
            </listitem>
          </itemizedlist></para>
        <para>Загрузка по требованию работает только для экземпляра в состоянии <link linkend="entity_states">Managed</link>, то есть внутри транзакции, загрузившей данный экземпляр.</para>
      </section>
      <section id="query">
        <title>Выполнение JPQL запросов</title>
        <para>Для выполнения <link linkend="jpql">JPQL</link> запросов предназначен интерфейс <code>Query</code>, ссылку на который который можно получить у текущего экземпляра <code>EntityManager</code> вызовом метода <code>createQuery()</code>. Если запрос предполагается использовать для извлечения сущностей, рекомендуется вызывать <code>createQuery()</code> с передачей типа результата, что приведет к созданию <code>TypedQuery</code>. </para>
        <para>Методы <code>Query</code> в основном соответствуют методам стандартного интерфейса <ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/Query.html">
            <code>javax.persistence.Query</code>
          </ulink>. Рассмотрим отличия.<itemizedlist>
            <listitem>
              <para><code>setParameter()</code> - устанавливает значение параметра запроса. При передаче в данный метод экземпляра сущности выполняет неявное преобразование экземпляра в его идентификатор. Например:<programlisting>Customer customer = ...;
TypedQuery&lt;Order&gt; query = entityManager.createQuery(
    &quot;select o from sales$Order o where o.customer.id = ?1&quot;, Order.class);
query.setParameter(1, customer);</programlisting></para>
              <para>Обратите внимание на сравнение в запросе по идентификатору, но передачу в качестве параметра самого экземпляра сущности. </para>
              <para>Вариант метода с передачей <code>implicitConversions = false</code> не выполняет такого преобразования.</para>
            </listitem>
            <listitem>
              <para><code>setView()</code>, <code>addView()</code> - аналогичны одноименным методам интерфейса <code>EntityManager</code> - устанавливают <link linkend="views">представление</link>, используемое при загрузке данных текущим запросом, не влияя на представление всего <code>EntityManager</code>.</para>
            </listitem>
            <listitem>
              <para><code>getDelegate()</code> - возвращает экземпляр <code>javax.persistence.Query</code>, предоставляемый реализацией ORM.</para>
            </listitem>
          </itemizedlist></para>
        <para>При выполнении запроса через <code>Query</code> изменения в текущем персистентном контексте не учитываются, т.е. запрос просто выполняется в БД. Если результатом выборки являются экземпляры, уже находящиеся в персистентном контексте, то в результате запроса окажутся именно они, а не прочитанные из БД. Ситуацию поясняет следующий фрагмент теста:<programlisting>TypedQuery&lt;User&gt; query;
List&lt;User&gt; list;

query = em.createQuery(&quot;select u from sec$User u where u.name = ?1&quot;, User.class);
query.setParameter(1, &quot;testUser&quot;);
list = query.getResultList();
assertEquals(1, list.size());
User user = list.get(0);

user.setName(&quot;newName&quot;);

query = em.createQuery(&quot;select u from sec$User u where u.name = ?1&quot;, User.class);
query.setParameter(1, &quot;testUser&quot;);
list = query.getResultList();
assertEquals(1, list.size());
User user1 = list.get(0);

assertTrue(user1 == user);</programlisting></para>
        <para>Такое поведение определяется параметром <code>openjpa.IgnoreChanges=true</code>, заданным в файле <link linkend="persistence.xml">
            <filename>persistence.xml</filename>
          </link> базового проекта <structname>cuba</structname>. В прикладном проекте данный параметр можно изменить, указав его в собственном <filename>persistence.xml</filename>.</para>
        <para>Запросы, модифицирующие данные (<code>update</code>, <code>delete</code>) приводят к сбросу (flush) в базу данных текущего песрсистентного контекста перед выполнением. Другими словами, ORM сначала синхронизирует состояние сущностей в персистентном контексте и в БД, а уже потом выполняет модифицирующий запрос. Рекомендуется выполнять такие запросы в неизмененном персистентном контексте, чтобы исключить неявные действия ORM, которые могут отрицательно сказаться на производительности.</para>
        <section>
          <title>Поиск подстроки без учета регистра</title>
          <para>Для удобного формирования условия поиска без учета регистра символов и по любой части строки можно использовать префикс <literal>(?i)</literal> имени параметра запроса, например:<programlisting>select c from sales$Customer c where c.name like :(?i)name</programlisting></para>
          <para>В данном случае ORM переведет значение параметра <literal>name</literal> в нижний регистр и обрамит символами <literal>%</literal>, а затем в БД выполнит SQL с условием вида <literal> lower(C.NAME) like ?</literal></para>
          <para>Следует иметь в виду, что при таком поиске индекс, созданный в БД по полю <code>NAME</code>, не используется.</para>
        </section>
        <section>
          <title>Макросы в JPQL</title>
          <para>Текст JPQL запроса может включать макросы, которые обрабатываются перед выполнением и превращаются в исполняемый JPQL, дополнительно модифицируя набор параметров.</para>
          <para>Макросы, определенные в платформе, решают следующие задачи:<itemizedlist>
              <listitem>
                <para>Позволяют обойти принципиальную невозможность средствами JPQL выразить условие зависимости значения поля от текущего момента времени (не работает арифметика типа current_date-1)</para>
              </listitem>
              <listitem>
                <para>Позволяют сравнивать с датой поля типа Timestamp (содержащие дату+время)</para>
              </listitem>
            </itemizedlist></para>
          <para>Рассмотрим их подробно:<variablelist>
              <varlistentry>
                <term>@between</term>
                <listitem>
                  <para>Имеет вид <literal>@between(field_name, moment1, moment2, time_unit)</literal>, где <itemizedlist>
                      <listitem>
                        <para><literal>field_name</literal> - имя атрибута для сравнения </para>
                      </listitem>
                      <listitem>
                        <para><literal>moment1</literal>, <literal>moment2</literal> - моменты времени, в которые должно попасть значение атрибута <literal>field_name</literal>. Каждый из моментов должен быть определен выражением с участием переменной <literal>now</literal>, к которой может быть прибавлено или отнято целое число </para>
                      </listitem>
                      <listitem>
                        <para><literal>time_unit</literal> - определяет единицу измерения времени, которое прибавляется или вычитается из <literal>now</literal> в выражениях моментов, а также точность округления моментов. Может быть следующим: <literal>year</literal>, <literal>month</literal>, <literal>day</literal>, <literal>hour</literal>, <literal>minute</literal>, <literal>second</literal>. При включенном <link linkend="base_projects">базовом проекте</link> <structname>workflow</structname> можно также использовать единицы рабочего времени: <literal>workday</literal>, <literal>workhour</literal>, workminute. </para>
                      </listitem>
                    </itemizedlist></para>
                  <para>Макрос преобразуется в следующее выражение JPQL: <literal>field_name &gt;= :moment1 and field_name &lt; :moment2</literal></para>
                  <para>Пример 1. Покупатель создан сегодня:<programlisting>select c from sales$Customer where @between(c.createTs, now, now+1, day)</programlisting></para>
                  <para>Пример 2. Покупатель создан в течение последних 10 минут:<programlisting>select c from sales$Customer where @between(c.createTs, now-10, now, minute)</programlisting></para>
                  <para>Пример 3. Документы, датированные последними 5 рабочими днями (для проектов, включающих <structname>workflow</structname>): <programlisting>select d from sales$Doc where @between(d.createTs, now-5, now, workday)</programlisting></para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>@today</term>
                <listitem>
                  <para>Имеет вид <literal>@today(field_name)</literal> и обеспечивает формирование условия попадания значения атрибута в текущий день. По сути это частный случай макроса <literal>@between</literal>.</para>
                  <para>Пример.

Пользователь создан сегодня: <programlisting>select d from sales$Doc where @today(d.createTs)</programlisting></para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>@dateEquals</term>
                <listitem>
                  <para>Имеет вид <literal>@dateEquals(field_name, parameter)</literal> и позволяет сформировать условие попадания значения поля <literal>field_name</literal> типа <code>Timestamp</code> в дату, задаваемую параметром <literal>parameter</literal>.</para>
                  <para>Пример:<programlisting>select d from sales$Doc where @dateEquals(d.createTs, :param)</programlisting></para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>@dateBefore</term>
                <listitem>
                  <para>Имеет вид <literal>@dateBefore(field_name, parameter</literal>) и позволяет сформировать условие, что дата значения поля <literal>field_name</literal> типа <code>Timestamp</code> меньше даты, задаваемой параметром <literal>parameter</literal>.</para>
                  <para>Пример:<programlisting>select d from sales$Doc where @dateBefore(d.createTs, :param)</programlisting></para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>@dateAfter</term>
                <listitem>
                  <para>Имеет вид <literal>@dateAfter(field_name, parameter</literal>) и позволяет сформировать условие, что дата значения поля <literal>field_name</literal> типа <code>Timestamp</code>  больше или равна дате, задаваемой параметром <literal>parameter</literal>.</para>
                  <para>Пример:<programlisting>select d from sales$Doc where @dateAfter(d.createTs, :param)</programlisting></para>
                </listitem>
              </varlistentry>
            </variablelist></para>
          <para>Список макросов может быть расширен в прикладном проекте. Для создания нового макроса необходимо определить бин, реализующий интерфейс <code>QueryMacroHandler</code>, и задать ему <code>@Scope(&quot;prototype&quot;)</code>. Механизм выполнения JPQL  запросов создает все доступные бины типа <code>QueryMacroHandler</code>, и по очереди передает им текст запроса с набором параметров. Очередность вызова обработчиков не определена.</para>
        </section>
      </section>
      <section id="nativeQuery">
        <title>Выполнение SQL запросов</title>
        <para>ORM позволяет выполнять SQL запросы к базе данных, возвращая как списки отдельных полей, так и экземпляры сущностей. Для этого необходимо создать объект <code>Query</code> или <code>TypedQuery</code> вызовом одного из методов <code>EntityManager.createNativeQuery()</code>. </para>
        <para>Если  выполняется выборка отдельных колонок таблицы, то результирующий список будет содержать строки в виде <code>Object[]</code>. Например:<programlisting>Query query = em.createNativeQuery(&quot;select ID, NAME from SALES_CUSTOMER where NAME like ?1&quot;);
query.setParameter(1, &quot;%Company%&quot;);
List list = query.getResultList();
for (Iterator it = list.iterator(); it.hasNext(); ) {
    Object[] row = (Object[]) it.next();
    UUID id = UUID.fromString((String) row[0]);
    String name = (String) row[1];
}</programlisting></para>
        <para>Следует иметь в виду, что значения колонок типа <code>UUID</code> возвращаются в виде <code>String</code>, а параметры этого типа также должны задаваться своим строковым представлением.</para>
        <para>Если вместе с текстом запроса передан класс результирующей сущности, то возвращается <code>TypedQuery</code> и после выполнения производится попытка отображения результатов запроса на атрибуты сущности. Например:<programlisting>TypedQuery&lt;Customer&gt; query = em.createNativeQuery(
    &quot;select * from SALES_CUSTOMER where NAME like ?1&quot;, 
    Customer.class);
query.setParameter(1, &quot;%Company%&quot;);
List&lt;Customer&gt; list = query.getResultList();</programlisting></para>
        <para>Поведение SQL запросов, возвращающих сущности, и модифицирующих запросов (<code>update</code>, <code>delete</code>), по отношению к текущему персистентному контексту аналогично описанному для <link linkend="query">JPQL запросов</link>.</para>
      </section>
    </section>
    <section id="transactions">
      <title>Управление транзакциями</title>
      <section>
        <title>Программное управление транзакциями</title>
        <para>Программное управление транзакциями осуществляется с помощью интерфейса <code>com.haulmont.cuba.core.Transaction</code>, ссылку на который можно получить методами <code>createTransaction()</code> или <code>getTransaction()</code> интерфейса инфраструктуры <code>
            <link linkend="persistence">Persistence</link>
          </code>.</para>
        <para>Метод <code>createTransaction()</code> создает новую транзакцию и возвращает интерфейс <code>Transaction</code>. Последующие вызовы методов <code>commit()</code>, <code>commitRetaining()</code>, <code>end()</code> этого интерфейса управляют созданной транзакцией. Если в момент создания существовала другая транзакция, то она будет приостановлена, и возобновлена после завершения созданной. </para>
        <para>Метод <code>getTransaction()</code> вызывает либо создание новой, либо присоединение к текущей транзакции. Если в момент вызова существовала активная транзакция, то метод успешно завершается, и последующие вызовы <code>commit()</code>, <code>commitRetaining()</code>, <code>end()</code> не оказывают никакого влияния на существующую транзакцию. Однако если <code>end()</code> вызван без предварительного вызова <code>commit()</code>, то текущая транзакция помечается как <code>RollbackOnly</code>.</para>
        <para>Пример ручного управления транзакцией:<programlisting>@Inject
private Persistence persistence;
...
Transaction tx = persistence.createTransaction();
try {
    EntityManager em = persistence.getEntityManager();
    Customer customer = new Customer();
    customer.setName(&quot;John Smith&quot;);
    em.persist(customer);

    tx.commit();
} finally {
    tx.end();
}</programlisting></para>
        <para>Интерфейс Transaction имеет также метод execute(), принимающий на вход класс-действие, которое нужно выполнить в данной транзакции. Это позволяет организовать управление транзакциями в функциональном стиле, например:<programlisting>persistence.createTransaction().execute(new Transaction.Runnable() {
    public void run(EntityManager em) {
        // transactional code here
    }
});</programlisting></para>
        <para>Если транзакционный блок должен вернуть результат, класс-действие должен реализовывать интерфейс <code>Transaction.Callable</code>. Если результат не требуется, как в приведенном примере, то класс-действие удобно наследовать от абстрактного класса <code>Transaction.Runnable</code>.</para>
        <para>Следует иметь в виду, что метод <code>execute()</code> у некоторого экземпляра <code>Transaction</code> можно вызвать только один раз, так как после выполнения кода класса-действия транзакция завершается.</para>
      </section>
      <section>
        <title>Декларативное управление транзакциями</title>
        <para>Любой метод <link linkend="managed_beans">управляемого бина</link> <structname>Middleware</structname> можно пометить аннотацией <code>@org.springframework.transaction.annotation.Transactional</code>, что вызовет автоматическое создание транзакции при вызове этого метода. В таком методе не нужно вызывать <code>Persistence.createTransaction()</code>, а можно сразу получать <code>EntityManager</code> и работать с ним.</para>
        <para>Для аннотации <code>@Transactional</code> можно указать параметры. Основным параметром является режим создания транзакции - <code>Propagation</code>. Значение <code>REQUIRED</code> соответствует <code>getTransaction()</code>, значение <code>REQUIRES_NEW</code> - <code>createTransaction()</code>. По умолчанию <code>REQUIRED</code>.
</para>
        <para>Декларативное управление транзакциями позволяет уменьшить количество <ulink url="http://en.wikipedia.org/wiki/Boilerplate_code">boilerplate кода</ulink>, однако имеет следующий недостаток: коммит транзакции проиходит вне прикладного кода, что часто затрудняет отладку, т.к. скрывается момент отправки изменений в БД и перехода сущностей в состояние <link linkend="entity_states">Detached</link>. Кроме того, следует иметь в виду, что декларативная разметка сработает только в случае вызова метода контейнером, т.е. вызов транзакционного метода из другого метода того же самого объекта не приведет к старту транзакции.
</para>
        <para>В связи с этим рекомендуется применять декларативное управление транзакциями только для простых случаев типа метода <link linkend="services">сервиса</link>, читающего некоторый объект и возвращающего его на клиента. </para>
      </section>
      <section>
        <title>Примеры взаимодействия транзакций</title>
        <section>
          <title>Откат вложенной транзакции</title>
          <para>Если вложенная транзакция создана через <code>getTransaction()</code>, то ее откат приведет к невозможности коммита охватывающей транзакции. Например:<programlisting>void methodA() {
    Transaction tx = persistence.createTransaction();
    try {
        // (1) вызываем метод, создающий вложенную транзакцию
        methodB();   

        // (4) в этот момент будет выброшено исключение, т.к. транзакция 
        //     помечена как rollback only
        tx.commit(); 
    } finally {
        tx.end();
    }
}

void methodB() {
    Transaction tx = persistence.getTransaction();
    try {
        // (2) допустим здесь возникло исключение
        tx.commit();
    } catch (Exception e) {
        // (3) обрабатываем его и выходим
        return;    
    } finally {
        tx.end();
    }
}</programlisting></para>
          <para>Если же транзакция в <code>methodB()</code> будет создана через <code>createTransaction()</code>, то ее откат не окажет никакого влияния на коммит охватывающей транзакции в <code>methodA()</code>. </para>
        </section>
        <section>
          <title>Чтение и изменение данных во вложенной транзакции</title>
          <para>Рассмотрим сначала зависимую вложенную транзакцию, создаваемую через <code>getTransaction()</code>:<programlisting>void methodA() {
    Transaction tx = persistence.createTransaction();
    try {
        EntityManager em = persistence.getEntityManager();
        
        // (1) загружаем сущность, в которой name == &quot;old name&quot;
        Employee employee = em.find(Employee.class, id); 
        assertEquals(&quot;old name&quot;, employee.getName());
        
        // (2) присваиваем новое значение полю 
        employee.setName(&quot;name A&quot;);                      
        
        // (3) вызываем метод, создающий вложенную транзакцию
        methodB();                                       
        
        // (8) здесь происходит коммит изменений в БД, и в ней 
        //     окажется значение &quot;name B&quot;
        tx.commit();                                     
                                                         
    } finally {
        tx.end();
    }
}

void methodB() {
    Transaction tx = persistence.getTransaction();
    try {
        // (4) получаем тот же экземпляр EntityManager, что и methodA
        EntityManager em = persistence.getEntityManager(); 

        // (5) загружаем сущность с тем же идентификатором
        Employee employee = em.find(Employee.class, id);   

        // (6) значение поля новое, т.к. мы работаем с тем же
        //     персистентным контекстом, и обращения к БД вообще 
        //     не происходит
        assertEquals(&quot;name A&quot;, employee.getName());        
        employee.setName(&quot;name B&quot;);                        

        // (7) в этот момент реально коммита не происходит                        
        tx.commit();                                       
    } finally {
        tx.end();
    }
}</programlisting></para>
          <para>Теперь рассмотрим тот же самый пример с независимой вложенной транзакцией, создаваемой через <code>createTransaction()</code>: <programlisting>void methodA() {
    Transaction tx = persistence.createTransaction();
    try {
        EntityManager em = persistence.getEntityManager();

        // (1) загружаем сущность, в которой name == &quot;old name&quot; 
        Employee employee = em.find(Employee.class, id); 
        assertEquals(&quot;old name&quot;, employee.getName());

        // (2) присваиваем новое значение полю 
        employee.setName(&quot;name A&quot;);                      

        // (3) вызываем метод, создающий вложенную транзакцию
        methodB();                                       

        // (8) здесь возникнет исключение из-за оптимистичной блокировки
        //     и коммит не пройдет вообще
        tx.commit();                                     
                                                         
    } finally {
        tx.end();
    }
}

void methodB() {
    Transaction tx = persistence.createTransaction();
    try {
        // (4) создается новый экземпляр EntityManager, т.к. это 
        //     новая транзакция                                       
        EntityManager em = persistence.getEntityManager(); 

        // (5) загружаем сущность с тем же идентификатором
        Employee employee = em.find(Employee.class, id);   

        // (6) значение поля старое, т.к. произошла загрузка из БД
        //     старого экземпляра сущности
        assertEquals(&quot;old name&quot;, employee.getName());      
                                                           
        employee.setName(&quot;name B&quot;);                        

        // (7) здесь происходит коммит изменений в БД, и в ней                         
        //     окажется значение &quot;name B&quot;
        tx.commit();                                       
                                                           
    } finally {
        tx.end();
    }
}</programlisting></para>
          <para>В последнем случае исключение в точке (8) возникнет только если сущность является оптимистично блокируемой, т.е. если она реализует интерфейс <code>Versioned</code>.</para>
        </section>
      </section>
      <section id="transaction_timeout">
        <title>Таймаут транзакции</title>
        <para>Для создаваемой транзакции может быть указан таймаут в секундах, при превышении которого транзакция будет прервана и откачена. Таймаут транзакции  ограничивает максимальную длительность запросов к базе данных.</para>
        <para>При программном управлении транзакциями таймаут включается путем передачи объекта <code>TransactionParams</code> в метод <code>Persistence.createTransaction()</code>. Например:<programlisting>Transaction tx = persistence.createTransaction(new TransactionParams().setTimeout(2));</programlisting></para>
        <para>При декларативном управлении транзакциями используется параметр <code>timeout</code> аннотации <code> @Transactional</code>, например:<programlisting>@Transactional(timeout = 2)
public void someServiceMethod() {
...</programlisting></para>
        <para>Таймаут по умолчанию может быть задан в свойстве приложения <property>
            <link linkend="cuba.defaultQueryTimeoutSec">cuba.defaultQueryTimeoutSec</link>
          </property>. </para>
        <section>
          <title>Особенности реализации для различных СУБД</title>
          <para><application>PostgreSQL</application></para>
          <para>К сожалению, JDBC драйвер <application>PostgreSQL</application> не поддерживает метод <code>setQueryTimeout()</code> интерфейса <code>java.sql.Statement</code>, поэтому в начале каждой транзакции, для которой определен таймаут (любым способом, включая ненулевое значение  свойства <property>
              <link linkend="cuba.defaultQueryTimeoutSec">cuba.defaultQueryTimeoutSec</link>
            </property>), выполняется дополнительный оператор в БД: <code>set local statement_timeout to {value}</code>. При этом в случае превышения таймаута запрос будет прерван самим сервером БД. </para>
          <para>Для снижения нагрузки от этих дополнительных операторов рекомендуется поступать следующим образом: <itemizedlist>
              <listitem>
                <para>Таймаут по умолчанию устанавливать не на <structname>Middleware</structname> с помощью свойства <property>cuba.defaultQueryTimeoutSec</property>, в на самом сервере <application>PostgreSQL</application> в файле <filename>postgresql.conf</filename>, например <literal>statement_timeout = 3000</literal> (это в миллисекундах). </para>
              </listitem>
              <listitem>
                <para>Для методов, которым требуется большее время таймаута (отчеты и пр.), явно указывать желаемый таймаут в параметрах транзакции. </para>
              </listitem>
            </itemizedlist></para>
          <para><application>Microsoft SQL Server</application></para>
          <para>Драйвер JTDS поддерживает метод <code>setQueryTimeout()</code> интерфейса <code>java.sql.Statement</code>, поэтому для <code>EntityManager</code> просто устанавливается стандартное свойство <literal>javax.persistence.query.timeout</literal>, которое соответствующим образом влияет на JDBC запросы. </para>
        </section>
      </section>
    </section>
    <section id="dataService">
      <title>DataService и DataWorker</title>
      <para><link linkend="managed_beans">Управляемый бин</link> <code>DataWorker</code> является универсальным средством для загрузки графов сущностей из базы данных, и для сохранения изменений, произведенных в <link linkend="entity_states">Detached</link> экземплярах сущностей. <link linkend="services">Сервис</link> <code>DataService</code> является фасадом для вызова <code>DataWorker</code> с клиентского <link linkend="app_tiers">уровня</link> приложения.</para>
      <para>Выделение бизнес-логики загрузки и сохранения в <code>DataWorker</code> дает возможность при необходимости создать свой сервис, делегирующий основную работу <code>DataWorker</code> и выполняющий дополнительные преобразования, например перед возвратом данных на клиентский уровень.</para>
      <para><code>DataWorker</code> всегда стартует новую транзакцию и по завершению работы выполняет коммит, таким образом возвращая сущности в состоянии <link linkend="entity_states">Detached</link>.</para>
      <para>Методы <code>DataWorker</code>:<itemizedlist>
          <listitem>
            <para><code>load()</code>, <code>loadList()</code> - загружает граф сущностей в сответствии с параметрами переданного объекта <code>LoadContext</code>. </para>
            <para>Данные методы проверяют наличие у пользователя права <code>EntityOp.READ</code> на загружаемую сущность. Кроме того, при извлечении сущностей из БД накладываются ограничения групп доступа (см. руководство <productname>Платформа CUBA. Подсистема безопасности</productname>). Для отмены действия ограничений в текущем запросе можно передать в <code>LoadContext</code> атрибут <code>useSecurityConstraints = false</code>.</para>
          </listitem>
          <listitem>
            <para><code>commit()</code> - сохраняет в базе данных набор сущностей, переданный в объекте <code>CommitContext</code>. Возвращает набор экземпляров сущностей, возвращенных из метода <code>EntityManager.merge()</code>, то есть по сути свежие экземпляры, только что обновленные в БД. Дальнейшая работа должна производиться именно с этими возвращенными экземплярами, чтобы предотвратить потерю данных или исключения оптимистичной блокировки.</para>
            <para>Данный метод  проверяет наличие у пользователя права <code>EntityOp.UPDATE</code> на изменяемые сущности, и <code>EntityOp.DELETE</code> на  удаляемые. </para>
          </listitem>
          <listitem>
            <para><code>commitNotDetached()</code> - аналогичен методу <code>commit()</code>, но предназначен для сохранения в БД экземпляров, у которых отсутствует информация о <link linkend="entity_states">Detached</link> состоянии. Такие экземпляры сущностей могут быть переданы с клиентов, которые работают не напрямую с объектами, загруженными <structname>Middleware</structname>, а с дополнительными Data Transfer Objects, либо вообще не с Java объектами, а с их XML или JSON представлением (как например клиенты <link linkend="rest_api">REST API</link>)</para>
          </listitem>
        </itemizedlist></para>
      <para>В процессе загрузки данных <code>DataWorker</code> может реализовывать дополнительную функциональность, описанную ниже.</para>
      <section>
        <title>Запросы с distinct</title>
        <para>В JPQL запросах для экранов со списками сущностей, в которых включено постраничное отображение и возможна непредсказуемая модификация запроса <link linkend="gui_Filter">универсальным фильтром</link> или механизмом ограничений групп доступа, при отсутствии в запросе оператора <literal>distinct</literal> может возникать следующий эффект: <itemizedlist>
            <listitem>
              <para>при объединении с коллекцией на уровне извлечения из базы данных возникает набор с дубликатами строк</para>
            </listitem>
            <listitem>
              <para>на клиентском уровне в источнике данных дубликаты исчезают, т.к. попадают в мэп (<code>java.util.Map</code>) </para>
            </listitem>
            <listitem>
              <para>при постраничном отображении на одной странице оказывается меньшее количество строк чем запрошено, общее количество строк наоборот завышено.</para>
            </listitem>
          </itemizedlist></para>
        <para>Таким образом, рекомендуется в JPQL запросы браузеров включать предложение <literal> distinct</literal>, которое гарантирует отсутствие дубликатов записей при выборке из базы данных. Однако в некоторых серверах БД (в частности <application>PostgreSQL</application>) при большом количестве извлекаемых записей (более 10000) SQL запрос с <literal>distinct</literal> выполняется недопустимо долго.</para>
        <para>Для решения этой проблемы в платформе реализована возможность корректной работы без <literal>distinct</literal> на уровне SQL. Данный механизм включается свойством приложения <property>
            <link linkend="cuba.inMemoryDistinct">cuba.inMemoryDistinct</link>
          </property>, при активации которого выполняется следующее: <itemizedlist>
            <listitem>
              <para>В JPQL запросе должен по прежнему присутствовать <literal>select distinct</literal></para>
            </listitem>
            <listitem>
              <para>В <code>DataWorker</code> из JPQL запроса перед отправкой в ORM <literal>distinct</literal> вырезается  </para>
            </listitem>
            <listitem>
              <para>После загрузки страницы данных на <structname>Middleware</structname> удаляются дубликаты и выполняются дополнительные запросы к БД для получения нужного количества строк, которые затем и возвращаются клиенту.</para>
            </listitem>
          </itemizedlist></para>
      </section>
      <section id="query_from_selected">
        <title>Последовательная выборка</title>
        <para><code>DataWorker</code> может выполнять последовательную выборку данных из результатов предыдущего запроса. Эта возможность используется в <link linkend="gui_Filter">универсальном фильтре</link> при последовательном наложении фильтров. </para>
        <para>Данный механизм работает следующим образом:<itemizedlist>
            <listitem>
              <para>При получении <code>LoadContext</code> с установленными атрибутами <code>prevQueries</code> и <code>queryKey</code> <code>DataWorker</code> выполняет выборку по предыдущему запросу и сохраняет идентификаторы полученных сущностей в таблице <database>SYS_QUERY_RESULT</database> (соответствующей сущности <literal>sys$QueryResult</literal>), разделяя наборы записей по идентификаторам пользовательских сессий и ключу сеанса выборки <code>queryKey</code>. </para>
            </listitem>
            <listitem>
              <para>Текущий запрос модифицируется для объединения с результатами предыдущего, так что в итоге возвращает данные, соответствующие условиям обоих запросов, объединенных по &quot;И&quot;.</para>
            </listitem>
            <listitem>
              <para>Далее процесс может повторяться, при  этом уменьшающийся набор предыдущих результатов удаляется из таблицы <database>SYS_QUERY_RESULT</database> и заполняется заново.</para>
            </listitem>
          </itemizedlist></para>
        <para>Таблицу <database>SYS_QUERY_RESULT</database> необходимо периодически чистить от ненужных результатов запросов, оставленных завершенными пользовательскими сессиями. Для этого предназначен метод <code>deleteForInactiveSessions</code> бина <code>QueryResultsManagerAPI</code>. В прикладном проекте с включенным параметром <property>
            <link linkend="cuba.allowQueryFromSelected">cuba.allowQueryFromSelected</link>
          </property> необходимо вызывать этот метод из <link linkend="scheduled_tasks">назначенных заданий</link>, например:<programlisting>&lt;task:scheduled-tasks scheduler=&quot;scheduler&quot;&gt;
    &lt;task:scheduled ref=&quot;cuba_QueryResultsManager&quot; method=&quot;deleteForInactiveSessions&quot; fixed-rate=&quot;600000&quot;/&gt;
&lt;/task:scheduled-tasks&gt;</programlisting></para>
      </section>
    </section>
    <section id="dbms_types">
      <title>Работа с СУБД</title>
      <section>
        <title>Выбор и подключение</title>
        <para>Тип используемой СУБД определяется свойством приложения <property>
            <link linkend="cuba.dbmsType">cuba.dbmsType</link>
          </property> и настройкой источника данных. Конфигурационный файл для Tomcat, определяющий источник данных, описан в <xref linkend="context.xml"/></para>
        <warning>
          <para>Обратите внимание на применимость СУБД в зависимости от используемых <link linkend="base_projects">базовых проектов</link> платформы:<itemizedlist>
              <listitem>
                <para><application>HSQLDB</application> - применяется только для запуска интеграционных тестов платформы, не используется в прикладных проектах</para>
              </listitem>
              <listitem>
                <para><application>PostgreSQL</application> - поддерживается всеми базовыми проектами платформы</para>
              </listitem>
              <listitem>
                <para><application>Microsoft SQL Server</application> - поддерживается базовыми проектами <structname>cuba</structname>, <structname>workflow</structname>, <structname>fts</structname></para>
              </listitem>
            </itemizedlist></para>
        </warning>
      </section>
      <section id="db_scripts">
        <title>Создание и обновление БД</title>
        <para>Проект CUBA-приложения всегда содержит два набора SQL скриптов:<itemizedlist>
            <listitem>
              <para>Скрипты создания БД - предназначены для создания базы данных с нуля.</para>
              <para>Скрипты создания располагаются в каталоге <filename>/db/init</filename> модуля <structname>core</structname>. Для каждого типа СУБД, поддерживаемой приложением, создается свой набор скриптов и располагается в подкаталоге с именем, соответствующим значению перечисления <code>DbmsType</code>, например <filename>/db/init/postgres</filename>. Имена скриптов создания должны иметь вид <filename>{optional_prefix}create-db.sql</filename>.</para>
            </listitem>
            <listitem>
              <para>Скрипты обновления БД - предназначены для поэтапного приведения структуры БД к текущему состоянию <link linkend="data_model">модели данных</link>.</para>
              <para>Скрипты обновления располагаются в каталоге <filename>/db/update</filename> модуля <structname>core</structname>. Для каждого типа СУБД, поддерживаемой приложением,  создается свой набор скриптов и располагается в подкаталоге с именем, соответствующим значению перечисления <code>DbmsType</code>, например <filename>/db/update/postgres</filename>. </para>
              <para>Скрипты обновления должны иметь имена, которые при сортировке в алфавитном порядке образуют правильную последовательность их выполнения (обычно это хронологическая последовательность их создания). Поэтому рекомендуется задавать имя скрипта обновления в виде <filename>{yymmdd}-{description}.sql</filename>, где <literal>yy</literal> - год, <literal>mm</literal> - месяц, <literal>dd</literal> - день, <literal>description</literal> - краткое описание скрипта. Например <filename>121003-addCodeToCategoryAttribute.sql</filename>.</para>
              <para>Скрипты обновления можно группировать в подкаталоги, главное чтобы путь к скрипту с учетом подкаталога не нарушал хронологической последовательности. Например, можно создавать подкаталоги по номеру года или по году и месяцу.</para>
            </listitem>
          </itemizedlist></para>
        <para>В развернутом приложении скрипты создания и обновления БД располагаются в специальном <link linkend="db_dir">каталоге скриптов базы данных</link>, задаваемым свойством приложения <property>
            <link linkend="cuba.dbDir">cuba.dbDir</link>
          </property>.</para>
        <para>Скрипты представляют собой текстовые файлы с набором DDL и DML команд, разделенных символом &quot;<literal>^</literal>&quot;. Символ &quot;<literal>^</literal>&quot; применяется для того, чтобы можно было применять разделитель &quot;<literal>;</literal>&quot; в составе сложных команд, например при создании функций или триггеров. Встроенный механизм исполнения скриптов разделяет входной файл на команды по разделителю &quot;<literal>^</literal>&quot; и выполняет  каждую команду в отдельной транзакции. Это означает, что при необходимости можно сгруппировать несколько простых операторов (например <literal>insert</literal>), разделенных точкой с запятой, и обеспечить выполнение их в одной транзакции.</para>
        <section>
          <title>Создание БД</title>
          <para>Базу данных можно создать двумя способами: с помощью скрипта сборки Gradle или на старте приложения путем запуска автоматического обновления.</para>
          <para>Скрипт сборки <filename>build.gradle</filename> содержит задачу <code>createDb</code>, которая создает указанную в параметрах задачи БД и выполняет на ней все SQL скрипты создания (базовых проектов и самого приложения). </para>
          <warning>
            <para>Если база данных по указанному в скрипте сборки URL существует, она полностью удаляется и создается заново.</para>
          </warning>
          <para>Чтобы инициализировать БД <link linkend="db_update">механизмом автоматического обновления</link> (например в развернутом приложении при отсутствии скрипта сборки), нужно выполнить следующее:<itemizedlist>
              <listitem>
                <para>включить свойство приложения <property>
                    <link linkend="cuba.automaticDatabaseUpdate">cuba.automaticDatabaseUpdate</link>
                  </property></para>
              </listitem>
              <listitem>
                <para>создать пустую базу данных, соответствующую URL, заданному в описании источника данных в <filename>
                    <link linkend="context.xml">context.xml</link>
                  </filename></para>
              </listitem>
              <listitem>
                <para>запустить веб-сервер, содержащий блок <structname>Middleware</structname>. На старте приложения  БД будет проинициализирована и сразу же готова к работе.</para>
              </listitem>
            </itemizedlist></para>
        </section>
        <section>
          <title>Обновление БД</title>
          <para>Процесс обновления базы данных заключается в выполнении скриптов обновления, присутствующих в проекте или в каталоге скриптов, которые не зарегистрированы как выполненные в таблице <database>SYS_DB_CHANGELOG</database>. Эти скрипты могут быть выполнены как вручную (используя сторонние инструменты), так и следующими встроенными в систему способами:<itemizedlist>
              <listitem>
                <para>Выполнением задачи <code>updateDb</code> скрипта сборки <filename>build.gradle</filename>.</para>
              </listitem>
              <listitem>
                <para>В работающем приложении:<itemizedlist>
                    <listitem>
                      <para>на старте <structname>Middleware</structname> при включенном <link linkend="db_update">механизме автоматического обновления</link></para>
                    </listitem>
                    <listitem>
                      <para>после старта вызовом метода <code>updateDatabase()</code> JMX-бина <code>
                          <link linkend="persistenceManagerMBean">PersistenceManagerMBean</link>
                        </code></para>
                    </listitem>
                  </itemizedlist></para>
              </listitem>
            </itemizedlist></para>
        </section>
        <section id="db_update">
          <title>Механизм автоматического обновления</title>
          <para>Механизм автоматического обновления включается свойством приложения <property>
              <link linkend="cuba.automaticDatabaseUpdate">cuba.automaticDatabaseUpdate</link>
            </property>. Он активируется на старте блока <structname>Middleware</structname> до момента полной инициализации приложения,  и действует следующим образом:<itemizedlist>
              <listitem>
                <para>Если в БД отсутствует таблица <database>SEC_USER</database>, то считается, что база данных пуста, и запускается полная инициализация с помощью скриптов создания БД. После выполнения инициализирующих скриптов их имена запоминаются в таблице <database>SYS_DB_CHANGELOG</database>. Кроме того, там же сохраняются имена всех доступных скриптов обновления, <emphasis>без их выполнения</emphasis>.</para>
              </listitem>
              <listitem>
                <para>Если в БД имеется таблица <database>SEC_USER</database>, но отсутствует таблица <database>SYS_DB_CHANGELOG</database> (это случай, когда в первый раз запускается описываемый механизм на имеющейся рабочей БД), никакие скрипты <emphasis>не запускаются</emphasis>. Вместо этого создается таблица <database>SYS_DB_CHANGELOG</database> и в ней сохраняются имена всех доступных на данный момент скриптов обновления. </para>
              </listitem>
              <listitem>
                <para>Если в БД имеются и таблица <database>SEC_USER</database> и таблица <database>SYS_DB_CHANGELOG</database>, производится запуск скриптов обновления, и их имена запоминаются в таблице <database>SYS_DB_CHANGELOG</database>. Причем запускаются только те скрипты, имен которых не было в таблице <database>SYS_DB_CHANGELOG</database>, т.е. не запускавшиеся ранее.
Последовательность запуска скриптов определяется 2-мя факторами: приоритетом базового проекта (см. содержимое <link linkend="db_dir">каталога скриптов базы данных</link>: <filename>10-cuba</filename>, <filename>20-workflow</filename>, ...) и именем файла скрипта (с учетом подкаталогов внутри каталога <filename>update</filename>) в алфавитном порядке.</para>
              </listitem>
            </itemizedlist></para>
        </section>
      </section>
      <section>
        <title>Проектирование БД</title>
        <section>
          <title>Соответствие типов данных</title>
          <para>В таблице приведено соответствие типов данных, отличающихся для разных СУБД.</para>
          <informaltable frame="all">
            <tgroup cols="3">
              <colspec colnum="1" colname="c0"/>
              <colspec colnum="2" colname="c1"/>
              <colspec colnum="3" colname="c2"/>
              <thead>
                <row>
                  <entry>Java</entry>
                  <entry>PostgreSQL</entry>
                  <entry>MS SQL Server</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry>UUID</entry>
                  <entry>uuid</entry>
                  <entry>uniqueidentifier</entry>
                </row>
                <row>
                  <entry>Date</entry>
                  <entry>timestamp</entry>
                  <entry>datetime</entry>
                </row>
                <row>
                  <entry>Boolean</entry>
                  <entry>boolean</entry>
                  <entry>tinyint</entry>
                </row>
                <row>
                  <entry>byte[]</entry>
                  <entry>bytea</entry>
                  <entry>image</entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </section>
        <section>
          <title>Особенности MS SQL Server</title>
          <para><application>Microsoft SQL Server</application> использует кластерные индексы для таблиц.</para>
          <para>По умолчанию кластерный индекс создается по первичному ключу таблицы, однако используемые в CUBA-приложении ключи типа <code>UUID</code> плохо подходят для кластерного индекса. Поэтому необходимо для каждой таблицы правильно выбрать и создать кластерный индекс. Поле для кластерного индекса должно быть небольшим и монотонно возрастающим, поэтому ориентировочные правила следующие:<itemizedlist>
              <listitem>
                <para>Для большинства таблиц подходит поле <database>CREATE_TS</database>. При этом записи будут физически располагаться в порядке их создания. </para>
              </listitem>
              <listitem>
                <para>Для композитных сущностей, если чтение превалирует над записью, имеет смысл использовать ссылку на владельца. При этом записи будут сгруппированы по владельцам, и их извлечение вместе с владельцем будет происходить быстрее. </para>
              </listitem>
              <listitem>
                <para>Для небольших (&lt; 100 записей) редко изменяемых таблиц тип кластерного индекса не важен, можно оставить <database>ID</database>. </para>
              </listitem>
              <listitem>
                <para>Для таблиц сущностей, унаследованных по стратегии <code>JOINED</code>, в которых нет поля <database>CREATE_TS</database>, нужно создать его искусственно с параметром <literal>default current_tmestamp</literal>. </para>
              </listitem>
            </itemizedlist></para>
          <para>Пример:<programlisting>create table SALES_CUSTOMER (
    ID uniqueidentifier not null,
    CREATE_TS datetime,
    ...
    primary key nonclustered (ID)
)^

create clustered index IDX_SALES_CUSTOMER_CREATE_TS on SALES_CUSTOMER (CREATE_TS)^</programlisting></para>
          <para>Пример композитной сущности: <programlisting>create table SALES_ITEM (
    ID uniqueidentifier not null,
    CREATE_TS datetime,
    ...
    ORDER_ID uniqueidentifier,
    ...
    primary key nonclustered (ID),
    constraint FK_SALES_ITEM_ORDER foreign key (ORDER_ID) references SALES_ORDER(ID)
)^

create clustered index IDX_SALES_ITEM_ORDER on SALES_ITEM (ORDER_ID)^</programlisting></para>
          <para>Пример унаследованной сущности: <programlisting>create table SALES_DOC (
    CARD_ID uniqueidentifier,
    CREATE_TS datetime default current_timestamp,
    NUMBER varchar(50),
    primary key nonclustered (CARD_ID),
    constraint FK_SALES_DOC_CARD foreign key (CARD_ID) references WF_CARD (ID)
)^

create clustered index IDX_SALES_DOC_CREATE_TS on SALES_DOC (CREATE_TS)^

create index IDX_SALES_DOC_CARD on SALES_DOC (CARD_ID)^</programlisting></para>
        </section>
      </section>
    </section>
  </section>
  <section id="gui_framework">
    <title>Универсальный пользовательский интерфейс</title>
    <para>Подсистема универсального пользовательского интерфейса (Generic UI, GUI) позволяет разрабатывать экраны пользовательского интерфейса, используя  XML и Java. Созданные таким образом экраны одинаково работоспособны в двух
стандартных клиентских <link linkend="app_tiers">блоках</link>: Web Client и Desktop Client. </para>
    <figure>
      <title>Структура универсального пользовательского интерфейса </title>
      <mediaobject>
        <imageobject>
          <imagedata align="center" fileref="img/ClientStructure.png"/>
        </imageobject>
      </mediaobject>
    </figure>
    <para>Здесь в центре изображены основные составляющие  экранов универсального пользовательского интерфейса:<itemizedlist>
        <listitem>
          <para><link linkend="screen_xml">XML-дескрипторы</link> - файлы XML, содержащие информацию об источниках данных и компоновке
экрана</para>
        </listitem>
        <listitem>
          <para><link linkend="screen_controller">Контроллеры</link> - классы Java, содержащие логику инициализации экрана
и обработки событий от элементов пользовательского интерфейса.</para>
        </listitem>
      </itemizedlist></para>
    <para>Код экранов приложения, расположенный в <link linkend="app_modules">модуле</link> <structname>gui</structname>,  взаимодействует с интерфейсами визуальных
компонентов (VCL Interfaces), реализованными по-отдельности в модулях <structname>web</structname>  и <structname>desktop</structname> <link linkend="base_projects">базового проекта</link> <structname>cuba</structname>. Для Web Client реализация основана на фреймворке <application>Vaadin</application>, для Desktop Client – на фреймворке <application>Java Swing</application>.</para>
    <para><link linkend="gui_vcl">Библиотека визуальных компонентов</link> (Visual Components Library, VCL)
содержит большой набор готовых компонентов для отображения данных.</para>
    <para>Механизм <link linkend="datasources">источников данных</link>  (Datasources) предоставляет унифицированный
интерфейс, обеспечивающий
функционирование
связанных
с
данными визуальных компонентов.</para>
    <para>Инфраструктура клиента  (Infrastructure) включает в себя главное окно приложения,
механизмы отображения и взаимодействия  экранов UI, а также средства
взаимодействия со средним слоем.</para>
    <section id="screens">
      <title>Экраны</title>
      <para>Экран универсального пользовательского интерфейса состоит из <link linkend="screen_xml">XML-дескриптора</link> и класса <link linkend="screen_controller">контроллера</link>. Дескриптор содержит ссылку на класс контроллера. </para>
      <para>Для того, чтобы экран можно было вызывать из главного меню или из Java кода (например из контроллера другого экрана), XML-дескриптор должен быть зарегистрирован в файле <link linkend="screens.xml">
          <filename>screens.xml</filename>
        </link> проекта.</para>
      <para>Главное меню приложения формируется отдельно для Web Client и Desktop Client на основе файлов <filename>
          <link linkend="menu.xml">menu.xml</link>
        </filename>, расположенных соответственно в модулях <structname>web</structname> и <structname>desktop</structname> проекта.</para>
      <section>
        <title>Типы экранов</title>
        <section id="frame">
          <title>Фрейм</title>
          <para>Фреймы представляют собой части экранов, которые можно использовать для декомпозиции и многократного использования.</para>
          <para>Для подключения фрейма в XML экрана используется элемент <link linkend="gui_IFrame">
              <sgmltag>iframe</sgmltag>
            </link> c указанием либо пути к файлу XML фрейма, либо идентификатора фрейма, если он зарегистрирован в  <link linkend="screens.xml">
              <filename>screens.xml</filename>
            </link>.</para>
          <para>Контроллер фрейма должен быть унаследован от класса <code>AbstractFrame</code>.</para>
          <para>Правила взаимодействия экрана и вложенного в него фрейма:</para>
          <itemizedlist>
            <listitem>
              <para>Из экрана обращаться к компонентам фрейма можно через точку: <code>frame_id.component_id</code></para>
            </listitem>
            <listitem>
              <para>Из контроллера фрейма получить компонент экрана  можно обычным вызовом <code>getComponent(component_id)</code>, но только в том случае, если компонент с таким именем не объявлен в самом фрейме. То есть компоненты фрейма маскируют компоненты экрана.</para>
            </listitem>
            <listitem>
              <para>Из фрейма получить <link linkend="datasources">источник данных</link> экрана можно простым вызовом <code>getDsContext().get(ds_id)</code> либо в запросе <code>ds$ds_id</code>, но только в том случае, если источник данных с таким именем не объявлен в самом фрейме (аналогично компонентам).</para>
            </listitem>
            <listitem>
              <para>Из экрана получить источник данных фрейма можно только через итерацию по <code>getDsContext().getChildren()</code></para>
            </listitem>
          </itemizedlist>
          <para>При коммите экрана вызывается также коммит измененных источников  данных фрейма.</para>
        </section>
        <section id="screen_simple">
          <title>Простой экран</title>
          <para>Простой экран предназначен для отображения и редактирования произвольной информации, в том числе отдельных экемпляров и списков сущностей. Данный тип экрана имеет только базовую функциональность, позволяющую отобразить его в главном окне системы, закрыть, а также работать с <link linkend="datasources">источниками данных</link>.</para>
          <para>Идентификатор экрана в файле <link linkend="screens.xml">
              <filename>screens.xml</filename>
            </link> может быть произвольного вида.</para>
          <para>Контроллер простого экрана должен быть унаследован от класса <code>AbstractWindow</code>. </para>
        </section>
        <section id="screen_lookup">
          <title>Экран выбора</title>
          <para>Экран выбора (lookup) отличается от простого экрана тем, что при вызове методом <code>openLookup()</code> отображает внизу панель с кнопками, позволяющими передать вызывающему коду экземпляр выбранной в данный момент в списке сущности. При вызове методом <code>openWindow()</code> или, например, из главного меню, панель с кнопками выбора не отображается.</para>
          <para>Экраны  выбора рекомендуется использовать для отображения списков сущностей. Визуальные компоненты, предназначенные для отображения и редактирования ссылок между сущностями (такие как <code>
              <link linkend="gui_PickerField">PickerField</link>
            </code>, <code>
              <link linkend="gui_LookupPickerField">LookupPickerField</link>
            </code>, <code>
              <link linkend="gui_SearchPickerField">SearchPickerField</link>
            </code>), вызывают экраны выбора для поиска связанных сущностей. </para>
          <para>Для корректной работы <link linkend="standard_actions">стандартных действий</link> идентификатор экрана выбора  в файле <link linkend="screens.xml">
              <filename>screens.xml</filename>
            </link> должен иметь вид <literal>{имя_сущности}.lookup</literal>, например <literal>sales$Customer.lookup</literal>.</para>
          <para>Контроллер экрана выбора должен быть унаследован от класса <code>AbstractLookup</code>. В XML экрана в атрибуте <sgmltag>lookupComponent</sgmltag> должен быть указан компонент (например, <code>
              <link linkend="gui_Table">Table</link>
            </code>), из которого будет взят экземпляр сущности при выборе.</para>
        </section>
        <section id="screen_edit">
          <title>Экран редактирования</title>
          <para>Экран редактирования предназначен для отображения и редактирования  экземпляра сущности. Поддерживает функциональность установки редактируемого экземпляра и <link linkend="gui_Action">действия</link> по  коммиту изменений в базу данных. Экран редактирования должен вызываться методом <code>openEditor()</code> с передачей экземпляра сущности.</para>
          <para>Для корректной работы <link linkend="standard_actions">стандартных действий</link> идентификатор экрана редактирования в файле <link linkend="screens.xml">
              <filename>screens.xml</filename>
            </link> должен иметь вид <literal>{имя_сущности}.edit</literal>, например <literal>sales$Customer.edit</literal>.</para>
          <para>Контроллер экрана редактирования  должен быть унаследован от класса <code>AbstractEditor</code>. В XML экрана в атрибуте <sgmltag>datasource</sgmltag> указывается источник данных, в который проставляется редактируемый экземпляр сущности. Для отображения действий, выполняющих коммит или отмену изменений, в XML можно использовать следующие стандартные фреймы с кнопками:<itemizedlist>
              <listitem>
                <para><literal>editWindowActions</literal> (файл <filename>com/haulmont/cuba/gui/edit-window.actions.xml</filename>) - содержит кнопки <guibutton>OK</guibutton> и <guibutton>Cancel</guibutton></para>
              </listitem>
              <listitem>
                <para><literal>extendedEditWindowActions</literal> (файл <filename>com/haulmont/cuba/gui/extended-edit-window.actions.xml</filename>) - содержит кнопки <guibutton>OK &amp; Close</guibutton>, <guibutton>OK</guibutton> и <guibutton>Cancel</guibutton></para>
              </listitem>
            </itemizedlist></para>
          <para>В экране редактирования неявно создаются следующие действия:<itemizedlist>
              <listitem>
                <para><literal>windowCommitAndClose</literal> (соответствует константе <code>Window.Editor.WINDOW_COMMIT_AND_CLOSE</code>) - действие, выполняющее коммит изменений в базу данных и закрывающее экран. Создается  при наличии в экране визуального компонента с идентификатором <literal>windowCommitAndClose</literal>, в частности, при использовании вышеописанного стандартного фрейма <literal>extendedEditWindowActions</literal> отображается кнопкой <guibutton>OK &amp; Close</guibutton>.</para>
              </listitem>
              <listitem>
                <para><literal>windowCommit</literal> (соответствует константе <code>Window.Editor.WINDOW_COMMIT</code>) - действие, выполняющее коммит изменений в базу данных. При отсутствии действия <literal>windowCommitAndClose</literal> после коммита закрывает экран. Создается всегда, и при наличии в экране  вышеописанных стандартных фреймов отображается кнопкой <guibutton>OK</guibutton>.</para>
              </listitem>
              <listitem>
                <para><literal>windowClose</literal> (соответствует константе <code>Window.Editor.WINDOW_CLOSE</code>) - действие, закрывающее экран без коммита изменений. Создается всегда, и при наличии в экране  вышеописанных стандартных фреймов отображается кнопкой <guibutton>Cancel</guibutton>.</para>
              </listitem>
            </itemizedlist></para>
          <para>Таким образом, если  в экран добавлен фрейм <literal>editWindowActions</literal>, то кнопка <guibutton>OK</guibutton> коммитит изменения и закрывает экран, а кнопка <guibutton>Cancel</guibutton> - закрывает без коммита. Если же добавлен фрейм <literal>extendedEditWindowActions</literal>, то кнопка <guibutton>OK</guibutton> только коммитит изменения, оставляя экран открытым, кнопка <guibutton>OK &amp; Close</guibutton> коммитит и закрывает экран, кнопка <guibutton>Cancel</guibutton> - закрывает без коммита.</para>
          <para>Вместо стандартных фреймов для отображения действий можно использовать произвольные компоненты, например <code>
              <link linkend="gui_LinkButton">LinkButton</link>
            </code>.</para>
        </section>
      </section>
      <section id="screen_xml">
        <title>XML-дескриптор</title>
        <para>XML-дескриптор - это файл формата XML, описывающий <link linkend="datasources">источники данных</link> и расположение визуальных компонентов экрана.</para>
        <para><para>Схема XML доступна по адресу <ulink url="http://schemas.haulmont.com/cuba/4.0/window.xsd">http://schemas.haulmont.com/cuba/4.0/window.xsd</ulink></para></para>
        <para>Рассмотрим структуру дескриптора.</para>
        <para><sgmltag>window</sgmltag> − корневой элемент.</para>
        <para>Атрибуты <sgmltag>window</sgmltag>:<itemizedlist>
            <listitem>
              <para><property>
                  <sgmltag>class</sgmltag>
                </property> − имя класса <link linkend="screen_controller">контроллера</link></para>
            </listitem>
            <listitem>
              <para><sgmltag>messagesPack</sgmltag> −  <link linkend="message_packs">пакет сообщений</link> данного экрана, который будет использован при получении локализованных строк  без указания  пакета из XML-дескриптора и из контроллера методом <code>getMessage()</code></para>
            </listitem>
            <listitem>
              <para><sgmltag>caption</sgmltag> − заголовок экрана, может содержать <link linkend="messageTools.loadString">ссылку на сообщение</link> из вышеуказанного пакета, например, <programlisting>caption=&quot;msg://caption&quot;</programlisting></para>
            </listitem>
            <listitem>
              <para><sgmltag>focusComponent</sgmltag> − идентификатор компонента, который получит фокус ввода при отображении экрана</para>
            </listitem>
            <listitem>
              <para><sgmltag>lookupComponent</sgmltag> - обязательный для <link linkend="screen_lookup">экрана выбора</link> атрибут, задающий идентификатор визуального компонента, из которого будет выбран экземпляр сущности. Поддерживаются компоненты следующих типов (и их наследников):<itemizedlist>
                  <listitem>
                    <para><code>Table</code></para>
                  </listitem>
                  <listitem>
                    <para><code>Tree</code></para>
                  </listitem>
                  <listitem>
                    <para><code>LookupField</code></para>
                  </listitem>
                  <listitem>
                    <para><code>PickerField</code></para>
                  </listitem>
                  <listitem>
                    <para><code>OptionsGroup</code></para>
                  </listitem>
                </itemizedlist></para>
            </listitem>
            <listitem>
              <para><sgmltag>datasource</sgmltag> - обязательный для <link linkend="screen_edit">экрана редактирования</link> атрибут, задающий идентификатор <link linkend="datasources">источника данных</link>, в который будет проставлен экземпляр редактируемой сущности.</para>
            </listitem>
          </itemizedlist></para>
        <para>Элементы <sgmltag>window</sgmltag>:<itemizedlist>
            <listitem>
              <para><sgmltag>metadataContext</sgmltag> −  элемент для инициализации <link linkend="views">представлений</link> (views), необходимых данному экрану. Предпочтительным является определение всех представлений в одном общем файле <filename>
                  <link linkend="views.xml">views.xml</link>
                </filename>, так как все описатели представлений разворачиваются в один общий репозиторий, и при рассредоточении описателей по разным файлам трудно обеспечить уникальность имен.</para>
            </listitem>
            <listitem>
              <para><sgmltag>dsContext</sgmltag> −  определяет <link linkend="datasources">источники данных</link> данного экрана.</para>
            </listitem>
            <listitem>
              <para><sgmltag>actions</sgmltag> -  определяет список <link linkend="gui_Action">действий</link> данного экрана.</para>
            </listitem>
            <listitem>
              <para><sgmltag>timers</sgmltag> -  определяет список таймеров данного экрана.</para>
            </listitem>
            <listitem>
              <para><sgmltag>companions</sgmltag> -  определяет список классов-<link linkend="companions">компаньонов</link> данного контроллера</para>
              <para>Элементы <sgmltag>companions</sgmltag>:<itemizedlist>
                  <listitem>
                    <para><sgmltag>web</sgmltag> - задает компаньон, реализованный в модуле <structname>web</structname></para>
                  </listitem>
                  <listitem>
                    <para><sgmltag>desktop</sgmltag> - задает компаньон, реализованный в модуле <structname>desktop</structname></para>
                  </listitem>
                </itemizedlist></para>
              <para>Каждый из этих элементов содержит атрибут <sgmltag>class</sgmltag>, задающий класс компаньона.</para>
            </listitem>
            <listitem>
              <para><sgmltag>layout</sgmltag> − корневой элемент компоновки экрана. Является сам по себе контейнером с вертикальным расположением компонентов, аналогичным <link linkend="gui_BoxLayout">
                  <sgmltag>vbox</sgmltag>
                </link>.</para>
              <para>Атрибуты <sgmltag>layout</sgmltag>:<itemizedlist>
                  <listitem>
                    <para><link linkend="attr_spacing">
                        <sgmltag>spacing</sgmltag>
                      </link></para>
                  </listitem>
                  <listitem>
                    <para><link linkend="attr_margin">
                        <sgmltag>margin</sgmltag>
                      </link></para>
                  </listitem>
                  <listitem>
                    <para><link linkend="attr_expand">
                        <sgmltag>expand</sgmltag>
                      </link></para>
                  </listitem>
                  <listitem>
                    <para><link linkend="attr_stylename">
                        <sgmltag>stylename</sgmltag>
                      </link></para>
                  </listitem>
                  <listitem>
                    <para><link linkend="attr_height">
                        <sgmltag>height</sgmltag>
                      </link></para>
                  </listitem>
                  <listitem>
                    <para><link linkend="attr_width">
                        <sgmltag>width</sgmltag>
                      </link></para>
                  </listitem>
                </itemizedlist></para>
            </listitem>
          </itemizedlist></para>
      </section>
      <section id="screen_controller">
        <title>Контроллер экрана</title>
        <para>Контроллер экрана - это <code>Java</code> или <code>Groovy</code> класс, связанный с <link linkend="screen_xml">XML-дескриптором</link>, и содержащий логику инициализации и обработки событий экрана.</para>
        <para>Контроллер должен быть унаследован от одного из следующих базовых классов:</para>
        <itemizedlist>
          <listitem>
            <para><code>
                <link linkend="abstractFrame">AbstractFrame</link>
              </code> − предназначен для реализации <link linkend="frame">фреймов</link>.</para>
          </listitem>
          <listitem>
            <para><code>
                <link linkend="abstractWindow">AbstractWindow</link>
              </code> − предназначен для реализации <link linkend="screen_simple">простых экранов</link>.</para>
          </listitem>
          <listitem>
            <para><code>
                <link linkend="abstractLookup">AbstractLookup</link>
              </code> − предназначен для реализации <link linkend="screen_lookup">экранов выбора</link>.</para>
          </listitem>
          <listitem>
            <para><code>
                <link linkend="abstractEditor">AbstractEditor</link>
              </code> − предназначен для реализации <link linkend="screen_edit">экранов редактирования</link>.</para>
          </listitem>
        </itemizedlist>
        <tip>
          <para>Если экрану не нужна никакая дополнительная логика, то в качестве контроллера можно использовать сам базовый класс <code>AbstractWindow</code>, <code>AbstractLookup</code> или <code>AbstractEditor</code>, указав его в XML-дескрипторе (эти классы на самом деле не являются абстрактными в смысле невозможности создания экземпляров). Для фрейма класс контроллера можно не указывать вообще.</para>
        </tip>
        <para>Класс контроллера должен быть зарегистрирован в XML-дескрипторе экрана в атрибуте <sgmltag>class</sgmltag> корневого элемента <sgmltag>window</sgmltag>.</para>
        <figure>
          <title>Базовые классы контроллеров</title>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/Controllers.png"/>
            </imageobject>
          </mediaobject>
        </figure>
        <section id="abstractFrame">
          <title>AbstractFrame</title>
          <para><code>AbstractFrame</code> является корнем иерархии классов контроллеров. Рассмотрим его основные методы:</para>
          <itemizedlist>
            <listitem>
              <para><code>init()</code> - вызывается фреймворком после создания всего дерева компонентов, описанного XML-дескриптором, но до отображения экрана.</para>
              <para>В метод <methodname>init()</methodname> из вызывающего кода передается мэп параметров, которые могут быть использованы  внутри контроллера. Эти параметры могут быть переданы как из кода контроллера вызывающего экрана (в методе <code>openWindow()</code>, <code>openLookup()</code> или <code>openEditor()</code>), так и установлены в файле регистрации экранов <filename>
                  <link linkend="screens.xml">screens.xml</link>
                </filename>.</para>
              <para>Метод <code>init()</code> следует имплементировать при необходимости  инициализации компонентов экрана, например:<programlisting>@Inject
private Table someTable;

@Override
public void init(Map&lt;String, Object&gt; params) {
    someTable.addGeneratedColumn(&quot;someColumn&quot;, new Table.ColumnGenerator&lt;Colour&gt;() {
        @Override
        public Component generateCell(Colour entity) {
            ...
        }
    });
}</programlisting></para>
            </listitem>
            <listitem>
              <para><code>getMessage()</code>, <code>formatMessage()</code> - методы получения локализованных сообщений из <link linkend="message_packs">пакета</link>, заданного для экрана в XML-дескрипторе. Представляют собой просто короткие варианты вызова одноименных методов интерфейса <code>
                  <link linkend="messages">Messages</link>
                </code>.</para>
            </listitem>
            <listitem>
              <para><code>getDialogParams()</code> - получить объект <code>DialogParams</code> для установки параметров отображения диалоговых окон (высота, ширина и пр.). Значения, установленные в этом объекте, влияют на следующий экран, открываемый в режиме модального диалога (<code>WindowManager.OpenType.DIALOG</code>). После отображения диалога они сбрасываются в значения по умолчанию.</para>
              <para>Таким образом, при устанавливать значения в <code>DialogParams</code> необходимо непосредственно перед вызовом другого экрана в режиме диалога методами <code>openWindow()</code>, <code>openLookup()</code>, <code>openEditor()</code>. Например:<programlisting>getDialogParams().setWidth(400);
openEditor(&quot;sales$Customer.edit&quot;, customer, WindowManager.OpenType.DIALOG);</programlisting></para>
              <para>Если же сам текущий экран открывается в режиме модального диалога, то можно управлять параметрами его отображения, устанавливая параметры <code>DialogParams</code>  в его методе <code>init()</code>. При этом установленные в <code>init()</code> параметры имеют приоритет над установленными в вызывающем коде.</para>
            </listitem>
            <listitem>
              <para><code>openFrame()</code> - загрузить фрейм по идентификатору, зарегистрированному в <filename>
                  <link linkend="screens.xml">screens.xml</link>
                </filename>, и, если в метод передан компонент-контейнер, отобразить его внутри контейнера. Возвращается контроллер фрейма. Например:<programlisting>@Inject
private BoxLayout container;

@Override
public void init(Map&lt;String, Object&gt; params) {
    SomeFrame frame = openFrame(container, &quot;someFrame&quot;);
    frame.setHeight(&quot;100%&quot;);
    frame.someInitMethod();
}</programlisting></para>
              <para>Контейнер не обязательно сразу передавать в метод <code>openFrame()</code>, вместо этого можно загрузить фрейм, а затем добавить его  в нужный контейнер:<programlisting>@Inject
private BoxLayout container;

@Override
public void init(Map&lt;String, Object&gt; params) {
    SomeFrame frame = openFrame(null, &quot;someFrame&quot;);
    frame.setHeight(&quot;100%&quot;);
    frame.someInitMethod();
    container.add(frame);
}</programlisting></para>
            </listitem>
            <listitem>
              <para><code>openWindow()</code>, <code>openLookup()</code>, <code>openEditor()</code> - открыть соответственно простой экран, экран выбора или редактирования. Методы возвращают контроллер созданного экрана.</para>
              <para>Для выполнения действий после закрытия вызываемого экрана необходимо добавить слушатель типа <code>CloseListener</code>, например:<programlisting>CustomerEdit editor = openEditor(&quot;sales$Customer.edit&quot;, customer, WindowManager.OpenType.THIS_TAB);
editor.addListener(new CloseListener() {
    @Override
    public void windowClosed(String actionId) {
        // do something
    }
});</programlisting></para>
            </listitem>
            <listitem>
              <para><code>showMessageDialog()</code> - отобразить диалоговое окно с сообщением.</para>
            </listitem>
            <listitem>
              <para><code>showOptionDialog()</code> - отобразить диалоговое окно с сообщением и возможностью выбора пользователем некоторых действий. Действия задаются массивом объектов типа <code>
                  <link linkend="gui_Action">Action</link>
                </code>, которые в диалоге отображаются посредством соответствующих кнопок.</para>
              <para>Для отображения стандартных кнопок типа <guibutton>OK</guibutton>, <guibutton>Cancel</guibutton> и других рекомендуется использовать объекты типа <code>DialogAction</code>, например:<programlisting>showOptionDialog(&quot;PLease confirm&quot;, &quot;Are you sure?&quot;, 
        MessageType.CONFIRMATION,
        new Action[] {
                new DialogAction(DialogAction.Type.YES) {
                    @Override
                    public void actionPerform(Component component) {
                        // do something
                    }
                },
                new DialogAction(DialogAction.Type.NO);
        });</programlisting></para>
            </listitem>
            <listitem>
              <para><code>showNotification()</code> - отобразить всплывающее окно с сообщением.</para>
            </listitem>
          </itemizedlist>
        </section>
        <section id="abstractWindow">
          <title>AbstractWindow</title>
          <para><code>AbstractWindow</code> является наследником <code>
              <link linkend="abstractFrame">AbstractFrame</link>
            </code>, и определяет следующие собственные методы:</para>
          <itemizedlist>
            <listitem>
              <para><code>validateAll()</code> - валидация экрана. Реализация по умолчанию вызывает метод <code>validate()</code> у всех компонентов экрана, реализующих интерфейс <code>Component.Validatable</code>, накапливает информацию об исключениях, и если таковые имеются, выводит соответствующее сообщение и возвращает <code>false</code>, иначе возвращает <code>true</code>.</para>
              <para>Данный метод следует переопределять только в том случае, если необходимо полностью заменить стандартную процедуру валидации экрана. Если же нужно только дополнить ее, достаточно определить специальный шаблонный метод <code>postValidate()</code>.</para>
            </listitem>
            <listitem>
              <para><code>postValidate()</code> - шаблонный метод, который можно имплементировать в контроллере для дополнительной валидации экрана. Получаемый методом объект <code>ValidationErrors</code> используется для добавления информации об ошибках валидации, которая будет отображена совместно с ошибками стандартной валидации. Например:<programlisting>private Pattern pattern = Pattern.compile(&quot;\\d&quot;);

@Override
protected void postValidate(ValidationErrors errors) {
    if (getItem().getAddress().getCity() != null) {
        if (pattern.matcher(getItem().getAddress().getCity()).find()) {
            errors.add(&quot;City name can&apos;t contain digits&quot;);
        }
    }
}</programlisting></para>
            </listitem>
            <listitem>
              <para><code>close()</code> - закрыть данный экран. </para>
              <para>Метод принимает строковое значение, передаваемое далее  в шаблонный метод <code>preClose()</code> и слушателям <code>CloseListener</code>. Таким образом заинтересованный код может получить информацию о причине закрытия экрана от кода, инициирующего закрытие. В частности, в экранах редактирования сущностей при закрытии экрана после коммита изменений рекомендуется использовать константу <code>Window.COMMIT_ACTION_ID</code>, без коммита изменений - константу <code>Window.CLOSE_ACTION_ID</code>.</para>
              <para>Если какой-либо из источников данных содержит несохраненные изменения, перед закрытием экрана будет выдано диалоговое окно с соответствующим предупреждением. Тип предупреждения можно выбрать с помощью свойства приложения <property>
                  <link linkend="cuba.gui.useSaveConfirmation">cuba.gui.useSaveConfirmation</link>
                </property>.</para>
              <para>Вариант  метода <code>close()</code> с параметром <code>force = false</code> закрывает экран без вызова <code>preClose()</code> и без предупреждения, независимо от наличия несохраненных изменений.</para>
              <para>Метод <code>close()</code> возвращает <code>true</code>, если экран был успешно закрыт, и <code>false</code> - если закрытие было прервано.</para>
            </listitem>
            <listitem>
              <para><code>preClose()</code> - шаблонный метод, который можно имплементировать в контроллере для перехвата момента закрытия экрана. Метод получает строковое значение, указанное инициатором закрытия при вызове метода <code>close()</code>.</para>
              <para>Если метод <code>preClose()</code> возвращает <code>false</code>, то процесс закрытия экрана прерывается.</para>
            </listitem>
          </itemizedlist>
        </section>
        <section id="abstractLookup">
          <title>AbstractLookup</title>
          <para><code>AbstractLookup</code> является наследником <code>
              <link linkend="abstractWindow">AbstractWindow</link>
            </code>, и определяет следующие собственные методы:</para>
          <itemizedlist>
            <listitem>
              <para><code>setLookupComponent()</code> - установить компонент, из которого будет производиться выбор экземпляров сущности. </para>
              <para>Как правило,  компонент выбора устанавливается в XML-дескрипторе экрана, и вызывать данный метод в прикладном коде нет необходимости.</para>
            </listitem>
            <listitem>
              <para><code>setLookupValidator()</code> - установить для экрана объект типа <code>Window.Lookup.Validator</code>, метод <code>validate()</code> которого вызывается фреймворком перед тем как вернуть выбранные экземпляры сущностей. Если <code>validate()</code> возвращает <code>false</code>, процесс выбора и закрытия экрана прерывается.</para>
              <para>По умолчанию валидатор не установлен.</para>
            </listitem>
          </itemizedlist>
        </section>
        <section id="abstractEditor">
          <title>AbstractEditor</title>
          <para><code>AbstractEditor</code> − базовый класс контроллеров экранов редактирования, является наследником <code>
              <link linkend="abstractWindow">AbstractWindow</link>
            </code>.</para>
          <para>При создании конкретного класса контроллера рекомендуется параметризовать <code>AbstractEditor</code> типом редактируемой сущности. При этом методы <code>getItem()</code> и <code>initItem()</code> будут работать с конкретным типом сущности и прикладному коду не потребуется дополнительных приведений типов. Например:</para>
          <programlisting>public class CustomerEdit extends AbstractEditor&lt;Customer&gt; {

    @Override
    protected void initItem(Customer item) {
    ...</programlisting>
          <para><code>AbstractEditor</code> определяет следующие собственные методы:</para>
          <itemizedlist>
            <listitem>
              <para><code>getItem()</code> - возвращает экземпляр редактируемой сущности, установленный в главном источнике данных экрана (т.е. указанном в атрибуте <sgmltag>datasource</sgmltag> корневого элемента XML-дескриптора).</para>
              <para>Если редактируется не новый экземпляр, то в момент открытия экрана он перезагружается из базы данных с необходимым <link linkend="views">представлением</link>, указанным для главного источника данных. </para>
              <para>Изменения, вносимые в экземпляр, возвращаемый <code>getItem()</code>,  отражаются на состоянии источника данных, и будут отправлены на Middleware при коммите экрана.</para>
              <warning>
                <para>Следует иметь в виду, что <code>getItem()</code> возвращает значение только после инициализации экрана методом <code>setItem()</code>. До этого момента, например в методах <code>init()</code> и <code>initItem()</code>, данный метод возвращает <code>null</code>.</para>
                <para>Однако в методе <code>init()</code> экземпляр сущности, переданный в <code>openEditor()</code>, можно получить из  параметров следующим образом:<programlisting>@Override
public void init(Map&lt;String, Object&gt; params) {
    Customer item = WindowParams.ITEM.getEntity(params);
    // do something
}</programlisting></para>
                <para>В метод <code>initItem()</code> экземпляр передается явно и нужного типа.</para>
                <para>В обоих случаях полученный экземпляр сущности, если он не новый, будет впоследствии перезагружен, и вносить в него изменения или сохранять в поле для последующего использования не имеет смысла.</para>
              </warning>
            </listitem>
            <listitem>
              <para><code>setItem()</code> - вызывается фреймворком при открытии экрана методом <code>openEditor()</code> для установки редактируемого экземпляра сущности в главном источнике данных. В момент вызова   созданы все компоненты и источники данных экрана, и отработал метод <code>init()</code> контроллера.</para>
              <para>Для инициализации экрана редактирования вместо переопределения <code> setItem()</code> рекомендуется имплементировать специальные шаблонные методы <code>initItem()</code> и <code>postInit()</code>.</para>
            </listitem>
            <listitem>
              <para><code>initItem()</code> - шаблонный метод, вызываемый фреймворком перед установкой редактируемого экземпляра сущности в главном источнике данных.</para>
              <para>Данный метод можно имплементировать в контроллере при необходимости инициализации экземпляра сущности перед его установкой в источник данных, например:<programlisting>@Override
protected void initItem(Driver item) {
    if (PersistenceHelper.isNew(item)){
        item.setAddress(new Address());
    }
}</programlisting></para>
            </listitem>
            <listitem>
              <para><code>postInit()</code> - шаблонный метод, вызываемый фреймворком сразу после  установки редактируемого экземпляра сущности в главном источнике данных. Во время выполнения данного метода можно вызывать <code>getItem()</code>, который будет возвращать новый или перезагруженный при инициализации экрана  экземпляр сущности.</para>
              <para>Данный метод можно имплементировать в контроллере для окончательной инициализации экрана, например:<programlisting>@Inject
protected EntityDiffViewer diffFrame;

@Override
protected void postInit() {
    if (!PersistenceHelper.isNew(getItem())) {
        diffFrame.loadVersions(getItem());
    }
}</programlisting></para>
            </listitem>
            <listitem>
              <para><code>commit()</code> - валидировать экран и отправить изменения через <code>DataSupplier</code> на Middleware.</para>
              <para>Если используется вариант метода с параметром <code>validate = false</code>, то валидация перед коммитом не производится.</para>
              <para>Данный метод не рекомендуется переопределять, лучше использовать специальные шаблонные методы <code>postValidate()</code>, <code>preCommit()</code> и <code>postCommit()</code>.</para>
            </listitem>
            <listitem>
              <para><code>commitAndClose()</code> - валидировать экран, отправить изменения  на Middleware и закрыть экран. В метод <code>preClose()</code> и зарегистрированные слушатели <code>CloseListener</code> будет передано значение константы <code>Window.COMMIT_ACTION_ID</code>.</para>
              <para>Данный метод не рекомендуется переопределять, лучше использовать специальные шаблонные методы <code>postValidate()</code>, <code>preCommit()</code> и <code>postCommit()</code>.</para>
            </listitem>
            <listitem>
              <para><code>preCommit()</code> - шаблонный метод, вызываемый фреймворком в процессе коммита изменений, после того как когда валидация завершена успешно и перед отправкой данных на Middleware.</para>
              <para>Данный метод можно имплементировать в контроллере. Если метод возвращает <code>false</code>, процесс коммита (и закрытия экрана, если был вызван <code>commitAndClose()</code>), прерывается. Например:<programlisting>@Override
protected boolean preCommit() {
    if (somethingWentWrong) {
        showNotification(&quot;Something went wrong&quot;, NotificationType.WARNING);
        return false;
    }
    return true;
}</programlisting></para>
            </listitem>
            <listitem>
              <para><code>postCommit()</code> - шаблонный метод, вызываемый фреймворком на финальной стадии коммита изменений. Параметры метода:<itemizedlist>
                  <listitem>
                    <para><code>committed</code> - установлен в <code>true</code>, если в экране действительно были изменения, и они отправлены на Middleware;</para>
                  </listitem>
                  <listitem>
                    <para><code>close</code> - установлен в <code>true</code>, если экран после коммита будет закрыт.</para>
                  </listitem>
                </itemizedlist></para>
              <para>Реализация метода по умолчанию, если экран не закрывается, отображает сообщение об успешном коммите изменений и вызывает метод <code>postInit()</code>.</para>
              <para>Данный метод можно переопределить в контроллере для выполнения некоторых действий после успешного коммита, например:<programlisting>@Inject
private Datasource&lt;Driver&gt; driverDs;
@Inject
private EntitySnapshotService entitySnapshotService;

@Override
protected boolean postCommit(boolean committed, boolean close) {
    if (committed) {
        entitySnapshotService.createSnapshot(driverDs.getItem(), driverDs.getView());
    }
    return super.postCommit(committed, close);
}</programlisting></para>
            </listitem>
          </itemizedlist>
          <para>Далее приведены диаграммы последовательностей инициализации и различных вариантов коммита экрана редактирования.</para>
          <figure>
            <title>Инициализация экрана редактирования</title>
            <mediaobject>
              <imageobject>
                <imagedata align="center" fileref="img/EditorInit.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <figure>
            <title>Коммит и закрытие экрана с фреймом editWindowActions</title>
            <mediaobject>
              <imageobject>
                <imagedata align="center" fileref="img/EditorCommit.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <figure>
            <title>Коммит экрана с фреймом extendedEditWindowActions</title>
            <mediaobject>
              <imageobject>
                <imagedata align="center" fileref="img/ExtendedEditorCommit.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <figure>
            <title>Коммит и закрытие экрана с фреймом extendedEditWindowActions</title>
            <mediaobject>
              <imageobject>
                <imagedata align="center" fileref="img/ExtendedEditorCommitAndClose.png"/>
              </imageobject>
            </mediaobject>
          </figure>
        </section>
        <section id="screen_controller_injection">
          <title>Зависимости контроллеров</title>
          <para>В контроллерах можно использовать Dependency Injection для получения ссылок на используемые объекты. Для этого нужно объявить либо поле соответствующего типа, либо метод доступа на запись (setter) с соответствующим типом результата, и добавить ему одну из следующих аннотаций:<itemizedlist>
              <listitem>
                <para><code>@Inject</code> - простейший вариант, поиск объекта для инжекции будет произведен по типу поля/метода и по имени, эквивалентному имени поля либо имени атрибута (по правилам JavaBeans) для метода</para>
              </listitem>
              <listitem>
                <para><code>@Named(&quot;someName&quot;)</code> - вариант с явным указанием имени искомого объекта</para>
              </listitem>
            </itemizedlist></para>
          <para>Инжектировать в контроллеры можно следующие объекты: <itemizedlist>
              <listitem>
                <para>Визуальные компоненты данного экрана, определенные в XML-дескрипторе. Если тип атрибута унаследован от <code>Component</code>, в текущем экране будет произведен поиск компонента с соответствующим именем. </para>
              </listitem>
              <listitem>
                <para>Действия, определенные в XML-дескрипторе - см. <xref linkend="gui_Action"/></para>
              </listitem>
              <listitem>
                <para><link linkend="datasources">Источники данных</link>, определенные в XML-дескрипторе. Если тип атрибута унаследован от <code>Datasource</code>, в текущем экране будет произведен поиск источника данных с соответствующим именем. </para>
              </listitem>
              <listitem>
                <para><code>UserSession</code>. Если тип атрибута - <code>
                    <link linkend="userSession">UserSession</link>
                  </code>, будет инжектирован объект текущей пользовательской сессии. </para>
              </listitem>
              <listitem>
                <para><code>DsContext</code>. Если тип атрибута - <code>DsContext</code>, будет инжектирован <code>DsContext</code> текущего экрана. </para>
              </listitem>
              <listitem>
                <para><code>WindowContext</code>. Если тип атрибута - <code>WindowContext</code>, будет инжектирован <code>WindowContext</code> текущего экрана. </para>
              </listitem>
              <listitem>
                <para><code>DataService</code>. Если тип атрибута - <code>com.haulmont.cuba.gui.data.DataService</code>, будет инжектирован этот объект. </para>
              </listitem>
              <listitem>
                <para>Любой бин, определенный в контексте данного клиентского блока приложения, в том числе:<itemizedlist>
                    <listitem>
                      <para>импортируемые клиентом <link linkend="services">сервисы</link> Middleware</para>
                    </listitem>
                    <listitem>
                      <para><code>ComponentsFactory</code></para>
                    </listitem>
                    <listitem>
                      <para><code>WindowConfig</code></para>
                    </listitem>
                    <listitem>
                      <para><code>ExportDisplay</code></para>
                    </listitem>
                    <listitem>
                      <para><code>
                          <link linkend="background_tasks">BackgroundWorker</link>
                        </code></para>
                    </listitem>
                  </itemizedlist></para>
              </listitem>
              <listitem>
                <para>Если ничего из вышеперечисленного не подошло и контроллер имеет <link linkend="companions">компаньонов</link>, в случае совпадения типов будет инжектирован компаньон для текущего типа клиента.</para>
              </listitem>
            </itemizedlist></para>
        </section>
        <section id="companions">
          <title>Реализация для разных типов клиентов</title>
          <para>Базовые классы контроллеров расположены в <link linkend="app_modules">модуле</link> <structname>gui</structname> <link linkend="base_projects">базового проекта</link> <structname>cuba</structname> и не содержат ссылок на классы реализации визуальных компонентов (<application>Swing</application> или <application>Vaadin</application>), что дает возможность использовать их в клиентах обоих типов. Вместо этого базовые классы контроллеров реализуют дополнительный интерфейс <code>Window.Wrapper</code> и делегируют выполнение &quot;обернутому&quot; окну. </para>
          <para>В то же время конкретные классы контроллеров могут быть расположены как в модуле <structname>gui</structname>, так и в <structname>web</structname> или <structname>desktop</structname>, в зависимости от применяемых в проекте клиентских <link linkend="app_tiers">блоков</link> и специфики экрана. Если контроллер является универсальным, но для разных типов клиента требуется дополнительная функциональность, ее можно определить в так называемых <firstterm>классах-компаньонах</firstterm>. </para>
          <para>Класс-компаньон располагается в модуле клиента соответствующего типа (<structname>web</structname> или <structname>desktop</structname>) и реализует интерфейс, задаваемый в использующем его контроллере. Класс компаньона задается в элементе <sgmltag>companions</sgmltag> XML-дескриптора экрана. Контроллер может получить ссылку на экземпляр компаньона с помощью инжекции или вызовом <code>getCompanion()</code>, и в нужный момент передать ему управление, например для дополнительной инициализации визуальных компонентов специфичным для данного типа клиента способом. </para>
        </section>
      </section>
    </section>
    <section id="gui_vcl">
      <title>Библиотека визуальных компонентов</title>
      <para><link linkend="gui_components">Компоненты</link></para>
      <para><link linkend="gui_layouts">Контейнеры</link></para>
      <section id="gui_components">
        <title>Компоненты</title>
        <figure>
          <title>Диаграмма компонентов</title>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/Components_new.png"/>
            </imageobject>
          </mediaobject>
        </figure>
        <para><code>Component</code> − предок всех визуальных компонентов. Он содержит базовые атрибуты, позволяющие идентифицировать компонент и располагать его на экране.</para>
        <informaltable frame="none" pgwide="0">
          <tgroup cols="2" colsep="1">
            <colspec colnum="1" colname="c0" colwidth="1*"/>
            <colspec colnum="2" colname="c1" colwidth="4*"/>
            <tbody valign="middle">
              <row>
                <entry>
                  <emphasis role="bold">Buttons</emphasis>
                </entry>
                <entry/>
              </row>
              <row>
                <entry align="left">
                  <link linkend="gui_Button">Button</link>
                </entry>
                <entry align="left">
                  <mediaobject>
                    <imageobject>
                      <imagedata fileref="img/Button.png"/>
                    </imageobject>
                  </mediaobject>
                </entry>
              </row>
              <row valign="middle">
                <entry align="left">
                  <link linkend="gui_PopupButton">PopupButton</link>
                </entry>
                <entry align="left">
                  <mediaobject>
                    <imageobject>
                      <imagedata fileref="img/PopupButton.png"/>
                    </imageobject>
                  </mediaobject>
                </entry>
              </row>
              <row>
                <entry align="left">
                  <link linkend="gui_LinkButton">LinkButton</link>
                </entry>
                <entry align="left">
                  <mediaobject>
                    <imageobject>
                      <imagedata fileref="img/LinkButton.png"/>
                    </imageobject>
                  </mediaobject>
                </entry>
              </row>
              <row>
                <entry/>
              </row>
              <row>
                <entry>
                  <emphasis role="bold">Text</emphasis>
                </entry>
                <entry/>
              </row>
              <row>
                <entry align="left">
                  <link linkend="gui_Label">Label</link>
                </entry>
                <entry align="left">
                  <mediaobject>
                    <imageobject>
                      <imagedata fileref="img/gui_label.png"/>
                    </imageobject>
                  </mediaobject>
                </entry>
              </row>
              <row>
                <entry/>
              </row>
              <row>
                <entry>
                  <emphasis role="bold">Text inputs</emphasis>
                </entry>
                <entry/>
              </row>
              <row>
                <entry align="left">
                  <link linkend="gui_TextField">TextField</link>
                </entry>
                <entry align="left">
                  <mediaobject>
                    <imageobject>
                      <imagedata fileref="img/gui_textField.png"/>
                    </imageobject>
                  </mediaobject>
                </entry>
              </row>
              <row>
                <entry align="left">
                  <link linkend="gui_TextArea">TextArea</link>
                </entry>
                <entry align="left">
                  <mediaobject>
                    <imageobject>
                      <imagedata fileref="img/gui_textArea.png"/>
                    </imageobject>
                  </mediaobject>
                </entry>
              </row>
              <row>
                <entry/>
              </row>
              <row>
                <entry>
                  <emphasis role="bold">Date inputs</emphasis>
                </entry>
                <entry/>
              </row>
              <row>
                <entry align="left">
                  <link linkend="gui_DateField">DateField</link>
                </entry>
                <entry align="left">
                  <mediaobject>
                    <imageobject>
                      <imagedata fileref="img/gui_dateField.png"/>
                    </imageobject>
                  </mediaobject>
                </entry>
              </row>
              <row>
                <entry align="left">
                  <link linkend="gui_TimeField">TimeField</link>
                </entry>
                <entry align="left">
                  <mediaobject>
                    <imageobject>
                      <imagedata fileref="img/gui_timeField1.png"/>
                    </imageobject>
                  </mediaobject>
                </entry>
              </row>
              <row>
                <entry/>
              </row>
              <row>
                <entry>
                  <emphasis role="bold">Selects</emphasis>
                </entry>
                <entry/>
              </row>
              <row>
                <entry align="left">
                  <link linkend="gui_CheckBox">CheckBox</link>
                </entry>
                <entry align="left">
                  <mediaobject>
                    <imageobject>
                      <imagedata fileref="img/CheckBox.png"/>
                    </imageobject>
                  </mediaobject>
                </entry>
              </row>
              <row>
                <entry align="left">
                  <link linkend="gui_PickerField">PickerField</link>
                </entry>
                <entry align="left">
                  <mediaobject>
                    <imageobject>
                      <imagedata fileref="img/PickerField.png"/>
                    </imageobject>
                  </mediaobject>
                </entry>
              </row>
              <row>
                <entry align="left">
                  <link linkend="gui_OptionsGroup">OptionsGroup</link>
                </entry>
                <entry align="left">
                  <mediaobject>
                    <imageobject>
                      <imagedata fileref="img/gui_optionsGroup.png"/>
                    </imageobject>
                  </mediaobject>
                </entry>
              </row>
              <row>
                <entry align="left">
                  <link linkend="gui_LookupField">LookupField</link>
                </entry>
                <entry align="left">
                  <mediaobject>
                    <imageobject>
                      <imagedata fileref="img/LookupField.png"/>
                    </imageobject>
                  </mediaobject>
                </entry>
              </row>
              <row>
                <entry align="left">
                  <link linkend="gui_LookupPickerField">LookupPickerField</link>
                </entry>
                <entry align="left">
                  <mediaobject>
                    <imageobject>
                      <imagedata fileref="img/LookupPickerField.png"/>
                    </imageobject>
                  </mediaobject>
                </entry>
              </row>
              <row>
                <entry align="left">
                  <link linkend="gui_SearchPickerField">SearchPickerField</link>
                </entry>
                <entry align="left">
                  <mediaobject>
                    <imageobject>
                      <imagedata fileref="img/gui_searchPickerField.png"/>
                    </imageobject>
                  </mediaobject>
                </entry>
              </row>
              <row>
                <entry align="left">
                  <link linkend="gui_TwinColumn">TwinColumn</link>
                </entry>
                <entry align="left">
                  <mediaobject>
                    <imageobject>
                      <imagedata fileref="img/TwinColumn.png"/>
                    </imageobject>
                  </mediaobject>
                </entry>
              </row>
              <row>
                <entry/>
              </row>
              <row>
                <entry>
                  <emphasis role="bold">Uploads</emphasis>
                </entry>
                <entry/>
              </row>
              <row>
                <entry align="left">
                  <link linkend="gui_FileUploadField">FileUploadField</link>
                </entry>
                <entry align="left">
                  <mediaobject>
                    <imageobject>
                      <imagedata fileref="img/Upload.png"/>
                    </imageobject>
                  </mediaobject>
                </entry>
              </row>
              <row>
                <entry/>
              </row>
              <row>
                <entry>
                  <emphasis role="bold">Tables and trees</emphasis>
                </entry>
                <entry/>
              </row>
              <row>
                <entry align="left">
                  <link linkend="gui_Table">Table</link>
                </entry>
                <entry align="left">
                  <mediaobject>
                    <imageobject>
                      <imagedata fileref="img/gui_table.png"/>
                    </imageobject>
                  </mediaobject>
                </entry>
              </row>
              <row>
                <entry align="left">
                  <link linkend="gui_TreeTable">TreeTable</link>
                </entry>
                <entry align="left">
                  <mediaobject>
                    <imageobject>
                      <imagedata fileref="img/gui_treeTable.png"/>
                    </imageobject>
                  </mediaobject>
                </entry>
              </row>
              <row>
                <entry align="left">
                  <link linkend="gui_GroupTable">GroupTable</link>
                </entry>
                <entry align="left">
                  <mediaobject>
                    <imageobject>
                      <imagedata fileref="img/GroupTable.png"/>
                    </imageobject>
                  </mediaobject>
                </entry>
              </row>
              <row>
                <entry align="left">
                  <link linkend="gui_Tree">Tree</link>
                </entry>
                <entry align="left">
                  <mediaobject>
                    <imageobject>
                      <imagedata fileref="img/Tree.png"/>
                    </imageobject>
                  </mediaobject>
                </entry>
              </row>
              <row>
                <entry/>
              </row>
              <row>
                <entry>
                  <emphasis role="bold">Others</emphasis>
                </entry>
                <entry/>
              </row>
              <row>
                <entry align="left">
                  <link linkend="gui_FieldGroup">FieldGroup</link>
                </entry>
                <entry align="left">
                  <mediaobject>
                    <imageobject>
                      <imagedata fileref="img/gui_fieldGroup.png"/>
                    </imageobject>
                  </mediaobject>
                </entry>
              </row>
              <row>
                <entry align="left">
                  <link linkend="gui_TokenList">TokenList</link>
                </entry>
                <entry align="left">
                  <mediaobject>
                    <imageobject>
                      <imagedata fileref="img/gui_tokenList.png"/>
                    </imageobject>
                  </mediaobject>
                </entry>
              </row>
              <row>
                <entry align="left">
                  <link linkend="gui_Filter">GenericFilter</link>
                </entry>
                <entry align="left">
                  <mediaobject>
                    <imageobject>
                      <imagedata fileref="img/gui_filter_mini.png"/>
                    </imageobject>
                  </mediaobject>
                </entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
        <section id="gui_Button">
          <title>Button</title>
          <para>Кнопка (<code>Button</code>) −  компонент,  обеспечивающий  выполнение некоторых действий при нажатии на нее пользователем.</para>
          <para>XML-имя компонента: <sgmltag>button</sgmltag></para>
          <figure>
            <title/>
            <mediaobject>
              <imageobject>
                <imagedata contentwidth="80%" align="center" fileref="img/gui_Button_dia.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>Компонент кнопки реализован для блоков <structname>Web Client</structname> и <structname>Desktop Client</structname>.</para>
          <para>Кнопка может содержать  текст или пиктограмму (или и то и другое). На рисунке ниже отображены разные виды кнопок.</para>
          <figure>
            <title>Типы кнопок</title>
            <mediaobject>
              <imageobject>
                <imagedata contentwidth="233" contentdepth="128" align="center" fileref="img/gui_buttonTypes.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <itemizedlist>
            <listitem>
              <para>Пример кнопки с названием, взятым из <link linkend="message_packs">пакета локализованных сообщений</link>, и с всплывающей подсказкой:</para>
              <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/button/textButton.txt" encoding="UTF-8" parse="text"/></programlisting>
              <para>Название кнопки задается с помощью атрибута <link linkend="gui_attr_basic_caption">caption</link>, всплывающая подсказка − с помощью атрибута <link linkend="gui_attr_basic_description">description</link>.</para>
            </listitem>
            <listitem>
              <para>Пример создания кнопки с пиктограммой:</para>
              <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/button/iconButton.txt" encoding="UTF-8" parse="text"/></programlisting>
              <para>Атрибут <link linkend="gui_attr_basic_icon">icon</link> указывает на местоположение пиктограммы. Подробную информацию о том, где следует располагать файлы пиктограмм, Вы можете прочитать в <xref linkend="gui_themes"/></para>
            </listitem>
            <listitem>
              <para id="gui_attr_button_stylename">Для создания кнопки с пользовательским стилем необходимо указать атрибут <link linkend="gui_attr_basic_stylename">stylename</link>, а также задать стиль компонента в файле <filename>CSS</filename>.</para>
              <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/button/userButton.txt" encoding="UTF-8" parse="text"/></programlisting>
              <para>Определение стиля:</para>
              <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/button/cssButton.txt" encoding="UTF-8" parse="text"/></programlisting>
              <para>Подробную информацию о том, как создавать пользовательский стиль, Вы можете прочитать в <xref linkend="gui_themes"/></para>
            </listitem>
          </itemizedlist>
          <para id="gui_attr_button_invoke">Основная функция кнопки −  выполнить некоторое действие при нажатии на нее. Определить метод <glossterm linkend="screen_controller_glossentry">контроллера</glossterm>, который будет вызываться при нажатии на кнопку, можно с помощью атрибута <sgmltag>invoke</sgmltag>. Значением атрибута должно быть    имя  метода контроллера, вызываемого в ответ на событие нажатия кнопки. Метод должен:</para>
          <itemizedlist>
            <listitem>
              <para>Быть <code>public</code></para>
            </listitem>
            <listitem>
              <para>Возвращать <code>void</code></para>
            </listitem>
            <listitem>
              <para>Не иметь аргументов или иметь один аргумент типа <code>Component</code>. Если метод имеет аргумент <code>Component</code>, то при вызове в него будет передан экземпляр вызвавшей кнопки.</para>
            </listitem>
          </itemizedlist>
          <para>В качестве примера показано описание кнопки, вызывающей метод <code>someMethod:</code></para>
          <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/button/invokeButton.txt" encoding="UTF-8" parse="text"/></programlisting>
          <para>В <glossterm linkend="screen_controller_glossentry">контроллере</glossterm> экрана необходимо определить метод <code>someMethod</code>:</para>
          <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/button/methodButton.txt" encoding="UTF-8" parse="text"/></programlisting>
          <para id="gui_attr_button_action">Атрибут <sgmltag>invoke</sgmltag> игнорируется, если для кнопки задан атрибут <sgmltag>action</sgmltag>. Атрибут <sgmltag>action</sgmltag> содержит имя <link linkend="gui_Action">Action</link>, соответствующего данной кнопке.</para>
          <para>Пример кнопки с атрибутом <sgmltag>action</sgmltag>:</para>
          <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/button/actionButton.txt" encoding="UTF-8" parse="text"/></programlisting>
          <para><link linkend="gui_Action">Action</link> для кнопки можно создавать программно, в <glossterm linkend="screen_controller_glossentry">контроллере</glossterm> экрана.</para>
          <para>В качестве примера создадим кнопку, имеющую в <glossterm linkend="screen_xml_glossentry">xml-дескрипторе</glossterm> только атрибут <link linkend="gui_attr_basic_id">id</link>:</para>
          <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/button/withoutActionButton.txt" encoding="UTF-8" parse="text"/></programlisting>
          <para>В контроллере  в методе <code>init()</code> экрана определим действие и название для кнопки.</para>
          <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/button/withoutActionButtonContr.txt" encoding="UTF-8" parse="text"/></programlisting>
          <para>Атрибуты <sgmltag>button</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_button_action">action</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_enable">enable</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_button_stylename">stylename</link>
                  </entry>
                </row>
                <row>
                  <entry>
                    <link linkend="gui_attr_basic_align">align</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_icon">icon</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_visible">visible</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_caption">caption</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_id">id</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_width">width</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_description">description</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_button_invoke">invoke</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
        </section>
        <section id="gui_PopupButton">
          <title>PopupButton</title>
          <para>Кнопка с выпадающим списком действий.</para>
          <para>XML-имя компонента: <sgmltag>popupButton</sgmltag>.</para>
          <figure>
            <title/>
            <mediaobject>
              <imageobject>
                <imagedata contentwidth="80%" align="center" fileref="img/gui_popupButton_dia.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>Компонент реализован для блоков <structname>Web Client</structname> и <structname>Desktop Client</structname>.</para>
          <para>Кнопка с выпадающим списком действий может содержать  текст или пиктограмму (или и то и другое). На рисунке ниже отражены разные виды кнопок.</para>
          <figure>
            <title>Типы кнопок</title>
            <mediaobject>
              <imageobject>
                <imagedata contentwidth="154" contentdepth="125" align="center" fileref="img/gui_popupButtonTypes.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>Пример кнопки с выпадающим списком, содержащим два действия: </para>
          <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/popupButton/textPopupButton.txt" encoding="UTF-8" parse="text"/></programlisting>
          <para>Кнопка имеет название, заданное с помощью атрибута <link linkend="gui_attr_basic_caption">caption</link>, и всплывающую подсказку, определенную в атрибуте <link linkend="gui_attr_basic_description">description</link>.</para>
          <para>Кнопка <code>popupButton</code> содержит выпадающий список действий,  которые задаются в элементе <link linkend="gui_Action">actions</link>.</para>
          <figure>
            <title>Кнопка с выпадающим списком действий</title>
            <mediaobject>
              <imageobject>
                <imagedata contentwidth="107" contentdepth="73" align="center" fileref="img/PopupButton.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>Пример кнопки с пиктограммой (пиктограмма задается в атрибуте <link linkend="gui_attr_basic_icon">icon</link>):</para>
          <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/popupButton/iconPopupButton.txt" encoding="UTF-8" parse="text"/></programlisting>
          <para>Атрибуты <sgmltag>popupButton</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_align">align</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_icon">icon</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_width">width</link>
                  </entry>
                </row>
                <row>
                  <entry>
                    <link linkend="gui_attr_basic_caption">caption</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_id">id</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_description">description</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_stylename">stylename</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_enable">enable</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_visible">visible</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
          <para>Элементы <sgmltag>popupButton</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="1" colsep="1" rowsep="1" align="left">
              <colspec colname="c1"/>
              <tbody>
                <row>
                  <entry align="left">
                    <link linkend="gui_Action">actions</link>
                  </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </section>
        <section id="gui_LinkButton">
          <title>LinkButton</title>
          <para>Кнопка-ссылка (<code>LinkButton</code>) − кнопка, выглядящая как гиперссылка.</para>
          <para>XML-имя компонента: <sgmltag>linkButton</sgmltag></para>
          <figure>
            <title/>
            <mediaobject>
              <imageobject>
                <imagedata contentwidth="70%" align="center" fileref="img/gui_linkButton_dia.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>Компонент кнопки-ссылки реализован для блоков <structname>Web Client</structname> и <structname>Desktop Client</structname>.</para>
          <para>Кнопка-ссылка  может содержать  текст или пиктограмму (или и то и другое). На рисунке ниже отражены разные виды кнопок.</para>
          <figure>
            <title>Типы кнопок-ссылок</title>
            <mediaobject>
              <imageobject>
                <imagedata contentwidth="130" contentdepth="127" align="center" fileref="img/gui_linkButtonTypes.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>Пример описания кнопки-ссылки в <link linkend="screen_xml_glossentry">xml-дескрипторе</link>. Кнопка имеет название (атрибут <link linkend="gui_attr_basic_caption">caption</link>) и всплывающую подсказку (атрибут <link linkend="gui_attr_basic_description">description</link>): </para>
          <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/linkButton/textLinkButton.txt" encoding="UTF-8" parse="text"/></programlisting>
          <para>Пример кнопки-ссылки с пиктограммой (атрибут <link linkend="gui_attr_basic_icon">icon</link>):</para>
          <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/linkButton/iconLinkButton.txt" encoding="UTF-8" parse="text"/></programlisting>
          <para>Для кнопки-ссылки, также как и для обычной кнопки (<link linkend="gui_Button">Button</link>), можно в атрибуте <link linkend="gui_attr_button_invoke">invoke</link> задать метод <glossterm linkend="screen_controller_glossentry">контроллера</glossterm>, который будет вызываться при нажатии на нее.</para>
          <para>В качестве примера показано описание кнопки, вызывающей метод <code>someMethod:</code></para>
          <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/linkButton/invokeLinkButton.txt" encoding="UTF-8" parse="text"/></programlisting>
          <para>В <glossterm linkend="screen_controller_glossentry">контроллере</glossterm> экрана необходимо определить метод <code>someMethod</code>:</para>
          <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/linkButton/methodLinkButton.txt" encoding="UTF-8" parse="text"/></programlisting>
          <para>Атрибуты <sgmltag>linkButton</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_button_action">action</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_enable">enable</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_button_stylename">stylename</link>
                  </entry>
                </row>
                <row>
                  <entry>
                    <link linkend="gui_attr_basic_align">align</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_icon">icon</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_visible">visible</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_caption">caption</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_id">id</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_width">width</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_description">description</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_button_invoke">invoke</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
        </section>
        <section id="gui_Label">
          <title>Label</title>
          <para>Надпись (<code>Label</code>) − текстовый компонент, отображающий  статический текст либо значение атрибута <glossterm linkend="entity">сущности</glossterm>.</para>
          <para>XML-имя компонента: <sgmltag>label</sgmltag></para>
          <figure>
            <title/>
            <mediaobject>
              <imageobject>
                <imagedata contentwidth="80%" align="center" fileref="img/gui_label_dia.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>Компонент <code>Label</code> реализован для блоков <structname>Web Client</structname> и <structname>Desktop Client</structname>.</para>
          <figure>
            <title>Простая надпись</title>
            <mediaobject>
              <imageobject>
                <imagedata align="center" fileref="img/gui_labelOrders.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>Пример компонента надписи с текстом, взятым из <link linkend="message_packs">пакета локализованных сообщений</link>:</para>
          <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/label/label.txt" encoding="UTF-8" parse="text"/></programlisting>
          <itemizedlist>
            <listitem>
              <para id="gui_attr_label_value">Атрибут <sgmltag>value</sgmltag> предназначен для отображения текста надписи. Обычно значение атрибута задается с помощью ключа <link linkend="message_packs">пакета сообщений</link>. </para>
            </listitem>
            <listitem>
              <para>Текст, содержащийся в атрибуте <sgmltag>value</sgmltag>, будет перенесен на следующую строку, если по длине он превысит значение атрибута <link linkend="gui_attr_basic_width">width</link>. Поэтому если Вам нужно использовать многострочную надпись, укажите требуемое значение атрибута <link linkend="gui_attr_basic_width">width</link> (применимо только для веб-приложений). Если текст надписи слишком длинный, и значение атрибута <link linkend="gui_attr_basic_width">width</link> не определено, то текст будет урезан.</para>
              <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/label/labelWrapped.txt" encoding="UTF-8" parse="text"/></programlisting>
              <figure>
                <title/>
                <mediaobject>
                  <imageobject>
                    <imagedata align="center" fileref="img/gui_label_truncated.png"/>
                  </imageobject>
                </mediaobject>
              </figure>
            </listitem>
          </itemizedlist>
          <para>В компоненте надписи есть возможность отображать значение атрибута сущности. Для этого используются атрибуты <link linkend="gui_attr_basic_datasource">datasource</link> и <link linkend="gui_attr_basic_property">property</link>.</para>
          <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/label/labelWithDatasource.txt" encoding="UTF-8" parse="text"/></programlisting>
          <para>Как видно из примера, предварительно создается источник данных <literal>customerDs</literal> для некоторой сущности <code>Customer</code>, имеющей атрибут  <code>name</code>. В компоненте надписи в  атрибуте <link linkend="gui_attr_basic_datasource">datasource</link> указывается ссылка на созданный ранее источник данных, а в атрибуте <link linkend="gui_attr_basic_property">property</link> − название поля сущности, которое должно быть отображено в компоненте надписи.</para>
          <para>Атрибуты <sgmltag>label</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_align">align</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_property">property</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_width">width</link>
                  </entry>
                </row>
                <row>
                  <entry>
                    <link linkend="gui_attr_basic_datasource">datasource</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_stylename">stylename</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_height">height</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_label_value">value</link>
                  </entry>
                  <entry/>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_id">id</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_visible">visible</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
          <para>Элементы <sgmltag>label</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="1" colsep="1" rowsep="1" align="left">
              <colspec colname="c1"/>
              <tbody>
                <row>
                  <entry align="left">
                    <link linkend="gui_element_basic_formatter">formatter</link>
                  </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </section>
        <section id="gui_TextField">
          <title>TextField</title>
          <para>Поле для редактирования текста.</para>
          <para>XML-имя компонента: <sgmltag>textField</sgmltag></para>
          <figure>
            <title/>
            <mediaobject>
              <imageobject>
                <imagedata contentwidth="80%" align="center" fileref="img/gui_textField_dia.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>Компонент текстового поля реализован для блоков <structname>Web Client</structname> и <structname>Desktop Client</structname>.</para>
          <para>Текстовое поле служит для обеспечения возможности получить текстовую информацию от пользователя, а также для отображения атрибутов <glossterm linkend="entity">сущности</glossterm>.</para>
          <itemizedlist>
            <listitem>
              <para>Пример текстового поля с заголовком, взятым из <link linkend="message_packs">пакета локализованных сообщений</link>:</para>
              <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/textField/textField.txt" encoding="UTF-8" parse="text"/></programlisting>
              <para>На рисунке ниже показан вид простого текстового поля.</para>
              <figure>
                <title/>
                <mediaobject>
                  <imageobject>
                    <imagedata contentwidth="180" align="center" fileref="img/gui_textField.png"/>
                  </imageobject>
                </mediaobject>
              </figure>
            </listitem>
            <listitem>
              <para>Для создания текстового поля, связанного с данными, необходимо использовать атрибуты <link linkend="gui_attr_basic_datasource">datasource</link> и <link linkend="gui_attr_basic_property">property</link>.</para>
              <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/textField/textFieldDatasource.txt" encoding="UTF-8" parse="text"/></programlisting>
              <para>Как видно из примера, предварительно создается источник данных <literal>customerDs</literal> для некоторой сущности <code>Покупатель (Customer)</code>, имеющей атрибут <code>name</code>. В компоненте текстового поля  в атрибуте <link linkend="gui_attr_basic_datasource">datasource</link> указывается ссылка на созданный ранее источник данных, а в атрибуте <link linkend="gui_attr_basic_property">property</link> − название поля сущности, которое должно быть отображено в текстовом поле.</para>
              <figure>
                <title/>
                <mediaobject>
                  <imageobject>
                    <imagedata align="center" fileref="img/gui_textField_data.png"/>
                  </imageobject>
                </mediaobject>
              </figure>
            </listitem>
            <listitem>
              <para id="gui_attr_textField_datatype">Если поле не связано с источником данных (то есть не указан источник данных и название атрибута), можно связать текстовое поле  с типом данных с помощью атрибута <sgmltag>datatype</sgmltag>. Атрибут используется  для форматирования значения поля. Значением атрибута <sgmltag>datatype</sgmltag> является имя типа данных из списка:</para>
              <itemizedlist>
                <listitem>
                  <para><literal>boolean</literal></para>
                </listitem>
                <listitem>
                  <para><literal>byte array</literal></para>
                </listitem>
                <listitem>
                  <para><literal>date</literal></para>
                </listitem>
                <listitem>
                  <para><literal>decimal</literal></para>
                </listitem>
                <listitem>
                  <para><literal>double</literal></para>
                </listitem>
                <listitem>
                  <para><literal>int</literal></para>
                </listitem>
                <listitem>
                  <para><literal>long</literal></para>
                </listitem>
                <listitem>
                  <para><literal>string</literal></para>
                </listitem>
                <listitem>
                  <para><literal>uuid</literal></para>
                </listitem>
              </itemizedlist>
              <para>В качестве примера рассмотрим текстовое поле, связанное с типом данных <literal>Integer</literal>. </para>
              <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/textField/textFieldInt.txt" encoding="UTF-8" parse="text"/></programlisting>
              <para>При переходе из  текстового поля, в котором введено  значение, не  являющееся типом данных <literal>Integer</literal>, приложение выдаст сообщение об ошибке и очистит текстовое поле.</para>
              <figure>
                <title/>
                <mediaobject>
                  <imageobject>
                    <imagedata contentwidth="452" contentdepth="133" align="center" fileref="img/gui_textField_int.png"/>
                  </imageobject>
                </mediaobject>
              </figure>
            </listitem>
            <listitem>
              <para id="gui_attr_textField_cols_rows">Текстовому полю можно задавать количество строк и столбцов текста с помощью атрибутов <sgmltag>cols</sgmltag> и <sgmltag>rows</sgmltag>.</para>
              <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/textField/textFieldColsRows.txt" encoding="UTF-8" parse="text"/></programlisting>
              <figure>
                <title/>
                <mediaobject>
                  <imageobject>
                    <imagedata contentwidth="450" contentdepth="96" align="center" fileref="img/gui_textFieldColsRows.png"/>
                  </imageobject>
                </mediaobject>
              </figure>
            </listitem>
            <listitem>
              <para id="gui_attr_textField_maxLength">Для текстового компонента можно ограничить максимальную длину вводимого текста с помощью атрибута <sgmltag>maxLength</sgmltag>. Значение атрибута устанавливается по умолчанию на основании длины строкового атрибута <glossterm linkend="entity">сущности</glossterm>, если этот параметр указан в аннотации сущности. Значение &quot;-1&quot; означает отсутствие ограничения.</para>
              <para>Ниже показан пример, ограничивающий длину вводимого текста в 10 символов.</para>
              <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/textField/textFieldMaxLength.txt" encoding="UTF-8" parse="text"/></programlisting>
            </listitem>
            <listitem>
              <para id="gui_attr_textField_resizable">Для компонента <code>textField</code> существует атрибут <sgmltag>resizable</sgmltag>. При задании атрибуту значения <literal>true</literal> и установке количества строк, больших одной, у пользователя появляется возможность  изменять размеры компонента.</para>
              <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/textField/textFieldResizable.txt" encoding="UTF-8" parse="text"/></programlisting>
              <figure>
                <title/>
                <mediaobject>
                  <imageobject>
                    <imagedata contentwidth="330" align="center" fileref="img/gui_textField_resizable.png"/>
                  </imageobject>
                </mediaobject>
              </figure>
            </listitem>
            <listitem>
              <para id="gui_attr_textField_trim">Для отсечения лишних пробелов в начале и конце значения используется атрибут <sgmltag>trim</sgmltag>. По умолчанию значение атрибута равно <literal>true</literal>. Пробелы отсекаются в момент получения значения поля с помощью метода доступа.</para>
              <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/textField/textFieldTrim.txt" encoding="UTF-8" parse="text"/></programlisting>
              <para>В <glossterm linkend="screen_controller_glossentry">контроллере</glossterm> экрана определяем метод, который будет вызываться при нажатии на <link linkend="gui_Button">кнопку</link>.</para>
              <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/textField/textFieldTrimContr.txt" encoding="UTF-8" parse="text"/></programlisting>
            </listitem>
            <listitem>
              <para id="gui_attr_textField_secret">Атрибут <sgmltag>secret</sgmltag> позволяет преобразовать текстовое поле в  поле, которое не показывает символы, введенные пользователем. Вместо этого поле отображает эхо-символы, отличные от введенных. </para>
              <para>Текстовое поле с атрибутом <code>secret=&quot;true&quot;</code>  скрывает введенные данные только в визуальном представлении. При получении значения поля с помощью метода доступа это значение представляется в текстовой форме.</para>
              <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/textField/textFieldSecret.txt" encoding="UTF-8" parse="text"/></programlisting>
              <para>В <glossterm linkend="screen_controller_glossentry">контроллере</glossterm> экрана определяем метод, который будет вызываться при нажатии на <link linkend="gui_Button">кнопку</link>.</para>
              <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/textField/textFieldSecretContr.txt" encoding="UTF-8" parse="text"/></programlisting>
              <figure>
                <title/>
                <mediaobject>
                  <imageobject>
                    <imagedata align="center" fileref="img/gui_textField_secret.png"/>
                  </imageobject>
                </mediaobject>
              </figure>
            </listitem>
          </itemizedlist>
          <para>Атрибуты <sgmltag>textField</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row><entry align="left">
                    <link linkend="gui_attr_basic_caption">caption</link>
                  </entry>editable<entry align="left">
                    <link linkend="gui_attr_basic_editable">editable</link>
                  </entry><entry align="left">
                    <link linkend="gui_attr_basic_property">property</link>
                  </entry><entry>
                    <link linkend="gui_attr_textField_secret">secret</link>
                  </entry></row>
                <row>
                  <entry>
                    <link linkend="gui_attr_textField_cols_rows">cols</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_enable">enable</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_textField_resizable">resizable</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_stylename">stylename</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_datasource">datasource</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_height">height</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_required">required</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_textField_trim">trim</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_textField_datatype">datatype</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_id">id</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_requiredMessage">requiredMessage</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_visible">visible</link>
                  </entry>
                </row>
                <row>
                  <entry>
                    <link linkend="gui_attr_basic_description">description</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_textField_maxLength">maxLength</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_textField_cols_rows">rows</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_width">width</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
          <para>Элементы <sgmltag>textField</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="1" colsep="1" rowsep="1" align="left">
              <colspec colname="c1"/>
              <tbody>
                <row>
                  <entry align="left">
                    <link linkend="gui_element_basic_formatter">formatter</link>
                  </entry>
                </row>
                <row>
                  <entry>
                    <link linkend="gui_element_basic_validator">validator</link>
                  </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </section>
        <section id="gui_TextArea">
          <title>TextArea</title>
          <para>Текстовая область (<code>TextArea</code>) − многострочное текстовое поле для редактирования текста. Содержит элементы управления для форматирования текста.</para>
          <para>XML-имя компонента: <sgmltag>textArea</sgmltag></para>
          <figure>
            <title/>
            <mediaobject>
              <imageobject>
                <imagedata contentwidth="180" align="center" fileref="img/gui_textArea_dia.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>Компонент текстовой области реализован только для блока <structname>Web Client</structname>.</para>
          <para>К тексту, вводимому в компоненте <code>TextArea</code>, можно применять средства для форматирования: изменять начертание шрифта, его размер, гарнитуру − с помощью элементов управления, расположенных в верхней части компонента.</para>
          <figure>
            <title/>
            <mediaobject>
              <imageobject>
                <imagedata contentwidth="473" align="center" fileref="img/gui_textAreaInfo.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>Атрибуты <sgmltag>textArea</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row><entry align="left">
                    <link linkend="gui_attr_basic_caption">caption</link>
                  </entry>editable<entry align="left">
                    <link linkend="gui_attr_basic_editable">editable</link>
                  </entry><entry align="left">
                    <link linkend="gui_attr_basic_property">property</link>
                  </entry><entry>
                    <link linkend="gui_attr_basic_stylename">stylename</link>
                  </entry></row>
                <row>
                  <entry>
                    <link linkend="gui_attr_textField_cols_rows">cols</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_enable">enable</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_required">required</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_visible">visible</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_datasource">datasource</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_height">height</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_requiredMessage">requiredMessage</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_width">width</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_description">description</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_id">id</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_textField_cols_rows">rows</link>
                  </entry>
                  <entry/>
                </row>
              </tbody></tgroup>
          </informaltable>
          <para>Элементы <sgmltag>textArea</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="1" colsep="1" rowsep="1" align="left">
              <colspec colname="c1"/>
              <tbody>
                <row>
                  <entry align="left">
                    <link linkend="gui_element_basic_formatter">formatter</link>
                  </entry>
                </row>
                <row>
                  <entry>
                    <link linkend="gui_element_basic_validator">validator</link>
                  </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </section>
        <section id="gui_DateField">
          <title>DateField</title>
          <para>Поле для отображения или ввода даты и времени. В самом простом варианте представляет собой поле для отображения даты, справа от него находится кнопка с выпадающим календарем, правее находится поле для ввода времени.</para>
          <figure>
            <title/>
            <mediaobject>
              <imageobject>
                <imagedata contentwidth="80%" align="center" fileref="img/gui_dateFieldSimple.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>Дата и время по умолчанию отображаются в формате, соответствующем выбранной локали.</para>
          <para>XML-имя компонента: <sgmltag>dateField</sgmltag>.</para>
          <figure>
            <title/>
            <mediaobject>
              <imageobject>
                <imagedata contentwidth="80%" align="center" fileref="img/gui_dateField_dia.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>Компонент реализован для блоков <structname>Web Client</structname> и <structname>Desktop Client</structname><itemizedlist>
              <listitem>
                <para>Для создания  поля даты, связанного с <link linkend="datasources">источником данных</link>, необходимо определить его описание в <glossterm linkend="screen_xml_glossentry">xml-дескрипторе</glossterm> следующим образом:</para>
                <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/dateField/dateField.txt" encoding="UTF-8" parse="text"/></programlisting>
                <para>В примере предварительно создается источник данных <literal>orderDs</literal> для некоторой сущности <code>Заказ (Order)</code>, имеющей атрибут <code>date</code>. В компоненте ввода даты   в атрибуте <link linkend="gui_attr_basic_datasource">datasource</link> указывается ссылка на созданный ранее источник данных, а в атрибуте <link linkend="gui_attr_basic_property">property</link> − название поля сущности, которое должно быть отображено в  поле.</para>
              </listitem>
              <listitem>
                <para id="gui_attr_dateField_dateFormat">Возможно изменить формат представления даты и времени с помощью атрибута  <sgmltag>dateFormat</sgmltag> по правилам  SimpleDateFormat (<ulink url="http://docs.oracle.com/javase/6/docs/api/java/text/SimpleDateFormat.html">http://docs.oracle.com/javase/6/docs/ api/java/text/SimpleDateFormat.html</ulink>). Значением атрибута может быть либо строка формата, либо ключ в пакете сообщений (если строка начинается с msg://)</para>
                <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/dateField/dateFieldFormat.txt" encoding="UTF-8" parse="text"/></programlisting>
                <figure>
                  <title/>
                  <mediaobject>
                    <imageobject>
                      <imagedata contentwidth="210" align="center" fileref="img/gui_dateField_format.png"/>
                    </imageobject>
                  </mediaobject>
                </figure>
              </listitem>
              <listitem>
                <para id="gui_attr_dateField_resolution">В большинстве бизнес-приложений нет необходимости отображать милисекунды или даже время.  Точность представления даты или времени контролируется атрибутом <sgmltag>resolution</sgmltag>.  Значение атрибута должно соответствовать перечислению <code>DateField.Resolution</code> − <literal>SEC</literal>, <literal>MIN</literal>, <literal>HOUR</literal>, <literal>DAY</literal>, <literal>MONTH</literal>, <literal>YEAR</literal>. По умолчанию точность определяется по аннотации <code>javax.persistence.Temporal</code> соответствующего атрибута <glossterm linkend="entity">сущности</glossterm>.</para>
                <para>Если <code>resolution=&quot;DAY&quot;</code> и не указан атрибут <sgmltag>dateFormat</sgmltag>, то в качестве формата будет взят формат, указанный в <link linkend="main_message_pack">главном пакете сообщений</link> с ключом <sgmltag>dateFormat</sgmltag>.</para>
                <para>Если <code>resolution=&quot;MIN&quot;</code> и не указан атрибут <sgmltag>dateFormat</sgmltag>, то в качестве формата будет взят формат, указанный в <link linkend="main_message_pack">главном пакете сообщений</link> с ключом <sgmltag>dateTimeFormat</sgmltag>.</para>
                <para>Ниже показано определения поля для ввода даты с точностью до месяца.</para>
                <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/dateField/dateFieldResolution.txt" encoding="UTF-8" parse="text"/></programlisting>
                <figure>
                  <title/>
                  <mediaobject>
                    <imageobject>
                      <imagedata contentwidth="350" align="center" fileref="img/gui_dateField_resolution.png"/>
                    </imageobject>
                  </mediaobject>
                </figure>
              </listitem>
            </itemizedlist>.</para>
          <para>Атрибуты <sgmltag>dateField</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row><entry align="left">
                    <link linkend="gui_attr_basic_caption">caption</link>
                  </entry>editable<entry align="left">
                    <link linkend="gui_attr_basic_editable">editable</link>
                  </entry><entry align="left">
                    <link linkend="gui_attr_basic_property">property</link>
                  </entry><entry>
                    <link linkend="gui_attr_basic_stylename">stylename</link>
                  </entry></row>
                <row>
                  <entry>
                    <link linkend="gui_attr_basic_datasource">datasource</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_enable">enable</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_required">required</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_visible">visible</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_dateField_dateFormat">dateFormat</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_height">height</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_requiredMessage">requiredMessage</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_width">width</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_description">description</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_id">id</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_dateField_resolution">resolution</link>
                  </entry>
                  <entry/>
                </row>
              </tbody></tgroup>
          </informaltable>
          <para>Элементы <sgmltag>dateField</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="1" colsep="1" rowsep="1" align="left">
              <colspec colname="c1"/>
              <tbody>
                <row>
                  <entry>
                    <link linkend="gui_element_basic_validator">validator</link>
                  </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </section>
        <section id="gui_TimeField">
          <title>TimeField</title>
          <para>Поле для отображения или ввода времени. В самом простом варианте представляет собой поле для отображения или ввода времени в часах и минутах.</para>
          <figure>
            <title/>
            <mediaobject>
              <imageobject>
                <imagedata contentwidth="142" align="center" fileref="img/gui_timeField.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>XML-имя компонента: <sgmltag>timeField</sgmltag>.</para>
          <figure>
            <title/>
            <mediaobject>
              <imageobject>
                <imagedata contentwidth="80%" align="center" fileref="img/gui_timeField_dia.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>Компонент реализован для блоков <structname>Web Client</structname> и <structname>Desktop Client</structname>.</para>
          <itemizedlist>
            <listitem>
              <para>Для создания простого  поля для ввода времени необходимо определить его в <glossterm linkend="screen_xml_glossentry">xml-дескрипторе</glossterm> следующим образом:</para>
              <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/timeField/timeField.txt" encoding="UTF-8" parse="text"/></programlisting>
              <para>В примере предварительно создается источник данных <literal>orderDs</literal> для некоторой сущности <code>Заказ (Order)</code>, имеющей атрибут <code>date</code>. В компоненте ввода времени    в атрибуте <link linkend="gui_attr_basic_datasource">datasource</link> указывается ссылка на созданный ранее источник данных, а в атрибуте <link linkend="gui_attr_basic_property">property</link> − название поля сущности, которое должно быть отображено в  поле.</para>
            </listitem>
            <listitem>
              <para>Для создания поля времени, связанного с <link linkend="datasources">источником данных</link>, необходимо указать атрибуты <link linkend="gui_attr_basic_datasource">datasource</link> и <link linkend="gui_attr_basic_property">property</link> в определении поля:</para>
              <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/timeField/timeFieldDs.txt" encoding="UTF-8" parse="text"/></programlisting>
            </listitem>
            <listitem>
              <para id="gui_attr_timeField_showSeconds">С помощью установки атрибута <sgmltag>showSeconds</sgmltag> в значение <literal>true</literal> можно настроить отображение секунд.</para>
              <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/timeField/timeFieldSec.txt" encoding="UTF-8" parse="text"/></programlisting>
              <figure>
                <title/>
                <mediaobject>
                  <imageobject>
                    <imagedata contentwidth="235" align="center" fileref="img/gui_timeFieldSec.png"/>
                  </imageobject>
                </mediaobject>
              </figure>
            </listitem>
          </itemizedlist>
          <para>Атрибуты <sgmltag>timeField</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row><entry align="left">
                    <link linkend="gui_attr_basic_caption">caption</link>
                  </entry>editable<entry align="left">
                    <link linkend="gui_attr_basic_enable">enable</link>
                  </entry><entry align="left">
                    <link linkend="gui_attr_basic_required">required</link>
                  </entry><entry>
                    <link linkend="gui_attr_basic_visible">visible</link>
                  </entry></row>
                <row>
                  <entry>
                    <link linkend="gui_attr_basic_datasource">datasource</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_height">height</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_requiredMessage">requiredMessage</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_width">width</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_description">description</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_id">id</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_timeField_showSeconds">showSeconds</link>
                  </entry>
                  <entry/>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_editable">editable</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_property">property</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_stylename">stylename</link>
                  </entry>
                  <entry/>
                </row>
              </tbody></tgroup>
          </informaltable>
          <para>Элементы <sgmltag>timeField</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="1" colsep="1" rowsep="1" align="left">
              <colspec colname="c1"/>
              <tbody>
                <row>
                  <entry>
                    <link linkend="gui_element_basic_validator">validator</link>
                  </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </section>
        <section id="gui_CheckBox">
          <title>CheckBox</title>
          <para>Флажок (<code>CheckBox</code>) − компонент, имеющий два состояния: выбран, не выбран. Флажки используются
там, где нужно предоставить пользователю возможность что-то включить или
выключить.</para>
          <figure>
            <title/>
            <mediaobject>
              <imageobject>
                <imagedata contentwidth="170" align="center" fileref="img/CheckBox.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>XML-имя компонента: <sgmltag>checkBox</sgmltag>.</para>
          <figure>
            <title/>
            <mediaobject>
              <imageobject>
                <imagedata contentwidth="70%" align="center" fileref="img/gui_checkBox_dia.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>Компонент реализован для блоков <structname>Web Client</structname> и <structname>Desktop Client</structname>.</para>
          <para>Пример флажка с названием, взятым из <link linkend="message_packs">пакета локализованных сообщений</link>:</para>
          <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/checkBox/checkBox.txt" encoding="UTF-8" parse="text"/></programlisting>
          <para>Сброс или установка флажка изменяет его состояние. Состояние − это свойство типа <code>Boolean</code>, может быть получено с помощью метода  <code>getValue()</code> и установлено с помощью метода <code>setValue()</code>. </para>
          <para>При каждом изменении состояния флажка генерируется событие элемента, которое может быть обработано с помощью <code>ValueListener</code>.</para>
          <para>Ниже приведен код <glossterm linkend="screen_controller_glossentry">контроллера</glossterm>, демонстрирующий работу с флажком. При установке флажка на экране возникает сообщение <quote>Разрешить создание нового документа</quote>, при сбросе флажка − <quote>Не разрешать создание нового документа</quote>.</para>
          <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/checkBox/checkBoxContr.txt" encoding="UTF-8" parse="text"/></programlisting>
          <para>Атрибуты <sgmltag>checkBox</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row><entry align="left">
                    <link linkend="gui_attr_basic_align">align</link>
                  </entry>editable<entry align="left">
                    <link linkend="gui_attr_basic_editable">editable</link>
                  </entry><entry align="left">
                    <link linkend="gui_attr_basic_property">property</link>
                  </entry><entry/></row>
                <row>
                  <entry>
                    <link linkend="gui_attr_basic_caption">caption</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_enable">enable</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_stylename">stylename</link>
                  </entry>
                  <entry/>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_datasource">datasource</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_height">height</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_visible">visible</link>
                  </entry>
                  <entry/>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_description">description</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_id">id</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_width">width</link>
                  </entry>
                  <entry/>
                </row>
              </tbody></tgroup>
          </informaltable>
          <para>Элементы <sgmltag>checkBox</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="1" colsep="1" rowsep="1" align="left">
              <colspec colname="c1"/>
              <tbody>
                <row>
                  <entry>
                    <link linkend="gui_element_basic_validator">validator</link>
                  </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </section>
        <section id="gui_PickerField">
          <title>PickerField</title>
          <para>Поле ввода с дополнительными кнопками действий (<code>PickerField</code>) позволяет отображать экземпляр <glossterm linkend="entity">сущности</glossterm> в текстовом поле и выполнять действия нажатием на кнопки справа.</para>
          <figure>
            <title/>
            <mediaobject>
              <imageobject>
                <imagedata align="center" fileref="img/PickerField.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>XML-имя компонента: <sgmltag>pickerField</sgmltag>.</para>
          <figure>
            <title/>
            <mediaobject>
              <imageobject>
                <imagedata contentwidth="80%" align="center" fileref="img/gui_pickerField_dia.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>Компонент реализован для блоков <structname>Web Client</structname> и <structname>Desktop Client</structname>.</para>
          <itemizedlist>
            <listitem>
              <para>Пример компонента <code>PickerField</code> для поля <code>Покупатель</code> (<code>Customer</code>):</para>
              <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/pickerField/pickerFieldMetaClass.txt" encoding="UTF-8" parse="text"/></programlisting>
              <para id="gui_attr_pickerField_metaclass">Атрибут <sgmltag>metaClass</sgmltag> задает тип <glossterm linkend="entity">сущности</glossterm>, экземпляр которой будет выбираться с помощью действия поиска (<literal>lookup</literal>). Для заданной сущности должен быть определен экран <literal>Название_сущности.lookup</literal> либо в атрибуте <sgmltag>lookupScreen</sgmltag> указан идентификатор экрана, который нужно открыть для выбора экземпляра сущности.</para>
            </listitem>
            <listitem>
              <para>Определить компонент можно также следующим образом:</para>
              <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/pickerField/pickerFieldProperty.txt" encoding="UTF-8" parse="text"/></programlisting>
              <para>Ппредварительно создается источник данных <literal>orderDs</literal> для некоторой сущности <code>Заказ (Order)</code>, имеющей ссылочный атрибут <code>customer</code>. В компоненте <sgmltag>pickerField</sgmltag>    в атрибуте <link linkend="gui_attr_basic_datasource">datasource</link> указывается ссылка на созданный ранее источник данных, а в атрибуте <link linkend="gui_attr_basic_property">property</link> − название поля сущности, которое должно быть отображено в  поле.</para>
            </listitem>
          </itemizedlist>
          <warning>
            <para>Для правильной работы компонента <code>PickerField</code> необходима установка атрибута <link linkend="gui_attr_pickerField_metaclass">metaClass</link> либо одновременная установка атрибутов <link linkend="gui_attr_basic_datasource">datasource</link> и <link linkend="gui_attr_basic_property">property</link>.</para>
          </warning>
          <tip>
            <title>Подсказка</title>
            <para>Если при объявлении компонента никаких <link linkend="gui_Action">действий</link> не задано, загрузчик XML определит для него действия <literal>lookup</literal> и <literal>clear</literal>. </para>
          </tip>
          <itemizedlist>
            <listitem>
              <para id="gui_element_pickerField_actions">Для компонента существуют стандартные действия, определенные  перечислением <code>PickerField.ActionType</code>: <code>lookup</code>, <code>clear</code>, <code>open</code>. Для стандартных действий не нужно определять никаких атрибутов, кроме идентификатора. Например, для того чтобы добавить к действиям по умолчанию действие <literal>open</literal>, нужно определить элемент <sgmltag>action</sgmltag> следующим образом:</para>
              <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/pickerField/pickerFieldStandartActions.txt" encoding="UTF-8" parse="text"/></programlisting>
              <warning>
                <para>Элемент <sgmltag>action</sgmltag> не дополняет, а переопределяет набор стандартных действий, поэтому необходимо указывать идентификаторы всех требуемых действий.</para>
              </warning>
              <figure>
                <title/>
                <mediaobject>
                  <imageobject>
                    <imagedata contentwidth="326" align="center" fileref="img/gui_pickerFieldActionsSt.png"/>
                  </imageobject>
                </mediaobject>
              </figure>
              <para>Ниже показано описание <code>PickerField</code>, имеющего произвольные действия.</para>
              <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/pickerField/pickerFieldUserActions.txt" encoding="UTF-8" parse="text"/></programlisting>
              <para>Действия необходимо определить в <glossterm linkend="screen_controller_glossentry">контроллере</glossterm> экрана:</para>
              <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/pickerField/pickerFieldUserActionsContr.txt" encoding="UTF-8" parse="text"/></programlisting>
              <figure>
                <title/>
                <mediaobject>
                  <imageobject>
                    <imagedata contentwidth="286" align="center" fileref="img/gui_pickerField_custom.png"/>
                  </imageobject>
                </mediaobject>
              </figure>
            </listitem>
            <listitem>
              <para>Для компонента определены горячие клавиши. Для стандартных действий:</para>
              <itemizedlist>
                <listitem>
                  <para><code>Lookup</code> − <keycombo>
                      <keycap>CTRL</keycap>
                      <keycap>ALT</keycap>
                      <keycap>L</keycap>
                    </keycombo></para>
                </listitem>
                <listitem>
                  <para><code>Open</code> − <keycombo>
                      <keycap>CTRL</keycap>
                      <keycap>ALT</keycap>
                      <keycap>O</keycap>
                    </keycombo></para>
                </listitem>
                <listitem>
                  <para><code>Clear</code> − <keycombo>
                      <keycap>CTRL</keycap>
                      <keycap>ALT</keycap>
                      <keycap>C</keycap>
                    </keycombo></para>
                </listitem>
              </itemizedlist>
              <para>Чтобы добавить пользовательскую горячую клавишу, необходимо чтобы класс <link linkend="gui_Action">действия</link> реализовывал интерфейс <code>com.haulmont.cuba.gui.components.ShortcutAction</code></para>
              <para>Пример действия, которое записывает в поле компонента <code>PickerField</code> некоторое строковое значение, находится ниже. Действие может вызываться при нажатии сочетания клавиш <keycombo>
                  <keycap>CTRL</keycap>
                  <keycap>СТРЕЛКА ВВЕРХ</keycap>
                </keycombo></para>
              <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/pickerField/pickerFieldAction.txt" encoding="UTF-8" parse="text"/></programlisting>
              <para>Также поддерживается вызов действий сочетанием <keycombo>
                  <keycap>CTRL</keycap>
                  <keycap>ALT</keycap>
                  <keycap>1</keycap>
                </keycombo>, <keycombo>
                  <keycap>CTRL</keycap>
                  <keycap>ALT</keycap>
                  <keycap>2</keycap>
                </keycombo> и так далее. То есть при нажатии сочетания клавиш <keycombo>
                  <keycap>CTRL</keycap>
                  <keycap>ALT</keycap>
                  <keycap>1</keycap>
                </keycombo> произойдет вызов действия, которое описывается первым в списке действий, при нажатии сочетания клавиш <keycombo>
                  <keycap>CTRL</keycap>
                  <keycap>ALT</keycap>
                  <keycap>2</keycap>
                </keycombo> − вызов второго действия и так далее.</para>
              <para>Сочетания клавиш можно переназначить в ClientConfig</para>
              <itemizedlist>
                <listitem>
                  <para><property>cuba.gui.pickerShortcut.modifiers</property> − модификаторы для вызова <link linkend="gui_Action">действий</link> по порядковому номеру</para>
                </listitem>
                <listitem>
                  <para><property>cuba.gui.pickerShortcut.lookup</property> − Lookup Action</para>
                </listitem>
                <listitem>
                  <para><property>cuba.gui.pickerShortcut.open</property> − Open Action</para>
                </listitem>
                <listitem>
                  <para><property>cuba.gui.pickerShortcut.clear</property> − Clear Action</para>
                </listitem>
              </itemizedlist>
            </listitem>
          </itemizedlist>
          <para>Атрибуты <sgmltag>pickerField</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row><entry align="left">
                    <link linkend="gui_attr_basic_caption">caption</link>
                  </entry>editable<entry align="left">
                    <link linkend="gui_attr_basic_enable">enable</link>
                  </entry><entry align="left">
                    <link linkend="gui_attr_basic_property">property</link>
                  </entry><entry>
                    <link linkend="gui_attr_basic_width">width</link>
                  </entry></row>
                <row><entry>
                    <link linkend="gui_attr_basic_captionProperty">captionProperty</link>
                  </entry><entry align="left">
                    <link linkend="gui_attr_basic_height">height</link>
                  </entry>required<entry>
                    <link linkend="gui_attr_basic_required">required</link>
                  </entry><entry/></row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_datasource">datasource</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_id">id</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_requiredMessage">requiredMessage</link>
                  </entry>
                  <entry/>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_description">description</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_lookupScreen">lookupScreen</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_stylename">stylename</link>
                  </entry>
                  <entry/>
                </row>
                <row>
                  <entry>
                    <link linkend="gui_attr_basic_editable">editable</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_pickerField_metaclass">metaClass</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_visible">visible</link>
                  </entry>
                  <entry/>
                </row>
              </tbody></tgroup>
          </informaltable>
        </section>
        <section id="gui_OptionsGroup">
          <title>OptionsGroup</title>
          <para>Компонент, который обеспечивает выбор из альтернатив, используя группу переключателей для выбора единственного значения из списка или используя группу флажков для выбора нескольких значений из списка.</para>
          <figure>
            <title/>
            <mediaobject>
              <imageobject>
                <imagedata contentwidth="265" align="center" fileref="img/gui_optionsGroup.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>XML-имя компонента: <sgmltag>optionsGroup</sgmltag>.</para>
          <figure>
            <title/>
            <mediaobject>
              <imageobject>
                <imagedata contentwidth="80%" align="center" fileref="img/gui_OptionsGroup_dia.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>Компонент реализован для блоков <structname>Web Client</structname> и <structname>Desktop Client</structname>.</para>
          <itemizedlist>
            <listitem>
              <para>Обычно  компонент используется для отображения списка значений некоторого перечисления (enum).</para>
              <para>Например, в экране редактирования покупателя можно добавить поле <code>Тип покупателя</code> (физическое лицо или юридическое лицо) следующим образом. В <link linkend="screen_xml_glossentry">xml-дескрипторе</link> описывается компонент <sgmltag>optionsGroup</sgmltag>, в значении атрибута <link linkend="gui_attr_basic_datasource">datasource</link> указывается идентификатор источника данных <literal>customerDs</literal>, в атрибуте <link linkend="gui_attr_basic_property">property</link> указывается поле <literal>type</literal> сущности <code>Customer</code>. Поле <code>type</code> задается в сущности  перечислением.</para>
              <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/optionsGroup/optionsGroupDatasource.txt" encoding="UTF-8" parse="text"/></programlisting>
            </listitem>
            <listitem>
              <para>В случае если некоторое поле  задается в сущности строкой, имеющей определенные значения, содержимое списка можно создать программно, в <link linkend="screen_controller_glossentry">контроллере</link> экрана. Например, добавим для  сущности покупателя поле <code>Пол</code>. В xml-дескрипторе определим описание компонента <sgmltag>optionsGroup</sgmltag>:</para>
              <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/optionsGroup/optionsGroupOptDs.txt" encoding="UTF-8" parse="text"/></programlisting>
              <para>Далее зададим значения в контроллере экрана:</para>
              <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/optionsGroup/optionsGroup.txt" encoding="UTF-8" parse="text"/></programlisting>
            </listitem>
            <listitem>
              <para>Если с помощью компонента требуется отобразить экземпляры некоторой  <link linkend="entity">сущности</link>, нужно использовать атрибут <link linkend="gui_attr_basic_optionsDatasource">optionsDatasource</link> при описании компонента.</para>
              <para>Предварительно создается <link linkend="datasources">источник данных</link> для отображения коллекции сущностей − <literal>collectionDatasource</literal>. В атрибуте <sgmltag>optionsDatasource</sgmltag> компонента <sgmltag>optionsGroup</sgmltag> указывается идентификатор описанного источника данных.</para>
            </listitem>
            <listitem>
              <para id="gui_attr_optionsGroup_orientation">Атрибут <sgmltag>orientation</sgmltag> задает расположение элементов группы. По умолчанию элементы располагаются по вертикали. Значение <literal>&quot;horizontal&quot;</literal> служит для горизонтального расположения.</para>
            </listitem>
            <listitem>
              <para id="gui_attr_optionsGroup_multiselect">Для задания режима выбора значений служит атрибут <sgmltag>multiselect</sgmltag>. Если <code>&quot;multiselect=false&quot;</code>, то компонент будет представлен как группа переключателей, иначе − как группа флажков. По умолчанию значение атрибута равно <literal>false</literal>.</para>
            </listitem>
          </itemizedlist>
          <para>Атрибуты <sgmltag>optionsGroup</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row><entry align="left">
                    <link linkend="gui_attr_basic_caption">caption</link>
                  </entry>editable<entry align="left">
                    <link linkend="gui_attr_basic_enable">enable</link>
                  </entry><entry align="left">
                    <link linkend="gui_attr_optionsGroup_orientation">orientation</link>
                  </entry><entry>
                    <link linkend="gui_attr_basic_visible">visible</link>
                  </entry></row>
                <row><entry>
                    <link linkend="gui_attr_basic_captionProperty">captionProperty</link>
                  </entry><entry align="left">
                    <link linkend="gui_attr_basic_height">height</link>
                  </entry>required<entry>
                    <link linkend="gui_attr_basic_property">property</link>
                  </entry><entry>
                    <link linkend="gui_attr_basic_width">width</link>
                  </entry></row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_datasource">datasource</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_id">id</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_required">required</link>
                  </entry>
                  <entry/>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_description">description</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_optionsGroup_multiselect">multiselect</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_requiredMessage">requiredMessage</link>
                  </entry>
                  <entry/>
                </row>
                <row>
                  <entry>
                    <link linkend="gui_attr_basic_editable">editable</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_optionsDatasource">optionsDatasource</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_stylename">stylename</link>
                  </entry>
                  <entry/>
                </row>
              </tbody></tgroup>
          </informaltable>
          <para>Элементы <sgmltag>optionsGroup</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="1" colsep="1" rowsep="1" align="left">
              <colspec colname="c1"/>
              <tbody>
                <row>
                  <entry align="left">
                    <link linkend="gui_element_basic_validator">validator</link>
                  </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </section>
        <section id="gui_LookupField">
          <title>LookupField</title>
          <para>Компонент, реализующий раскрывающийся список. Раскрывающийся список  служит для выбора одного из множества
доступных вариантов. В составе такого списка присутствует активизирующая его кнопка и поле редактирования. Раскрывающийся список реализует фильтрацию значений в реальном времени (по мере ввода значения пользователем) и постраничный вывод доступных значений.</para>
          <figure>
            <title/>
            <mediaobject>
              <imageobject>
                <imagedata contentwidth="165" align="center" fileref="img/gui_lookupField.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>XML-имя компонента: <sgmltag>lookupField</sgmltag>.</para>
          <figure>
            <title/>
            <mediaobject>
              <imageobject>
                <imagedata contentwidth="80%" align="center" fileref="img/gui_LookupField_dia.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>Компонент реализован для блоков <structname>Web Client</structname> и <structname>Desktop Client</structname>.</para>
          <itemizedlist>
            <listitem>
              <para>Если в качестве значений списка используются экземпляры <glossterm linkend="entity">сущностей</glossterm>, нужно использовать атрибут <link linkend="gui_attr_basic_optionsDatasource">optionsDatasource</link> при описании компонента.</para>
              <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/lookupField/lookupFieldOptDs.txt" encoding="UTF-8" parse="text"/></programlisting>
              <para>Предварительно необходимо создать <link linkend="datasources">источник данных</link> <literal>orderDs</literal>, в который будет передан экземпляр редактируемой сущности из вызывающего экран кода, а также источник данных, содержащий коллецию сущностей  для раскрывающегося списка (<literal>customersDs</literal>).</para>
            </listitem>
            <listitem>
              <para>Ниже представлено описание раскрывающегося списка, значения которого заданы с помощью установки <link linkend="datasources">источника данных</link> и имени атрибута <glossterm linkend="entity">сущности</glossterm>. Атрибут сущности является перечислением (enum).</para>
              <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/lookupField/lookupField.txt" encoding="UTF-8" parse="text"/></programlisting>
            </listitem>
            <listitem>
              <para id="gui_attr_lookupField_filterMode">С помощью атрибута <sgmltag>filterMode</sgmltag> можно задать тип фильтрации значений:</para>
              <itemizedlist>
                <listitem>
                  <para><literal>NO</literal> − нет фильтрации</para>
                </listitem>
                <listitem>
                  <para><literal>STARTS_WITH</literal> − по началу фразы</para>
                </listitem>
                <listitem>
                  <para><literal>CONTAINS</literal> − по любому вхождению</para>
                </listitem>
              </itemizedlist>
            </listitem>
          </itemizedlist>
          <para>Атрибуты <sgmltag>lookupField</sgmltag>: </para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row><entry align="left">
                    <link linkend="gui_attr_basic_caption">caption</link>
                  </entry>editable<entry align="left">
                    <link linkend="gui_attr_basic_enable">enable</link>
                  </entry><entry align="left">
                    <link linkend="gui_attr_basic_optionsDatasource">optionsDatasource</link>
                  </entry><entry>
                    <link linkend="gui_attr_basic_visible">visible</link>
                  </entry></row>
                <row><entry>
                    <link linkend="gui_attr_basic_captionProperty">captionProperty</link>
                  </entry><entry align="left">
                    <link linkend="gui_attr_lookupField_filterMode">filterMode</link>
                  </entry>required<entry>
                    <link linkend="gui_attr_basic_property">property</link>
                  </entry><entry>
                    <link linkend="gui_attr_basic_width">width</link>
                  </entry></row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_datasource">datasource</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_height">height</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_required">required</link>
                  </entry>
                  <entry/>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_description">description</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_id">id</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_requiredMessage">requiredMessage</link>
                  </entry>
                  <entry/>
                </row>
                <row>
                  <entry>
                    <link linkend="gui_attr_basic_editable">editable</link>
                  </entry>
                  <entry>nullName</entry>
                  <entry>
                    <link linkend="gui_attr_basic_stylename">stylename</link>
                  </entry>
                  <entry/>
                </row>
              </tbody></tgroup>
          </informaltable>
          <para>Элементы <sgmltag>lookupField</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="1" colsep="1" rowsep="1" align="left">
              <colspec colname="c1"/>
              <tbody>
                <row>
                  <entry align="left">
                    <link linkend="gui_element_basic_validator">validator</link>
                  </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </section>
        <section id="gui_LookupPickerField">
          <title>LookupPickerField</title>
          <para>Раскрывающийся список с расширенной функциональностью (<code>LookupPickerField</code>) позволяет отображать экземпляр сущности в текстовом поле, выбирать экземпляр в раскрывающемся списке и выполнять действия нажатием на кнопки справа.</para>
          <figure>
            <title/>
            <mediaobject>
              <imageobject>
                <imagedata contentwidth="260" align="center" fileref="img/gui_lookupPickerField.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>XML-имя компонента: <sgmltag>lookupPickerField</sgmltag>.</para>
          <figure>
            <title/>
            <mediaobject>
              <imageobject>
                <imagedata contentwidth="80%" align="center" fileref="img/gui_LookupPickerField_dia.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>Компонент реализован для блоков <structname>Web Client</structname> и <structname>Desktop Client</structname>.</para>
          <para>Компонент <code>LookupPickerField</code> отличается от компонента <link linkend="gui_LookupField">LookupField</link> тем, что в правой части компонента добавляются кнопки, позволяющие перейти к экрану выбора экземпляра связанной сущности <inlinemediaobject>
              <imageobject>
                <imagedata fileref="img/lookupBtn.png"/>
              </imageobject>
            </inlinemediaobject> и к экрану просмотра выбранной в компоненте сущности <inlinemediaobject>
              <imageobject>
                <imagedata fileref="img/openBtn.png"/>
              </imageobject>
            </inlinemediaobject>.</para>
          <tip>
            <para>Если при объявлении компонента никаких <link linkend="gui_Action">действий</link> не задано, загрузчик XML определит для него действия <literal>lookup</literal> и <literal>open</literal>.</para>
          </tip>
          <para>Можно задавать дополнительные стандартные или произвольные действия. Информация о том, как это сделать, содержится в <link linkend="gui_element_pickerField_actions">описании компонента PickerField</link>.</para>
          <para>Ниже представлено описание раскрывающегося списка с расширенной функциональностью.</para>
          <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/lookupPickerField/lookupPickerField.txt" encoding="UTF-8" parse="text"/></programlisting>
          <para>Атрибуты <sgmltag>lookupPickerField</sgmltag>: </para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row><entry align="left">
                    <link linkend="gui_attr_basic_caption">caption</link>
                  </entry>editable<entry align="left">
                    <link linkend="gui_attr_basic_enable">enable</link>
                  </entry><entry align="left">nullName</entry><entry>
                    <link linkend="gui_attr_basic_stylename">stylename</link>
                  </entry></row>
                <row><entry>
                    <link linkend="gui_attr_basic_captionProperty">captionProperty</link>
                  </entry><entry align="left">
                    <link linkend="gui_attr_lookupField_filterMode">filterMode</link>
                  </entry>required<entry>
                    <link linkend="gui_attr_basic_optionsDatasource">optionsDatasource</link>
                  </entry><entry>
                    <link linkend="gui_attr_basic_visible">visible</link>
                  </entry></row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_datasource">datasource</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_height">height</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_property">property</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_width">width</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_description">description</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_id">id</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_required">required</link>
                  </entry>
                  <entry/>
                </row>
                <row>
                  <entry>
                    <link linkend="gui_attr_basic_editable">editable</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_pickerField_metaclass">metaClass</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_requiredMessage">requiredMessage</link>
                  </entry>
                  <entry/>
                </row>
              </tbody></tgroup>
          </informaltable>
          <para>Элементы <sgmltag>lookupPickerField</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="1" colsep="1" rowsep="1" align="left">
              <colspec colname="c1"/>
              <tbody>
                <row>
                  <entry align="left">
                    <link linkend="gui_element_basic_validator">validator</link>
                  </entry>
                </row>
                <row>
                  <entry>
                    <link linkend="gui_Action">actions</link>
                  </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </section>
        <section id="gui_SearchPickerField">
          <title>SearchPickerField</title>
          <para>Поле поиска с расширенной функциональностью (<code>SearchPickerField</code>) служит для поиска значения по заранее определенному условию. Для работы с полем достаточно ввести хотя бы один символ и нажать клавишу <keycap>Enter</keycap>. Если будут найдены несколько совпадений, значения будут отображены  в виде списка. С помощью дополнительных кнопок можно открывать экземпляр выбранной в поле <glossterm linkend="entity">сущности</glossterm>, удалять экземпляр или выбирать экземпляр из экрана списка сущностей.</para>
          <figure>
            <title/>
            <mediaobject>
              <imageobject>
                <imagedata align="center" fileref="img/gui_searchPickerFieldOverlap.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>XML-имя компонента: <sgmltag>searchPickerField</sgmltag>.</para>
          <figure>
            <title/>
            <mediaobject>
              <imageobject>
                <imagedata contentwidth="90%" align="center" fileref="img/gui_SearchPickerField_dia.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>Компонент реализован только для блока <structname>Web Client</structname>.</para>
          <itemizedlist>
            <listitem>
              <para>Для компонента <sgmltag>searchPickerField</sgmltag> необходимо предварительно создать <link linkend="datasources">источник данных</link>, предназначенный для работы с коллекцией <glossterm linkend="entity">сущностей</glossterm>, и задать в нем запрос, содержащий условия поиска. Например:</para>
              <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/searchPickerField/searchPickerFieldDs.txt" encoding="UTF-8" parse="text"/></programlisting>
              <para>При описании компонента в <glossterm linkend="screen_xml_glossentry">XML-дескрипторе</glossterm> используйте атрибут <link linkend="attr_optionsDatasource">optionsDatasource</link>. </para>
              <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/searchPickerField/searchPickerField.txt" encoding="UTF-8" parse="text"/></programlisting>
            </listitem>
            <listitem>
              <para id="gui_attr_searchPickerField_minSearchStringLength">Значение атрибута <sgmltag>minSearchStringLength</sgmltag> − это минимальное количество символов, необходимых для поиска значения.</para>
              <para>В <glossterm linkend="screen_controller_glossentry">контроллере</glossterm> экрана можно указать содержание нотификаций, которые будут выводиться на экран в двух случаях:</para>
              <itemizedlist>
                <listitem>
                  <para>если количество введенных символов меньше значения атрибута <link linkend="gui_attr_searchPickerField_minSearchStringLength">minSearchStringLength</link></para>
                </listitem>
                <listitem>
                  <para>если не найдено совпадений существующих в источнике данных значений и введенных символов.</para>
                </listitem>
              </itemizedlist>
              <para>Пример задания нотификаций в <glossterm linkend="screen_controller_glossentry">контроллере</glossterm> экрана:</para>
              <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/searchField/searchFieldContr.txt" encoding="UTF-8" parse="text"/></programlisting>
            </listitem>
            <listitem>
              <tip>
                <para>Если при объявлении компонента никаких <link linkend="gui_Action">действий</link> не задано,  загрузчик XML определит для него действия <literal>lookup</literal> и <literal>open</literal>.</para>
              </tip>
              <para>Стандартные действия определяются перечислением <code>PickerField.ActionType</code>: <literal>lookup</literal>, <literal>clear</literal>, <literal>open</literal>.</para>
              <para>Можно задавать дополнительные стандартные или произвольные действия. Информация о том, как это сделать, содержится в <link linkend="gui_element_pickerField_actions">описании компонента PickerField</link>.</para>
            </listitem>
          </itemizedlist>
          <para>Атрибуты <sgmltag>searchPickerField</sgmltag>: </para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row><entry align="left">
                    <link linkend="gui_attr_basic_caption">caption</link>
                  </entry>editable<entry align="left">
                    <link linkend="gui_attr_basic_enable">enable</link>
                  </entry><entry align="left">
                    <link linkend="gui_attr_searchPickerField_minSearchStringLength">minSearchStringLength</link>
                  </entry><entry>
                    <link linkend="gui_attr_basic_requiredMessage">requiredMessage</link>
                  </entry></row>
                <row><entry>
                    <link linkend="gui_attr_basic_captionProperty">captionProperty</link>
                  </entry><entry align="left">
                    <link linkend="gui_attr_lookupField_filterMode">filterMode</link>
                  </entry>required<entry>nullName</entry><entry>
                    <link linkend="gui_attr_basic_stylename">stylename</link>
                  </entry></row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_datasource">datasource</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_height">height</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_optionsDatasource">optionsDatasource</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_visible">visible</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_description">description</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_id">id</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_property">property</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_width">width</link>
                  </entry>
                </row>
                <row>
                  <entry>
                    <link linkend="gui_attr_basic_editable">editable</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_pickerField_metaclass">metaClass</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_required">required</link>
                  </entry>
                  <entry/>
                </row>
              </tbody></tgroup>
          </informaltable>
          <para>Элементы <sgmltag>searchPickerField</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="1" colsep="1" rowsep="1" align="left">
              <colspec colname="c1"/>
              <tbody>
                <row>
                  <entry>
                    <link linkend="gui_Action">actions</link>
                  </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </section>
        <section id="gui_TwinColumn">
          <title>TwinColumn</title>
          <para>Сдвоенный список (<code>TwinColumn</code>)  представляет собой компонент множественного выбора, имеющий  два находящихся рядом списка: доступных и выбранных опций. В левом списке содержатся доступные невыбранные значения, в правом списке содержатся выбранные значения. Пользователь может выбрать значения из левого списка и нажать на кнопку <inlinemediaobject>
              <imageobject>
                <imagedata fileref="img/gui_teinColumnRight.png"/>
              </imageobject>
            </inlinemediaobject>, переместив их таким образом в правый список. Значения могут быть отменены для выбора путем выделения их в правом списке и нажатия на кнопку <inlinemediaobject>
              <imageobject>
                <imagedata fileref="img/gui_teinColumnLeft.png"/>
              </imageobject>
            </inlinemediaobject>. Для каждого значения можно задать уникальный стиль отображения и пиктограмму.</para>
          <figure>
            <title/>
            <mediaobject>
              <imageobject>
                <imagedata contentwidth="235" align="center" fileref="img/TwinColumn.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>XML-имя компонента: <sgmltag>twinColumn</sgmltag></para>
          <figure>
            <title/>
            <mediaobject>
              <imageobject>
                <imagedata contentwidth="173" contentdepth="389" align="center" fileref="img/gui_TwinColumn_dia.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>Компонент реализован только для блока <structname>Web Client</structname>.</para>
          <para>Ниже представлен пример компонента <sgmltag>twinColumn</sgmltag>, предназначенного для формирования списка товаров  в заказе:</para>
          <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/twinColumn/twinColumnOptDs.txt" encoding="UTF-8" parse="text"/></programlisting>
          <para id="gui_attr_twinColumn_columns_rows">Для формирования списка опций служит источник данных <literal>productsDs</literal>, его идентификатор указывается в атрибуте <link linkend="gui_attr_basic_optionsDatasource">optionsDatasource</link> компонента. Атрибут <sgmltag>columns</sgmltag> используется для задания количества колонок текста в списке, а атрибут <sgmltag>rows</sgmltag> − для задания количества строк текста в списке.</para>
          <para>Для задания внешнего вида опций нужно реализовать интерфейс <code>com.haulmont.cuba.gui.components.StyleProvider</code> как показано в следующем примере:</para>
          <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/twinColumn/twinColumnStyle.txt" encoding="UTF-8" parse="text"/></programlisting>
          <para>Атрибуты <sgmltag>twinColumn</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row><entry align="left">
                    <link linkend="gui_attr_basic_caption">caption</link>
                  </entry>editable<entry align="left">
                    <link linkend="gui_attr_basic_editable">editable</link>
                  </entry><entry align="left">
                    <link linkend="gui_attr_basic_optionsDatasource">optionsDatasource</link>
                  </entry><entry>
                    <link linkend="gui_attr_basic_stylename">stylename</link>
                  </entry></row>
                <row><entry>
                    <link linkend="gui_attr_basic_captionProperty">captionProperty</link>
                  </entry><entry align="left">
                    <link linkend="gui_attr_basic_enable">enable</link>
                  </entry>required<entry>
                    <link linkend="gui_attr_basic_property">property</link>
                  </entry><entry>
                    <link linkend="gui_attr_basic_visible">visible</link>
                  </entry></row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_twinColumn_columns_rows">columns</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_height">height</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_required">required</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_width">width</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_datasource">datasource</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_id">id</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_requiredMessage">requiredMessage</link>
                  </entry>
                  <entry/>
                </row>
                <row>
                  <entry>
                    <link linkend="gui_attr_basic_description">description</link>
                  </entry>
                  <entry>nullName</entry>
                  <entry>
                    <link linkend="gui_attr_twinColumn_columns_rows">rows</link>
                  </entry>
                  <entry/>
                </row>
              </tbody></tgroup>
          </informaltable>
          <para>Элементы <sgmltag>twinColumn</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="1" colsep="1" rowsep="1" align="left">
              <colspec colname="c1"/>
              <tbody>
                <row>
                  <entry align="left">
                    <link linkend="gui_element_basic_validator">validator</link>
                  </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </section>
        <section id="gui_FileUploadField">
          <title>FileUploadField</title>
          <para>Компонент загрузки файлов (<code>FileUploadField</code>) позволяет пользователю загружать файлы на сервер. Компонент представляет собой кнопку, при нажатии на которую на экране отображается окно загрузки файла, содержащее список файлов некоторой директории. В списке можно выбрать только один файл для загрузки.</para>
          <figure>
            <title/>
            <mediaobject>
              <imageobject>
                <imagedata align="center" fileref="img/gui_upload.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>XML-имя компонента: <sgmltag>upload</sgmltag>.</para>
          <figure>
            <title/>
            <mediaobject>
              <imageobject>
                <imagedata contentwidth="80%" align="center" fileref="img/gui_FileUploadField_dia.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>Компонент реализован для блоков <structname>Web Client</structname> и <structname>Desktop Client</structname>. </para>
          <para>Ниже расположен пример, содержащий обработчик загрузки файла. В этом обработчике написан программный код, обеспечивающий вывод на экран сообщения об успешной или не успешной загрузке файла, а также вывод названия файла в компоненте  <link linkend="gui_Label">надписи</link>.</para>
          <para>Для начала определим описание компонента в <glossterm linkend="screen_xml_glossentry">xml-дескрипторе</glossterm>:</para>
          <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/upload/upload.txt" encoding="UTF-8" parse="text"/></programlisting>
          <para>Программный код <glossterm linkend="screen_controller_glossentry">контроллера</glossterm> выглядит следующим образом:</para>
          <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/upload/uploadContr.txt" encoding="UTF-8" parse="text"/></programlisting>
          <figure>
            <title/>
            <mediaobject>
              <imageobject>
                <imagedata align="center" fileref="img/gui_uploadRez.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>Атрибуты <sgmltag>upload</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row><entry align="left">
                    <link linkend="attr_caption">caption</link>
                  </entry>editable<entry align="left">
                    <link linkend="attr_id">id</link>
                  </entry><entry align="left">
                    <link linkend="attr_width">width</link>
                  </entry><entry/></row>
                <row>
                  <entry>
                    <link linkend="attr_description">description</link>
                  </entry>
                  <entry align="left">
                    <link linkend="attr_stylename">stylename</link>
                  </entry>
                  <entry/>
                  <entry/>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="attr_height">height</link>
                  </entry>
                  <entry align="left">
                    <link linkend="attr_visible">visible</link>
                  </entry>
                  <entry/>
                  <entry/>
                </row>
              </tbody></tgroup>
          </informaltable>
        </section>
        <section id="gui_FileMultiUploadField">
          <title>FileMultiUploadField</title>
          <para>Компонент для множественной загрузки файлов позволяет пользователю загружать файлы на сервер. Компонент представляет собой кнопку, при нажатии на которую на экране отображается окно загрузки файлов, содержащее список файлов некоторой директории. В списке можно выбрать сразу несколько файлов для загрузки.</para>
          <figure>
            <title/>
            <mediaobject>
              <imageobject>
                <imagedata align="center" fileref="img/gui_multipleUpload.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>XML-имя компонента: <sgmltag>multiupload</sgmltag>.</para>
          <figure>
            <title/>
            <mediaobject>
              <imageobject>
                <imagedata contentwidth="80%" align="center" fileref="img/gui_FileMultiUploadField_dia.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>Компонент реализован для блоков <structname>Web Client</structname> и <structname>Desktop Client</structname>. </para>
          <para>Ниже расположен пример, содержащий обработчик загрузки файлов. В этом обработчике написан программный код, обеспечивающий вывод на экран сообщения об успешной или не успешной загрузке файлов, а также вывод названий файлов в <link linkend="gui_TextField">текстовое поле</link>.</para>
          <para>Для начала определим описание компонента в <glossterm linkend="screen_xml_glossentry">xml-дескрипторе</glossterm>:</para>
          <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/multipleUpload/multipleUpload.txt" encoding="UTF-8" parse="text"/></programlisting>
          <para>Программный код <glossterm linkend="screen_controller_glossentry">контроллера</glossterm> выглядит следующим образом:</para>
          <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/multipleUpload/multipleUploadContr.txt" encoding="UTF-8" parse="text"/></programlisting>
          <figure>
            <title/>
            <mediaobject>
              <imageobject>
                <imagedata align="center" fileref="img/gui_multipleUploadRez.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>Атрибуты <sgmltag>multiupload</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row><entry align="left">
                    <link linkend="attr_caption">caption</link>
                  </entry>editable<entry align="left">
                    <link linkend="attr_id">id</link>
                  </entry><entry align="left">
                    <link linkend="attr_width">width</link>
                  </entry><entry/></row>
                <row>
                  <entry>
                    <link linkend="attr_description">description</link>
                  </entry>
                  <entry align="left">
                    <link linkend="attr_stylename">stylename</link>
                  </entry>
                  <entry/>
                  <entry/>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="attr_height">height</link>
                  </entry>
                  <entry align="left">
                    <link linkend="attr_visible">visible</link>
                  </entry>
                  <entry/>
                  <entry/>
                </row>
              </tbody></tgroup>
          </informaltable>
        </section>
        <section id="gui_Table">
          <title>Table</title>
          <para>Таблица (<code>Table</code>)  дает возможность выводить двухмерную информацию, расположенную в виде строк и столбцов, настраивать и сортировать данные, управлять заголовками таблицы и ее выделенными элементами.</para>
          <figure>
            <title/>
            <mediaobject>
              <imageobject>
                <imagedata contentwidth="300" align="center" fileref="img/gui_table.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>XML-имя компонента: <sgmltag>table</sgmltag></para>
          <figure>
            <title/>
            <mediaobject>
              <imageobject>
                <imagedata contentwidth="90%" align="center" fileref="img/gui_Table_dia.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>Компонент реализован для блоков <structname>Web Client</structname> и <structname>Desktop Client</structname>. </para>
          <para>Интерфейс <code>Table</code>,  наследуется от интерфейса  <code>ListComponent</code> − базового интерфейса компонентов, предназначенных для работы с коллекциями <glossterm linkend="entity">сущностей</glossterm>.</para>
          <para>Для того чтобы создать простую таблицу, необходимо в <glossterm linkend="screen_xml_glossentry">xml-дескрипторе</glossterm> задать <link linkend="datasources">источник данных</link> и определить описание таблицы:</para>
          <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/table/table.txt" encoding="UTF-8" parse="text"/></programlisting>
          <warning>
            <para>Обязательными для таблицы являются элементы <link linkend="element_table_columns">columns</link> и  <link linkend="element_table_rows">rows</link>.</para>
          </warning>
          <para>Атрибут <sgmltag id="attr_presentations">presentations</sgmltag> управляет механизмом <link linkend="gui_Table_presentations">представлений</link>. Значение по умолчанию равно <literal>false</literal>. Когда значение атрибута равно <literal>true</literal>, то в верхнем правом углу таблицы появляется значок <inlinemediaobject>
              <imageobject>
                <imagedata fileref="img/gui_presentation.png"/>
              </imageobject>
            </inlinemediaobject>.</para>
          <para>Атрибут <sgmltag id="attr_sortable">sortable</sgmltag> разрешает или запрещает сортировку в таблице. По умолчанию имеет значение <literal>true</literal>. Если сортировка разрешена, то при нажатии на название колонки справа от названия появляется значок <inlinemediaobject>
              <imageobject>
                <imagedata fileref="img/gui_sortable_down.png"/>
              </imageobject>
            </inlinemediaobject>/<inlinemediaobject>
              <imageobject>
                <imagedata fileref="img/gui_sortable_up.png"/>
              </imageobject>
            </inlinemediaobject>.</para>
          <para>Существует возможность использования для колонок функций <link linkend="gui_Table_aggregation">агрегирования</link> без модификации <link linkend="datasources">источника данных</link> с помощью атрибута <sgmltag id="attr_aggregatable">aggregatable</sgmltag>. По умолчанию атрибут  имеет значение <literal>false</literal>.</para>
          <para>Атрибут <sgmltag id="attr_showTotalAggregation">showTotalAggregation</sgmltag> разрешает или запрещает отображение строки итоговой агрегации в таблице. По умолчанию имеет значение <literal>true</literal>.</para>
          <para>Можно задать множественное выделение строк в таблице с помощью присваивания атрибуту <sgmltag id="attr_table_multiselect">multiselect</sgmltag>  значения <literal>true</literal>. По умолчанию значение атрибута равно <literal>false</literal>.</para>
          <para>С помощью элемента <sgmltag id="element_table_actions">actions</sgmltag> возможно определять набор действий (<link linkend="gui_Action">action</link>). Кроме описания произвольного действия возможно использование стандартных действий, определяемых перечислением <code>ListActionType</code>: <code>create</code>, <code>edit</code>, <code>remove</code>, <code>refresh</code>, <code>add</code>, <code>exclude</code>, <code>excel</code>.</para>
          <para><sgmltag id="attr_rowsCount">rowsCount</sgmltag> − необязательный элемент, создающий для таблицы компонент <code>RowsCount</code>, который позволяет загружать в таблицу данные постранично.</para>
          <para>Элемент <sgmltag id="element_table_rows">rows</sgmltag> является обязательным. В этом элементе необходимо объявить используемый <link linkend="datasources">источник данных</link>.</para>
          <para>Атрибут <sgmltag id="attr_headerMode">headerMode</sgmltag> элемента <sgmltag>rows</sgmltag> задает вариант отображения заголовков рядов:</para>
          <itemizedlist>
            <listitem>
              <para><literal>NONE</literal> − нет заголовков</para>
            </listitem>
            <listitem>
              <para><literal>ICON</literal> − пиктограмма</para>
            </listitem>
          </itemizedlist>
          <para>Следующим обязательным элементом для таблицы является элемент <sgmltag id="element_table_columns">columns</sgmltag>. Он определяет набор колонок (<sgmltag>column</sgmltag>) таблицы.</para>
          <para><sgmltag id="element_table_columns_column_1">column</sgmltag>  − элемент, задающий опции для колонки таблицы. Может содержать следующие атрибуты:</para>
          <itemizedlist>
            <listitem>
              <para><sgmltag id="attr_table_column_id">id</sgmltag> − обязательный атрибут, содержит название атрибута <glossterm linkend="entity">сущности</glossterm>, выводимого в колонке.</para>
            </listitem>
            <listitem>
              <para><sgmltag id="attr_table_column_collapsed">collapsed</sgmltag> − необязательный атрибут, скрывает/показывает колонку. По умолчанию имеет значение <literal>false</literal>.</para>
            </listitem>
            <listitem>
              <para><sgmltag id="attr_table_column_caption">caption</sgmltag> − необязательный атрибут, содержит заголовок колонки.</para>
            </listitem>
            <listitem>
              <para><sgmltag id="attr_table_column_width">width</sgmltag> − необязательный атрибут, отвечает за изначальную ширину колонки.</para>
            </listitem>
            <listitem>
              <para><sgmltag id="attr_table_column_calculatable">calculatable</sgmltag> − необязательный атрибут, используется только в редактируемой таблице. Буквально означает, что значения в данной колонке являются вычислимыми и зависят от значений других колонок.</para>
            </listitem>
            <listitem>
              <para><link linkend="attr_editable" id="attr_table_column_editable">editable</link> − необязательный атрибут, разрешает/запрещает редактирование данного атрибута в редактируемой таблице.</para>
            </listitem>
          </itemizedlist>
          <para>Для таблицы можно задать стиль отображения ячеек таблицы. Для этого в <glossterm linkend="screen_controller_glossentry">контроллере</glossterm> экрана нужно задать для таблицы <code>StyleProvider</code> реализовав интерфейс <code>com.haulmont.cuba.gui.components.StyleProvider.</code></para>
          <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/table/tableStyle.txt" encoding="UTF-8" parse="text"/></programlisting>
          <para>Далее нужно определить в теме приложения стили для строк и столбцов (подробную информацию о том, как создать тему приложения, смотрите <xref linkend="gui_themes"/>):</para>
          <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/table/tableStylecss.txt" encoding="UTF-8" parse="text"/></programlisting>
          <figure>
            <title/>
            <mediaobject>
              <imageobject>
                <imagedata contentwidth="381" align="center" fileref="img/gui_table_Style.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>В таблице существует возможность задавать собственное представление данных в колонке. Для этого необходимо использовать метод <code>Table.addGeneratedColumn</code>. В методе нужно создать CUBA-компонент с использованием класса <code>ComponentsFactory</code>. Пример:</para>
          <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/table/tableGeneratedColumn.txt" encoding="UTF-8" parse="text"/></programlisting>
          <figure>
            <title/>
            <mediaobject>
              <imageobject>
                <imagedata contentwidth="501" align="center" fileref="img/gui_tableGenerated.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>Атрибуты <sgmltag>table</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row><entry align="left">
                    <link linkend="attr_aggregatable">aggregatable</link>
                  </entry>editable<entry align="left">margin</entry><entry align="left">
                    <link linkend="attr_sortable">sortable</link>
                  </entry><entry/></row>
                <row>
                  <entry>
                    <link linkend="attr_editable">editable</link>
                  </entry>
                  <entry align="left">
                    <link linkend="attr_table_multiselect">multiselect</link>
                  </entry>
                  <entry>
                    <link linkend="attr_stylename">styleName</link>
                  </entry>
                  <entry/>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="attr_height">height</link>
                  </entry>
                  <entry align="left">
                    <link linkend="attr_presentations">presentations</link>
                  </entry>
                  <entry>
                    <link linkend="attr_visible">visible</link>
                  </entry>
                  <entry/>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="attr_id">id</link>
                  </entry>
                  <entry align="left">
                    <link linkend="attr_showTotalAggregation">showTotalAggregation</link>
                  </entry>
                  <entry>
                    <link linkend="attr_width">width</link>
                  </entry>
                  <entry/>
                </row>
              </tbody></tgroup>
          </informaltable>
          <para>Элементы <sgmltag>table</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="1" colsep="1" rowsep="1" align="left">
              <colspec colname="c1"/>
              <tbody>
                <row>
                  <entry>
                    <link linkend="element_table_actions">actions</link>
                  </entry>
                </row>
                <row>buttonsPanel<entry>
                    <link linkend="gui_ButtonsPanel">buttonsPanel</link>
                  </entry></row>
                <row>
                  <entry>
                    <link linkend="attr_rowsCount">rowsCount</link>
                  </entry>
                </row>
                <row>
                  <entry>
                    <link linkend="element_t_columns">columns</link>
                  </entry>
                </row>
                <row>
                  <entry>
                    <link linkend="element_t_rows">rows</link>
                  </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
          <para>Атрибуты элемента <link linkend="element_table_columns" id="element_t_columns">columns</link> <link linkend="element_table_columns_column_1">column</link>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row><entry align="left">
                    <link linkend="gui_Table_aggregation">aggregation</link>
                  </entry>editable<entry align="left">
                    <link linkend="attr_clickAction">clickAction</link>
                  </entry><entry align="left">
                    <link linkend="attr_table_column_id">id</link>
                  </entry><entry>
                    <link linkend="attr_resolution">resolution</link>
                  </entry></row>
                <row>
                  <entry>
                    <link linkend="attr_table_column_calculatable">calculatable</link>
                  </entry>
                  <entry align="left">
                    <link linkend="attr_table_column_collapsed">collapsed</link>
                  </entry>
                  <entry>
                    <link linkend="attr_optionsDatasource">optionsDatasource</link>
                  </entry>
                  <entry>
                    <link linkend="attr_visible">visible</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="attr_table_column_caption">caption</link>
                  </entry>
                  <entry align="left">
                    <link linkend="attr_dateFormat">dateFormat</link>
                  </entry>
                  <entry>
                    <link linkend="attr_required">required</link>
                  </entry>
                  <entry>
                    <link linkend="attr_table_column_width">width</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="attr_captionProperty">captionProperty</link>
                  </entry>
                  <entry align="left">
                    <link linkend="attr_table_column_editable">editable</link>
                  </entry>
                  <entry>
                    <link linkend="attr_requiredMessage">requiredMessage</link>
                  </entry>
                  <entry/>
                </row>
              </tbody></tgroup>
          </informaltable>
          <para>Атрибуты <link linkend="element_table_rows" id="element_t_rows">rows</link>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row><entry align="left">
                    <link linkend="attr_datasource">datasource</link>
                  </entry>editable</row>
                <row>
                  <entry>
                    <link linkend="attr_headerMode">headerMode</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
        </section>
        <section id="gui_TreeTable">
          <title>TreeTable</title>
          <para>Таблица с иерархией  (<code>TreeTable</code>)   − таблица, отображающая иерархию <glossterm linkend="entity">сущностей</glossterm>.</para>
          <figure>
            <title/>
            <mediaobject>
              <imageobject>
                <imagedata contentwidth="321" align="center" fileref="img/gui_treeTable.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>XML-имя компонента: <sgmltag>treeTable</sgmltag></para>
          <figure>
            <title/>
            <mediaobject>
              <imageobject>
                <imagedata contentwidth="90%" align="center" fileref="img/gui_TreeTable_dia.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>Компонент реализован для блоков <structname>Web Client</structname> и <structname>Desktop Client</structname>. </para>
          <para>Для того чтобы создать иерархическую таблицу, необходимо в <glossterm linkend="screen_xml_glossentry">xml-дескрипторе</glossterm> задать иерархический <link linkend="datasources">источник данных</link> и определить описание таблицы:</para>
          <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/treeTable/treeTable.txt" encoding="UTF-8" parse="text"/></programlisting>
          <warning>
            <para>Обязательными для иерархической таблицы являются элементы <link linkend="element_table_columns">columns</link> и  <link linkend="element_table_rows">rows</link>.</para>
          </warning>
        </section>
        <section id="gui_GroupTable">
          <title>GroupTable</title>
          <para><link linkend="gui_Table">Таблица</link> с возможностью динамической группировки по любому полю. Для того чтобы сгруппировать таблицу по какому-либо столбцу, нужно в шапке таблицы перетащить этот столбец перед знаком <inlinemediaobject>
              <imageobject>
                <imagedata fileref="img/gui_groupTableIcon.png"/>
              </imageobject>
            </inlinemediaobject>. Сгруппированные значения можно разворачивать и сворачивать с помощью знаков <inlinemediaobject>
              <imageobject>
                <imagedata fileref="img/gui_groupBox_plus.png"/>
              </imageobject>
            </inlinemediaobject>/<inlinemediaobject>
              <imageobject>
                <imagedata fileref="img/gui_groupBox_minus.png"/>
              </imageobject>
            </inlinemediaobject>.</para>
          <figure>
            <title/>
            <mediaobject>
              <imageobject>
                <imagedata contentwidth="357" align="center" fileref="img/gui_groupTableDragColumn.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>XML-имя компонента: <sgmltag>groupTable</sgmltag>.</para>
          <figure>
            <title/>
            <mediaobject>
              <imageobject>
                <imagedata contentwidth="80%" align="center" fileref="img/gui_GroupTable_dia.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>Компонент реализован для блоков <structname>Web Client</structname> и <structname>Desktop Client</structname>. </para>
          <para>Для правильного функционирования <code>GroupTable</code> должна быть соединена с <link linkend="datasources">GroupDatasource</link>.</para>
          <para>Пример использования:</para>
          <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/groupTable/groupTable.txt" encoding="UTF-8" parse="text"/></programlisting>
          <para>Элемент <sgmltag>group</sgmltag> − необязательный элемент, может в единственном экземпляре находиться внутри <link linkend="element_table_columns">columns</link>. Содержит набор элементов <link linkend="element_table_columns_column_1">column</link>, по которым будет выполняться первоначальная группировка.</para>
        </section>
        <section id="gui_Tree">
          <title>Tree</title>
          <para>Компонент <code>Tree</code> представляет иерархическую структуру данных, отображая ее в виде дерева.</para>
          <figure>
            <title/>
            <mediaobject>
              <imageobject>
                <imagedata contentwidth="100" align="center" fileref="img/Tree.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>XML-имя компонента: <sgmltag>tree</sgmltag></para>
          <figure>
            <title/>
            <mediaobject>
              <imageobject>
                <imagedata contentwidth="80%" align="center" fileref="img/gui_tree_dia.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>Компонент реализован для блоков <structname>Web Client</structname> и <structname>Desktop Client</structname>. </para>
          <para>Для того чтобы создать компонент дерева, создайте в <glossterm linkend="screen_xml_glossentry">xml-дескрипторе</glossterm> следующий код:</para>
          <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/tree/tree.txt" encoding="UTF-8" parse="text"/></programlisting>
          <warning>
            <para>Обязательными для дерева являются элемент <sgmltag>treechildren</sgmltag>.</para>
          </warning>
          <para>Элемент <sgmltag id="element_treechildren">treechildren</sgmltag>  декларирует используемый <link linkend="datasources">источник данных</link>. </para>
          <para>Атрибуты <sgmltag>tree</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row><entry align="left">
                    <link linkend="attr_height">height</link>
                  </entry>editable</row>
                <row><entry>
                    <link linkend="attr_id">id</link>
                  </entry>required<entry/></row>
                <row>
                  <entry align="left">
                    <link linkend="attr_table_multiselect">multiselect</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="attr_width">width</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
          <para>Элементы <sgmltag>tree</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="1" colsep="1" rowsep="1" align="left"><colspec colname="c1"/>c <tbody>
                <row><entry align="left">
                    <link linkend="element_treechildren">treechildren</link>
                  </entry>editable</row>
                <row><entry>
                    <link linkend="element_table_actions">actions</link>
                  </entry>required</row>
              </tbody></tgroup>
          </informaltable>
          <para>Атрибуты <sgmltag>treechildren</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row><entry align="left">
                    <link linkend="attr_captionProperty">captionProperty</link>
                  </entry>editable</row>
                <row><entry>
                    <link linkend="attr_datasource">datasource</link>
                  </entry>required</row>
                <row>
                  <entry align="left">
                    <sgmltag>hierarchyProperty</sgmltag>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
        </section>
        <section id="gui_FieldGroup">
          <title>FieldGroup</title>
          <para>Группа полей (<code>FieldGroup</code>) генерализует представление атрибутов одного или более <link linkend="datasources">источника данных</link>. Представление поля зависит от типа соответствующего атрибута. Для отображения <glossterm linkend="entity">сущностей</glossterm> может использоваться как <link linkend="gui_LookupField">LookupField</link>, так и <link linkend="gui_PickerField">PickerField</link>.</para>
          <figure>
            <title/>
            <mediaobject>
              <imageobject>
                <imagedata contentwidth="80%" align="center" fileref="img/gui_fieldGroup.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>XML-имя компонента: <sgmltag>fieldGroup</sgmltag></para>
          <figure>
            <title/>
            <mediaobject>
              <imageobject>
                <imagedata contentwidth="80%" align="center" fileref="img/gui_FieldGroup_dia.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>Компонент реализован для блоков <structname>Web Client</structname> и <structname>Desktop Client</structname>.</para>
          <para>Ниже представлено описание группы полей в <glossterm linkend="screen_xml_glossentry">xml-дескрипторе</glossterm> экрана:</para>
          <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/fieldGroup/fieldGroup.txt" encoding="UTF-8" parse="text"/></programlisting>
          <para>В элементе  <sgmltag>dsContext</sgmltag> создается <link linkend="datasources">источник данных</link> <literal>orderDs</literal> для  сущности заказа <code>Order</code>.</para>
          <itemizedlist>
            <listitem>
              <para id="gui_attr_fieldGroup_datasource"><link linkend="datasources">Источник данных</link> (атрибут <link linkend="gui_attr_basic_datasource">datasource</link>) можно задать как для всего компонента целиком, так и для каждого поля в отдельности. Если для компонента <sgmltag>fieldGroup</sgmltag> атрибут не задан, то атрибут <sgmltag>datasource</sgmltag> должен быть задан для каждого <link linkend="gui_element_fieldGroup_field">поля</link> в отдельности, либо представление полей должно задаваться разработчиком.</para>
            </listitem>
            <listitem>
              <para id="gui_attr_fieldGroup_collapsable">При установке  атрибута <sgmltag>collapsable</sgmltag>   в значение <literal>true</literal> компонент может сворачивать свое содержимое.</para>
              <figure>
                <title/>
                <mediaobject>
                  <imageobject>
                    <imagedata contentwidth="80%" align="center" fileref="img/gui_fieldGroup_collapsable.png"/>
                  </imageobject>
                </mediaobject>
              </figure>
            </listitem>
            <listitem>
              <para id="gui_attr_fieldGroup_captionAlignment"><sgmltag>captionAlignment</sgmltag> − необязательный атрибут, задает позицию отображения заголовков полей. Может принимать два значения: <literal>LEFT</literal>, <literal>TOP</literal>.</para>
              <figure>
                <title/>
                <mediaobject>
                  <imageobject>
                    <imagedata align="center" fileref="img/gui_FieldGroup_captionAlignment.png"/>
                  </imageobject>
                </mediaobject>
              </figure>
            </listitem>
            <listitem>
              <para id="gui_attr_fieldGroup_border">Атрибут <sgmltag>border</sgmltag> имеет два значения: <literal>hidden</literal> и <literal>visible</literal>. С помощью установки атрибута <sgmltag>border</sgmltag> в значение <literal>visible</literal> компонент <sgmltag>fieldGroup</sgmltag> выделяется рамкой. По умолчанию рамки вокруг компонента <sgmltag>fieldGroup</sgmltag> нет.</para>
            </listitem>
          </itemizedlist>
          <para id="gui_element_fieldGroup_column">Компонент <sgmltag>fieldGroup</sgmltag> состоит из списков <link linkend="gui_element_fieldGroup_field">полей</link>, сгруппированных в элементе <sgmltag>column</sgmltag>. </para>
          <itemizedlist>
            <listitem>
              <para id="gui_attr_fieldGroup_width">С помощью атрибута <sgmltag>width</sgmltag> задается ширину всех полей (без учета заголовка) в колонке. Это значение может быть перекрыто в каждом отдельном поле.</para>
            </listitem>
            <listitem>
              <para id="gui_attr_fieldGroup_flex">Атрибут <sgmltag>flex</sgmltag> определяет  соотношение ширин колонок.</para>
            </listitem>
          </itemizedlist>
          <para id="gui_element_fieldGroup_field">Элементами <link linkend="gui_element_fieldGroup_column">column</link> служат поля (<sgmltag>field</sgmltag>).</para>
          <para><sgmltag>field</sgmltag> − элемент, содержащий описание выводимого поля. Может содержать описание формата выводимого значения (<link linkend="gui_element_basic_formatter">formatter</link>) и описание валидаторов, применяемых к соответствующему полю (<link linkend="gui_element_basic_validator">validator</link>). Рассмотрим более подробно некоторые атрибуты элемента <sgmltag>field</sgmltag>. </para>
          <itemizedlist>
            <listitem>
              <para id="gui_attr_fieldGroup_field_id"><link linkend="gui_attr_basic_id">id</link> − обязательный атрибут, идентификатор поля. Имеет физический смысл: в случае, если задан <link linkend="datasources">источник данных</link>, то идентификатором поля должно быть имя атрибута, иначе − просто идентификатор поля.</para>
            </listitem>
            <listitem>
              <para id="gui_attr_fieldGroup_field_caption"><link linkend="gui_attr_basic_caption">caption</link> − необязательный атрибут, содержащий заголовок поля.</para>
            </listitem>
            <listitem>
              <para><link linkend="gui_attr_basic_visible">visible</link> − необязательный атрибут, отвечает за сокрытие поля.</para>
            </listitem>
            <listitem>
              <para><link linkend="gui_attr_basic_optionsDatasource">optionsDatasource</link> − необязательный атрибут, определяющий список возможных значений поля.</para>
            </listitem>
            <listitem>
              <para id="gui_attr_fieldGroup_field_datasource"><link linkend="gui_attr_basic_datasource">datasource</link> − необязательный атрибут, содержит имя <link linkend="datasources">источника данных</link> для конкретного поля.</para>
            </listitem>
            <listitem>
              <para id="gui_attr_fieldGroup_field_custom">Есть возможность самостоятельно задать представление поля с помощью атрибута <sgmltag>custom</sgmltag>. Значение атрибута в этом случае должно быть равно  <literal>true</literal>. Представление пользовательского поля необходимо определить в контроллере экрана. Компонент представления должен реализовывать интерфейс <code>Field</code>. Ниже представлен пример представления пользовательского поля:</para>
              <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/fieldGroup/fieldGroupCustom.txt" encoding="UTF-8" parse="text"/></programlisting>
            </listitem>
            <listitem>
              <para><link linkend="gui_attr_basic_width">width</link> − необязательный атрибут, содержит ширину поля (без учета заголовка)</para>
            </listitem>
            <listitem>
              <para id="gui_attr_fieldGroup_field_rows">Если значение атрибута <sgmltag>rows</sgmltag> больше <literal>1</literal>, то в ячейке будет компонент <link linkend="gui_TextArea">TextArea</link>.</para>
            </listitem>
            <listitem>
              <para id="gui_attr_fieldGroup_field_field"><sgmltag>field</sgmltag> − необязательный атрибут. В качестве значения атрибута указывается название компонента, который должен отображаться в поле. Например, по умолчанию для поля, соответствующего атрибуту даты и времени, отображается компонент ввода даты  <link linkend="gui_DateField">dateField</link>. Если есть необходимость, чтобы отображался <link linkend="gui_TimeField">компонент ввода времени</link>, то в качестве значения атрибута <sgmltag>field</sgmltag> нужно указать  <literal>timeField</literal>.</para>
            </listitem>
          </itemizedlist>
          <para>Атрибуты <sgmltag>fieldGroup</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row><entry align="left">
                    <link linkend="gui_attr_fieldGroup_border">border</link>
                  </entry>editable<entry align="left">
                    <link linkend="gui_attr_fieldGroup_datasource">datasource</link>
                  </entry><entry align="left">
                    <link linkend="gui_attr_basic_id">id</link>
                  </entry><entry/></row>
                <row>
                  <entry>
                    <link linkend="gui_attr_basic_caption">caption</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_editable">editable</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_stylename">stylename</link>
                  </entry>
                  <entry/>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_fieldGroup_captionAlignment">captionAlignment</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_enable">enable</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_visible">visible</link>
                  </entry>
                  <entry/>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_fieldGroup_collapsable">collapsable</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_height">height</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_width">width</link>
                  </entry>
                  <entry/>
                </row>
              </tbody></tgroup>
          </informaltable>
          <para>Элементы <sgmltag>fieldGroup</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="1" colsep="1" rowsep="1" align="left">
              <colspec colname="c1"/>
              <tbody>
                <row>
                  <entry>
                    <link linkend="gui_element_fieldGroup_field">field</link>
                  </entry>
                </row>
                <row>
                  <entry>
                    <link linkend="gui_element_fieldGroup_column">column</link>
                  </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
          <para>Атрибуты <link linkend="gui_element_fieldGroup_field">field</link>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row><entry align="left">
                    <link linkend="gui_attr_fieldGroup_field_caption">caption</link>
                  </entry>editable<entry align="left">
                    <link linkend="gui_attr_dateField_dateFormat">dateFormat</link>
                  </entry><entry>
                    <link linkend="gui_attr_textField_maxLength">maxLength</link>
                  </entry><entry>
                    <link linkend="gui_attr_timeField_showSeconds">showSeconds</link>
                  </entry></row>
                <row>
                  <entry>
                    <link linkend="gui_attr_basic_captionProperty">captionProperty</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_description">description</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_optionsDatasource">optionsDatasource</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_visible">visible</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_clickAction">clickAction</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_editable">editable</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_required">required</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_width">width</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_textField_cols_rows">cols</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_enable">enable</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_requiredMessage">requiredMessage</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_fieldGroup_field_custom">custom</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_fieldGroup_field_field">field</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_dateField_resolution">resolution</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_fieldGroup_field_datasource">datasource</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_fieldGroup_field_id">id</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_fieldGroup_field_rows">rows</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
          <para>Атрибуты <link linkend="attr_fG_column" id="element_fG_column">column</link>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row><entry align="left">
                    <link linkend="gui_attr_fieldGroup_flex">flex</link>
                  </entry>editable</row>
                <row>
                  <entry>
                    <link linkend="gui_attr_fieldGroup_width">width</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
        </section>
        <section id="gui_TokenList">
          <title>TokenList</title>
          <para>Список маркеров (<code>TokenList</code>) представляет собой компонент, имеющий упрощенный вариант отображения и формирования списка <glossterm linkend="entity">сущностей</glossterm>.</para>
          <para>Для выбора значений используется компонент, подобный <link linkend="gui_LookupPickerField">LookupPickerField</link> </para>
          <figure>
            <title/>
            <mediaobject>
              <imageobject>
                <imagedata contentwidth="310" align="center" fileref="img/gui_tokenList.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>XML-имя компонента: <sgmltag>tokenList</sgmltag></para>
          <figure>
            <title/>
            <mediaobject>
              <imageobject>
                <imagedata contentwidth="80%" align="center" fileref="img/gui_TokenList_dia.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>Компонент реализован для блоков <structname>Web Client</structname> и <structname>Desktop Client</structname>.</para>
          <para>Пример создания списка маркеров  в <glossterm linkend="screen_xml_glossentry">xml-дескрипторе</glossterm>:</para>
          <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/tokenList/tokenList.txt" encoding="UTF-8" parse="text"/></programlisting>
          <itemizedlist>
            <listitem>
              <para id="gui_attr_tokenList_position">С помощью атрибута <sgmltag>position</sgmltag> можно задавать позиционирование раскрывающегося списка. Атрибут может принимать два  значения:</para>
              <itemizedlist>
                <listitem>
                  <para><literal>TOP</literal></para>
                </listitem>
                <listitem>
                  <para><literal>BOTTOM</literal></para>
                </listitem>
              </itemizedlist>
              <figure>
                <title>Список маркеров со значением атрибута position=&quot;BOTTOM&quot;</title>
                <mediaobject>
                  <imageobject>
                    <imagedata contentwidth="310" align="center" fileref="img/gui_tokenListBottom.png"/>
                  </imageobject>
                </mediaobject>
              </figure>
            </listitem>
            <listitem>
              <para id="gui_attr_tokenList_inline">Атрибут <sgmltag>inline</sgmltag> задает отображение списка выбранных значений: вертикально или горизонтально. Значение <literal>true</literal> соответствует горизонтальному расположению, значение <literal>false</literal> − вертикальному.</para>
              <figure>
                <title>Список маркеров с горизонтальным расположением выбранных значений</title>
                <mediaobject>
                  <imageobject>
                    <imagedata contentwidth="409" align="center" fileref="img/gui_tokenListInline.png"/>
                  </imageobject>
                </mediaobject>
              </figure>
            </listitem>
            <listitem>
              <para id="gui_attr_tokenList_simple">Установка атрибута <sgmltag>simple</sgmltag> в значение <literal>true</literal> позволяет сворачивать компонент, оставляя только кнопку добавления. При нажатии на кнопку добавления сразу показывается экран списка экземпляров <glossterm linkend="entity">сущности</glossterm>, для которой задан <link linkend="datasources">источник данных</link>.</para>
              <figure>
                <title>Список маркеров со значением атрибута simple=&quot;true&quot;</title>
                <mediaobject>
                  <imageobject>
                    <imagedata contentwidth="234" align="center" fileref="img/gui_tokenListSimple.png"/>
                  </imageobject>
                </mediaobject>
              </figure>
            </listitem>
          </itemizedlist>
          <para>Компонент <sgmltag>tokenList</sgmltag> должен содержать следующие элементы:</para>
          <itemizedlist>
            <listitem>
              <para id="gui_element_tokenList_lookup"><sgmltag>lookup</sgmltag> − описатель компонента выбора значений.</para>
              <itemizedlist>
                <listitem>
                  <para id="gui_attr_tokenList_lookup_lookup">Атрибут <sgmltag>lookup</sgmltag> задает вид списка.</para>
                  <figure>
                    <title/>
                    <mediaobject>
                      <imageobject>
                        <imagedata align="center" fileref="img/gui_tokenListLookup.png"/>
                      </imageobject>
                    </mediaobject>
                  </figure>
                </listitem>
                <listitem>
                  <para>Атрибут <link linkend="gui_attr_basic_lookupScreen">lookupScreen</link>  задает идентификатор экрана для выбора значений в режиме <link linkend="attr_lookup">lookup</link>.</para>
                </listitem>
                <listitem>
                  <para id="gui_attr_tokenList_lookup_openType">С помощью атрибута <sgmltag>openType</sgmltag> можно задать способ открытия окна списка экземпляров сущности:</para>
                  <itemizedlist>
                    <listitem>
                      <para><literal>NEW_TAB</literal> − открытие экрана в новой вкладке</para>
                    </listitem>
                    <listitem>
                      <para><literal>DIALOG</literal> − открытие экрана в диалоговом окне</para>
                    </listitem>
                    <listitem>
                      <para><literal>NEW_WINDOW</literal> − открытие экрана в новом окне</para>
                    </listitem>
                    <listitem>
                      <para><literal>THIS_TAB</literal> − открытие экрана в текущей вкладке</para>
                    </listitem>
                  </itemizedlist>
                </listitem>
              </itemizedlist>
            </listitem>
            <listitem>
              <para id="gui_element_tokenList_button"><sgmltag>button</sgmltag> − описатель кнопки добавления значений</para>
            </listitem>
          </itemizedlist>
          <para>Ниже расположен пример <glossterm linkend="screen_controller_glossentry">контроллера</glossterm>, в котором задаются обработчики добавления нового значения и удаления значения:</para>
          <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/tokenList/tokenListContr.txt" encoding="UTF-8" parse="text"/></programlisting>
          <para>Атрибуты <sgmltag>tokenList</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row><entry align="left">
                    <link linkend="gui_attr_basic_caption">caption</link>
                  </entry>editable<entry align="left">
                    <link linkend="gui_attr_basic_editable">editable</link>
                  </entry><entry align="left">
                    <link linkend="gui_attr_tokenList_inline">inline</link>
                  </entry><entry>
                    <link linkend="gui_attr_basic_visible">visible</link>
                  </entry></row>
                <row><entry>
                    <link linkend="gui_attr_basic_captionProperty">captionProperty</link>
                  </entry><entry align="left">
                    <link linkend="gui_attr_basic_enable">enable</link>
                  </entry>required<entry>
                    <link linkend="gui_attr_tokenList_position">position</link>
                  </entry><entry>
                    <link linkend="gui_attr_basic_width">width</link>
                  </entry></row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_datasource">datasource</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_height">height</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_tokenList_simple">simple</link>
                  </entry>
                  <entry/>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_description">description</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_id">id</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_stylename">stylename</link>
                  </entry>
                  <entry/>
                </row>
              </tbody></tgroup>
          </informaltable>
          <para>Элементы <sgmltag>tokenList</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="1" colsep="1" rowsep="1" align="left">
              <colspec colname="c1"/>
              <tbody>
                <row>
                  <entry align="left">
                    <link linkend="gui_element_tokenList_lookup">lookup</link>
                  </entry>
                </row>
                <row>
                  <entry>
                    <link linkend="gui_element_tokenList_button">button</link>
                  </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
          <para>Атрибуты <link linkend="gui_element_tokenList_lookup">lookup</link>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row><entry align="left">
                    <link linkend="gui_attr_basic_captionProperty">captionProperty</link>
                  </entry>editable<entry align="left">
                    <link linkend="gui_attr_basic_lookupScreen">lookupScreen</link>
                  </entry><entry align="left">
                    <link linkend="gui_attr_basic_optionsDatasource">optionsDatasource</link>
                  </entry><entry/></row>
                <row><entry>
                    <link linkend="gui_attr_lookupField_filterMode">filterMode</link>
                  </entry><entry align="left">
                    <sgmltag>multiselect</sgmltag>
                  </entry>required<entry/><entry/></row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_tokenList_lookup_lookup">lookup</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_tokenList_lookup_openType">openType</link>
                  </entry>
                  <entry/>
                  <entry/>
                </row>
              </tbody></tgroup>
          </informaltable>
          <para>Атрибуты <link linkend="gui_element_tokenList_button">button</link>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row><entry align="left">
                    <link linkend="gui_attr_basic_caption">caption</link>
                  </entry>editable</row>
                <row><entry>
                    <link linkend="gui_attr_basic_icon">icon</link>
                  </entry>required</row>
              </tbody></tgroup>
          </informaltable>
        </section>
        <section id="gui_ProgressBar">
          <title>ProgressBar</title>
          <para>Индикатор прогресса (<code>ProgressBar</code>) наглядно демонстрирует пользователю, на каком этапе выполнения находится некий процесс, так что пользователь сможет понять, как долго остается ждать его завершения. Индикатор выводится на
экран в виде непрерывно меняющейся полосы. Может отображать конкретное значение прогресса, например, 30%, а может отображать неопределенное состояние.</para>
          <figure>
            <title/>
            <mediaobject>
              <imageobject>
                <imagedata align="center" fileref="img/gui_progressBar.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>XML-имя компонента: <sgmltag>progressBar</sgmltag></para>
          <figure>
            <title/>
            <mediaobject>
              <imageobject>
                <imagedata contentwidth="80%" align="center" fileref="img/gui_progressBar_dia.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>Компонент реализован для блоков <structname>Web Client</structname> и <structname>Desktop Client</structname>. </para>
          <para>Для создания индикатора необходимо в <glossterm linkend="screen_xml_glossentry">xml-дескрипторе</glossterm> определить его описание:</para>
          <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/progressBar/progressBar.txt" encoding="UTF-8" parse="text"/></programlisting>
          <para>С помощью атрибута <sgmltag id="attr_indeterminate">indeterminate</sgmltag> можно задать отображение неопределенного состояния индикатора. Если значение атрибута равно <literal>true</literal>, то индикатор отображает неопределенное состояние. Значение атрибута по умолчанию равно <literal>true</literal>.</para>
          <para>Значения прогресса задачи для индикатора прогресса следует передавать в  значениях типа <code>Float</code> в диапазоне от 0.0 до 1.0.</para>
          <para>Атрибуты <sgmltag>progressBar</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row><entry align="left">
                    <link linkend="attr_align">align</link>
                  </entry>editable<entry align="left">
                    <link linkend="attr_height">height</link>
                  </entry><entry align="left">
                    <link linkend="attr_stylename">stylename</link>
                  </entry><entry/></row>
                <row>
                  <entry>
                    <link linkend="attr_editable">editable</link>
                  </entry>
                  <entry align="left">
                    <link linkend="attr_id">id</link>
                  </entry>
                  <entry>
                    <link linkend="attr_visible">visible</link>
                  </entry>
                  <entry/>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="attr_enable">enable</link>
                  </entry>
                  <entry align="left">
                    <link linkend="attr_indeterminate">indeterminate</link>
                  </entry>
                  <entry>
                    <link linkend="attr_width">width</link>
                  </entry>
                  <entry/>
                </row>
              </tbody></tgroup>
          </informaltable>
        </section>
        <section id="gui_Filter">
          <title>Filter</title>
          <para>Универсальный фильтр (<code>Filter</code>) − компонент для организации поиска данных, предназначен для отбора информации, отображаемой в таблице экземпляров <glossterm linkend="entity">сущностей</glossterm>.</para>
          <para>Типичный фильтр имеет следующий вид:</para>
          <figure>
            <title/>
            <mediaobject>
              <imageobject>
                <imagedata align="center" fileref="img/gui_filter_descr.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>Для того чтобы создать фильтр, нажмите на кнопку <guibutton>Фильтр</guibutton> и выберите значение <guilabel>Создать</guilabel>. На экране отобразится  панель редактора фильтра.</para>
          <figure>
            <title/>
            <mediaobject>
              <imageobject>
                <imagedata align="center" fileref="img/gui_filter_editor.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>В поле <guilabel>Имя</guilabel> следует ввести имя фильтра, это имя будет отображаться в списке доступных для текущего экрана фильтров.</para>
          <para>В таблице содержатся условия фильтра. Условия можно менять местами с помощью кнопок <inlinemediaobject>
              <imageobject>
                <imagedata fileref="img/gui_filter_cond_down.png"/>
              </imageobject>
            </inlinemediaobject>/<inlinemediaobject>
              <imageobject>
                <imagedata fileref="img/gui_filter_cond_up.png"/>
              </imageobject>
            </inlinemediaobject>. Созданные условия можно удалять с помощью кнопки <inlinemediaobject>
              <imageobject>
                <imagedata fileref="img/gui_filter_remove.png"/>
              </imageobject>
            </inlinemediaobject></para>
          <para>С помощью флажков можно сделать выбранное в таблице условие скрытым для пользователя (колонка <guilabel>Скрытый</guilabel>) или обязательным для заполнения (колонка <guilabel>Обязательный</guilabel>). В колонке <guilabel>Операция</guilabel> следует для <emphasis role="bold">каждого</emphasis> условия выбрать операцию из списка доступных операций.</para>
          <para>Фильтр можно сделать <firstterm>глобальным</firstterm> (то есть доступным для всех пользователей) с помощью установки флажка <guilabel>Общий для всех пользователей</guilabel>, или установить текущий фильтр в качестве фильтра по умолчанию с помощью установки флажка <guilabel>По умолчанию</guilabel>.</para>
          <para>Чтобы добавить новое условие, следует нажать кнопку <guibutton>Добавить условие</guibutton> в редакторе фильтра. На экране отобразится окно выбора условий. </para>
          <figure>
            <title/>
            <mediaobject>
              <imageobject>
                <imagedata align="center" fileref="img/gui_filter_conditions.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>Условия разделяются по группам условий. Группа <guilabel>Атрибуты</guilabel> − это те условия, которые перечислены в элементах <sgmltag>properties</sgmltag> и  <sgmltag>property</sgmltag> компонента фильтра. Группа <guilabel>Специальные условия</guilabel> − это пользовательские условия, заданные в элементе <sgmltag>custom</sgmltag>. Группы <guilabel>Группы</guilabel>, <guilabel>Динамический атрибут...</guilabel> и <guilabel>Создать новое...</guilabel> доступны для выбора всегда.</para>
          <para/>
          <para>XML-имя компонента: <sgmltag>filter</sgmltag>.</para>
          <figure>
            <title/>
            <mediaobject>
              <imageobject>
                <imagedata contentwidth="80%" align="center" fileref="img/gui_filter_dia.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>Существует два класса компонентов фильтра: для веб-приложений  и для десктоп-приложений.</para>
          <para>Компонент фильтра имеет следующие атрибуты, перечисленные ниже.</para>
          <para><sgmltag id="applyTo_attr">applyTo</sgmltag> − необязательный атрибут, содержит <link linkend="attr_id">идентификатор</link> компонента, с которым связан фильтр. Используется в случае, когда необходимо иметь доступ к <link linkend="gui_Table_presentations">представлениям</link> связного компонента. Например, сохраняя фильтр как <link linkend="search_folder">папку поиска</link> или как <link linkend="application_folder">папку приложения</link>, можно указать, какое представление будет применятся при просмотре этой папки.</para>
          <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/filter/filter.txt" encoding="UTF-8" parse="text"/></programlisting>
          <figure>
            <title/>
            <mediaobject>
              <imageobject>
                <imagedata align="center" fileref="img/gui_filter_apply_to.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para><sgmltag id="useMaxResults_attr">useMaxResults</sgmltag> − необязательный атрибут, при указании значения <literal>false</literal> фильтр не будет отображать флажок <guilabel>Показывать N строк</guilabel>. По умолчанию флажок отображается, если есть специфическое разрешение <property>cuba.gui.filter.maxResults</property> (подробнее о специфических разрешениях смотрите в <productname>Руководстве по безопасности платформы <trademark>CUBA</trademark></productname> (<ulink url="http://docs.haulmont.com/cuba/">http://docs.haulmont.com/cuba/</ulink>)). Если атрибут <sgmltag>useMaxResults</sgmltag> не указан или значение атрибута равно <literal>true</literal>, а разрешение <property>cuba.gui.filter.maxResults</property> запрещено, фильтр будет принудительно отбирать только первые N строк без возможности пользователя отключить это. Число N определяется параметрами <literal>FetchUI</literal>, <literal>DefaultFetchUI</literal>, задаваемыми в <code>PersistenceManager</code>.</para>
          <para>На рисунке далее показан вид фильтра со значением атрибута <code>useMaxResults=&quot;true&quot;</code>, запретом специфического разрешения <property>cuba.gui.filter.maxResults</property> и параметром <code>DefaultFetchUI=2</code></para>
          <figure>
            <title/>
            <mediaobject>
              <imageobject>
                <imagedata align="center" fileref="img/gui_filter_useMaxRezult.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para><sgmltag id="manualApplyRequired_attr">manualApplyRequired</sgmltag> − необязательный атрибут. Определяет, как будет   применяться фильтр. Если значение атрибута равно <literal>false</literal>, то фильтр будет применяться сразу при открытии экрана списка. Если значение атрибута равно true, то фильтр будет применяться только после нажатия на кнопку <guibutton>Применить</guibutton>. Данный атрибут имеет приоритет над общесистемным <link linkend="app_properties_glossentry">свойством</link>  <property>cuba.gui.genericFilterManualApplyRequired</property>.</para>
          <para>Если значение атрибута <sgmltag id="required_filter_attr">required</sgmltag> равно <literal>true</literal>, то  в списке фильтров значение <literal>&lt;без фильтрации&gt;</literal> не отображается, и должен быть выбран один из доступных фильтров. Если для экрана не установлен фильтр по умолчанию, то в списке выбора фильтра автоматически устанавливается первый созданный фильтр.</para>
          <para>Если значение атрибута <sgmltag id="editable_filter_attr">editable</sgmltag> равно <literal>false</literal>, то кнопка <guibutton>Фильтр</guibutton> скрывается.</para>
          <para>Компонент  <sgmltag>filter</sgmltag> может содержать следующие элементы:</para>
          <variablelist>
            <varlistentry>
              <term>
                <sgmltag>properties</sgmltag>
              </term>
              <listitem>
                <para>Элемент, определяющий набор атрибутов <glossterm linkend="entity">сущности</glossterm>, заданной <link linkend="datasources">источником данных</link>. В качестве названий атрибутов используются <glossterm linkend="localization">локализованные имена атрибутов сущностей</glossterm>. Атрибуты:</para>
                <itemizedlist>
                  <listitem>
                    <para><sgmltag id="include_filter_attr">include</sgmltag> − обязательный атрибут, содержит регулярное выражение для включения атрибутов сущности. Атрибуты-коллекции не включаются независимо от данного регулярного выражения.</para>
                    <para>Чтобы включить все атрибуты сущности, используйте значение атрибута <literal>.*</literal> </para>
                  </listitem>
                  <listitem>
                    <para><sgmltag id="exclude_filter_attr">exclude</sgmltag> − необязательный атрибут, содержит регулярное выражение для исключения атрибутов сущности из предварительно включенных с помощью <link linkend="include_filter_attr">include</link>.</para>
                    <para>Чтобы исключить несколько атрибутов, перечислите их в значении атрибута <link linkend="exclude_filter_attr">exclude</link>, разделяя символом <literal>|</literal></para>
                  </listitem>
                </itemizedlist>
                <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/filter/filter_properties.txt" encoding="UTF-8" parse="text"/></programlisting>
                <figure>
                  <title/>
                  <mediaobject>
                    <imageobject>
                      <imagedata align="center" fileref="img/gui_filter_properties.png"/>
                    </imageobject>
                  </mediaobject>
                </figure>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <sgmltag>property</sgmltag>
              </term>
              <listitem>
                <para>Элемент, определяющий один атрибут сущности. Атрибуты:</para>
                <itemizedlist>
                  <listitem>
                    <para><sgmltag id="name_filter_property_attr">name</sgmltag> − имя атрибута сущности. Может быть путем (через &quot;.&quot;) по графу <glossterm linkend="entity">сущностей</glossterm>.</para>
                    <warning>
                      <para>Если в качестве имени атрибута указан путь по графу сущностей, обязательно указание значения для атрибута <link linkend="caption_filter_attr">caption</link>.</para>
                    </warning>
                  </listitem>
                  <listitem>
                    <para><sgmltag id="caption_filter_attr">caption</sgmltag> −  атрибут для задания локализованного названия имени параметра</para>
                    <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/filter/filter_property_caption.txt" encoding="UTF-8" parse="text"/></programlisting>
                    <figure>
                      <title/>
                      <mediaobject>
                        <imageobject>
                          <imagedata align="center" fileref="img/gui_filter_property_caption.png"/>
                        </imageobject>
                      </mediaobject>
                    </figure>
                  </listitem>
                  <listitem>
                    <para><sgmltag id="paramWhere_filter_attr">paramWhere</sgmltag> − необязательный атрибут для задания фильтра на список значений параметра-<glossterm linkend="entity">сущности</glossterm>. </para>
                    <para>Например, можно ограничить список предлагаемых пользователю  моделей автомобилей только моделями марки <literal>Audi</literal>.</para>
                    <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/filter/filter_paramWhere.txt" encoding="UTF-8" parse="text"/></programlisting>
                    <figure>
                      <title/>
                      <mediaobject>
                        <imageobject>
                          <imagedata align="center" fileref="img/gui_filter_paramWhere.png"/>
                        </imageobject>
                      </mediaobject>
                    </figure>
                  </listitem>
                  <listitem>
                    <para><sgmltag id="paramView_filter_attr">paramView</sgmltag> − необязательный атрибут для задания <link linkend="views">представления</link>, с которым будут загружаться список значений параметра-<glossterm linkend="entity">сущности</glossterm>. Например, <literal>_local</literal>.</para>
                  </listitem>
                </itemizedlist>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <sgmltag>custom</sgmltag>
              </term>
              <listitem>
                <para>Элемент, определяющий произвольное условие. Содержимым элемента должно быть выражение на <glossterm linkend="jpql">JPQL</glossterm> (возможно использование JPQL Macros), которое будет добавлено в условие <code>where</code> результирующего запроса. Параметр (если он есть) обозначается символом <literal>?</literal>. </para>
                <para>Пример фильтра с произвольными условиями:</para>
                <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/filter/filter_custom.txt" encoding="UTF-8" parse="text"/></programlisting>
                <para>Созданные произвольные условия попадают в раздел <guilabel>Специальные условия</guilabel> в редакторе условий.</para>
                <figure>
                  <title/>
                  <mediaobject>
                    <imageobject>
                      <imagedata align="center" fileref="img/gui_filter_custom.png"/>
                    </imageobject>
                  </mediaobject>
                </figure>
                <para>Атрибуты элемента <sgmltag>custom</sgmltag>:</para>
                <itemizedlist>
                  <listitem>
                    <para><sgmltag id="name_filter_custom_attr">name</sgmltag> − имя условия</para>
                  </listitem>
                  <listitem>
                    <para><sgmltag id="caption_filter_custom_attr">caption</sgmltag> − <link linkend="localization">локализованное</link> название условия</para>
                  </listitem>
                  <listitem>
                    <para><sgmltag id="paramClass_filter_attr">paramClass</sgmltag> или <sgmltag>class</sgmltag> − класс параметра условия</para>
                  </listitem>
                  <listitem>
                    <para><sgmltag id="inExpr_filter_attr">inExpr</sgmltag> − значение должно быть равно <literal>true</literal>, если выражение <glossterm linkend="jpql">JPQL</glossterm> содержит условие <code>in (?)</code></para>
                  </listitem>
                  <listitem>
                    <para><sgmltag id="join_filter_attr">join</sgmltag> − необязательный атрибут для задания строки, которая будет добавлена в секцию <literal>join</literal> запроса.</para>
                  </listitem>
                  <listitem>
                    <para><sgmltag>paramWhere</sgmltag> − необязательный атрибут для задания фильтра на список значений параметра-сущности.</para>
                  </listitem>
                  <listitem>
                    <para><sgmltag>paramView</sgmltag> − необязательный атрибут для задания <link linkend="views">представления</link>, с которым будут загружаться список значений параметра-<glossterm linkend="entity">сущности</glossterm>. Например,  <literal>_local</literal>.</para>
                  </listitem>
                </itemizedlist>
              </listitem>
            </varlistentry>
          </variablelist>
          <para>Атрибут <sgmltag>paramWhere</sgmltag> − необязательный атрибут для задания фильтра на список значений параметра-сущности. Содержит условие в формате <glossterm linkend="jpql">JPQL</glossterm> без слова <literal>where</literal>. Алиас сущности можно задавать любым.

Можно использовать параметры экрана, атрибуты сессии, а также <link linkend="component_filter_name_caution">компоненты</link> экрана, в том числе отображающие другие параметры.</para>
          <caution id="component_filter_name_caution">
            <title>Подсказка</title>
            <para>Как узнать имя компонента, отображающего параметр?</para>
            <para>Для этого нужно в редакторе фильтра правой кнопкой мыши вызвать контекстное меню в строке таблицы условий и выбрать в нем значение <guilabel>Показать имя компонента</guilabel>. После этого на экране отобразится окно, содержащее имя компонента.</para>
            <figure>
              <title/>
              <mediaobject>
                <imageobject>
                  <imagedata align="center" fileref="img/gui_filter_component_name.png"/>
                </imageobject>
              </mediaobject>
            </figure>
          </caution>
          <para><emphasis role="bold">Права пользователей</emphasis></para>
          <itemizedlist>
            <listitem>
              <para>Для создания/изменения/удаления глобальных фильтров пользователь должен иметь разрешение <property>cuba.gui.filter.global</property> </para>
            </listitem>
            <listitem>
              <para>Для создания/изменения новых условий пользователь должен иметь разрешение <property>cuba.gui.filter.customConditions</property></para>
            </listitem>
            <listitem>
              <para>Для возможности изменять значение флажка <guilabel>Show first N rows</guilabel> пользователь должен иметь разрешение <property>cuba.gui.filter.maxResults</property></para>
            </listitem>
          </itemizedlist>
          <para>Информацию о том, как настраивать  специфические разрешения, смотрите в <productname>Руководстве по безопасности платформы <trademark>CUBA</trademark></productname> (<ulink url="http://docs.haulmont.com/cuba/">http://docs.haulmont.com/cuba/</ulink>)</para>
          <para><emphasis role="bold">Общесистемные параметры</emphasis></para>
          <para>В системе предусмотрены следующие <glossterm linkend="app_properties_glossentry">параметры</glossterm>, влияющие на поведение фильтров:</para>
          <itemizedlist>
            <listitem>
              <para><property>cuba.gui.genericFilterManualApplyRequired</property>  − означает, что фильтр будет применяться только после нажатия пользователем соответствующей кнопки <guibutton>Применить</guibutton>. Значение по умолчанию равно <literal>true</literal>. Если выставлено значение <literal>false</literal>, то фильтр будет применяться сразу при открытии экрана списка. При открытии  экрана списка с помощью <link linkend="application_folder">папки приложения</link> или <link linkend="search_folder">папки поиска</link> значение <property>cuba.gui.genericFilterManualApplyRequired</property> не учитывается. По умолчанию в этом случае  в экране поиска фильтр будет применяться. Фильтр не применится, если значение атрибута <code>applyDefault</code> у папки явно установлено в <literal>false</literal>.</para>
            </listitem>
            <listitem>
              <para><property>cuba.gui.genericFilterChecking</property> − означает, что перед применением фильтра будет выполняться проверка его условий. Если фильтр не имеет ни одного заданного условия, то применяться он не будет. Значение по умолчанию равно <literal>true</literal>. Если значение равно  <literal>false</literal>, то проверка не производится.</para>
            </listitem>
            <listitem>
              <para><property>cuba.gui.genericFilterTreeConditionSelect</property> − включает выбор условий в древовидной структуре с возможностью обхода свойств связанных сущностей. Значение по умолчанию равно <literal>true</literal>. В случае задания значения <literal>false</literal> выбор условий осуществляется в плоском выпадающем списке из описателей условий, заданных в дескрипторе экрана.</para>
            </listitem>
            <listitem>
              <para><property>cuba.allowQueryFromSelected</property> служит для включения механизма  <link linkend="sequential_filter_para">последовательного наложения фильтров</link>. Значение по умолчанию равно <literal>true</literal>.</para>
            </listitem>
          </itemizedlist>
          <para><emphasis role="bold">Параметры вызова экрана</emphasis></para>
          <para>Существует возможность указать при вызове экрана, какой фильтр и с какими параметрами применить. Фильтр должен быть заранее создан в базе данных  и иметь заполненное поле <database>code</database>.</para>
          <para>Для указания кода фильтра в экран следует передать параметр с именем, равным <link linkend="attr_id">идентификатору</link> компонента фильтра в экране. Значение параметра − код фильтра, который нужно применить.</para>
          <para>Для установки значений параметров фильтра нужно передать параметры с именами, равными <link linkend="component_filter_name_caution">именам параметров</link>, и значения в виде строк.</para>
          <para>Пример установки фильтра из главного меню:</para>
          <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/filter/filter_from_menu.txt" encoding="UTF-8" parse="text"/></programlisting>
          <para>Следует отметить, что фильтр с установленным полем <database>code</database> обладает особыми свойствами:</para>
          <itemizedlist>
            <listitem>
              <para>Его не могут редактировать пользователи</para>
            </listitem>
            <listitem>
              <para>Название такого фильтра локализуется − в <link linkend="main_message_pack">главном пакете сообщений</link> приложения должна быть строка с ключом, равным коду фильтра.</para>
            </listitem>
          </itemizedlist>
          <para id="sequential_filter_para"><emphasis role="bold">Последовательное наложение фильтров</emphasis></para>
          <para>При включенном свойстве приложения <property>
              <link linkend="cuba.allowQueryFromSelected">cuba.allowQueryFromSelected</link>
            </property> в пользовательском интерфейсе компонента можно закреплять последний примененный фильтр и текущие результаты фильтрации. После этого можно выбрать другой фильтр или параметры и применить их на уже выбранных записях.</para>
          <para>Данный подход позволяет решить две проблемы:</para>
          <itemizedlist>
            <listitem>
              <para>Декомпозировать сложные фильтры.</para>
            </listitem>
            <listitem>
              <para>Применять фильтры на записи, отобранные с помощью папок <link linkend="application_folder">приложения</link> или <link linkend="search_folder">поиска</link>.</para>
            </listitem>
          </itemizedlist>
          <para>Чтобы применить этот механизм в пользовательском интерфейсе, выберите и примените один из фильтров. Затем нажмите на кнопку <inlinemediaobject>
              <imageobject>
                <imagedata fileref="img/gui_filter_add.png"/>
              </imageobject>
            </inlinemediaobject>. Фильтр закрепится в нижней части панели фильтра. Далее можно применить к выбранным записям другой фильтр. Так последовательно можно накладывать друг на друга любое количество фильтров. Также фильтры можно удалять последовательно с помощью кнопки <inlinemediaobject>
              <imageobject>
                <imagedata fileref="img/gui_filter_remove.png"/>
              </imageobject>
            </inlinemediaobject></para>
          <figure>
            <title/>
            <mediaobject>
              <imageobject>
                <imagedata align="center" fileref="img/gui_filter_sequential.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>Механизм последовательного наложения фильтров основан на возможности <code>
              <link linkend="dataService">DataWorker</link>
            </code> выполнять <link linkend="query_from_selected">последовательные запросы</link>.</para>
          <warning>
            <para>На момент написания данного руководства механизм последовательного наложения фильтров реализован только для блока <structname>Web Client</structname>.</para>
          </warning>
          <para>Атрибуты <sgmltag>filter</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row><entry align="left">
                    <link linkend="applyTo_attr">applyTo</link>
                  </entry>editable<entry align="left">
                    <link linkend="attr_id">id</link>
                  </entry><entry align="left">
                    <link linkend="attr_stylename">stylename</link>
                  </entry></row>
                <row>
                  <entry>
                    <link linkend="attr_datasource">datasource</link>
                  </entry>
                  <entry align="left">
                    <link linkend="manualApplyRequired_attr">manualApplyRequired</link>
                  </entry>
                  <entry>
                    <link linkend="useMaxResults_attr">useMaxResults</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="editable_filter_attr">editable</link>
                  </entry>
                  <entry align="left">
                    <link linkend="required_filter_attr">required</link>
                  </entry>
                  <entry>
                    <link linkend="attr_visible">visible</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
          <para>Атрибуты элемента <sgmltag>properties</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="1" colsep="1" rowsep="1" align="left"><colspec colname="c1"/>c <tbody>
                <row><entry align="left">
                    <link linkend="include_filter_attr">include</link>
                  </entry>editable</row>
                <row>
                  <entry>
                    <link linkend="exclude_filter_attr">exclude</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
          <para>Атрибуты элемента <sgmltag>property</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row><entry align="left">
                    <link linkend="caption_filter_attr">caption</link>
                  </entry>editable<entry align="left">
                    <link linkend="paramView_filter_attr">paramView</link>
                  </entry></row>
                <row>
                  <entry>
                    <link linkend="name_filter_property_attr">name</link>
                  </entry>
                  <entry align="left">
                    <link linkend="paramWhere_filter_attr">paramWhere</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
          <para>Атрибуты элемента <sgmltag>custom</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row><entry align="left">
                    <link linkend="caption_filter_custom_attr">caption</link>
                  </entry>editable<entry align="left">operatorType</entry><entry align="left">
                    <link linkend="paramWhere_filter_attr">paramWhere</link>
                  </entry></row>
                <row>
                  <entry>
                    <link linkend="join_filter_attr">join</link>
                  </entry>
                  <entry align="left">
                    <link linkend="paramClass_filter_attr">paramClass</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="name_filter_custom_attr">name</link>
                  </entry>
                  <entry align="left">
                    <link linkend="paramView_filter_attr">paramView</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
        </section>
      </section>
      <section id="gui_layouts">
        <title>Контейнеры</title>
        <para><link linkend="gui_BoxLayout">BoxLayout</link></para>
        <para><link linkend="gui_ButtonsPanel">ButtonsPanel</link></para>
        <para><link linkend="gui_GridLayout">GridLayout</link></para>
        <para><link linkend="gui_ScrollBoxLayout">ScrollBoxLayout</link></para>
        <para><link linkend="gui_SplitPanel">SplitPanel</link></para>
        <para><link linkend="gui_GroupBoxLayout">GroupBoxLayout</link></para>
        <para><link linkend="gui_TabSheet">TabSheet</link></para>
        <para><link linkend="gui_IFrame">IFrame</link></para>
        <section id="gui_BoxLayout">
          <title>BoxLayout</title>
          <para><code>BoxLayout</code> представляет собой контейнер с последовательным размещением компонентов.</para>
          <para>Существует 3 типа <code>BoxLayout</code>, определяемых именем XML-элемента:</para>
          <itemizedlist>
            <listitem>
              <para><sgmltag>hbox</sgmltag> − горизонтальное расположение компонентов</para>
              <figure>
                <title/>
                <mediaobject>
                  <imageobject>
                    <imagedata align="center" fileref="img/gui_hbox.png"/>
                  </imageobject>
                </mediaobject>
              </figure>
              <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/box/hbox.txt" encoding="UTF-8" parse="text"/></programlisting>
            </listitem>
            <listitem>
              <para><sgmltag>vbox</sgmltag> − вертикальное расположение компонентов. <sgmltag>vbox</sgmltag> имеет 100% ширину по умолчанию</para>
              <figure>
                <title/>
                <mediaobject>
                  <imageobject>
                    <imagedata contentwidth="182" contentdepth="245" align="center" fileref="img/gui_vbox.png"/>
                  </imageobject>
                </mediaobject>
              </figure>
              <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/box/vbox.txt" encoding="UTF-8" parse="text"/></programlisting>
            </listitem>
            <listitem>
              <para><sgmltag>flowbox</sgmltag> − горизонтальное расположение компонентов с переносом вниз. При недостатке места по горизонтали непомещающиеся компоненты будут перенесены &quot;на следующую строку&quot; (поведение аналогично <application>Swing</application> <code>FlowLayout</code>)</para>
              <figure>
                <title/>
                <mediaobject>
                  <imageobject>
                    <imagedata align="center" fileref="img/gui_flowbox.png"/>
                  </imageobject>
                </mediaobject>
              </figure>
              <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/box/flowbox.txt" encoding="UTF-8" parse="text"/></programlisting>
            </listitem>
          </itemizedlist>
          <para>Могут быть использованы следующие XML-атрибуты:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row><entry align="left">
                    <link linkend="attr_align">align</link>
                  </entry>editable<entry align="left">
                    <link linkend="attr_id">id</link>
                  </entry><entry>
                    <link linkend="attr_stylename">stylename</link>
                  </entry></row>
                <row>
                  <entry>
                    <link linkend="attr_expand">expand</link>
                  </entry>
                  <entry align="left">
                    <link linkend="attr_margin">margin</link>
                  </entry>
                  <entry>
                    <link linkend="attr_visible">visible</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="attr_height">height</link>
                  </entry>
                  <entry>
                    <link linkend="attr_spacing">spacing</link>
                  </entry>
                  <entry>
                    <link linkend="attr_width">width</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
        </section>
        <section id="gui_ButtonsPanel">
          <title>ButtonsPanel</title>
          <para>Компонент, унифицирующий использование и размещение кнопок для управления данными в таблице.</para>
          <figure>
            <title/>
            <mediaobject>
              <imageobject>
                <imagedata contentwidth="272" align="center" fileref="img/gui_buttonsPanel.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>XML-имя компонента: <sgmltag>buttonsPanel</sgmltag>.</para>
          <para>Для создания панели с кнопками нужно определить ее описание в <glossterm linkend="screen_xml_glossentry">xml-дескрипторе</glossterm>.</para>
          <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/buttonsPanel/buttonsPanel.txt" encoding="UTF-8" parse="text"/></programlisting>
          <para>Атрибут <sgmltag id="attr_alwaysVisible">alwaysVisible</sgmltag> служит для управления видимостью панели с кнопками при открытии окна списка в режиме поиска (например, при открытии окна списка из компонента <link linkend="gui_PickerField">PickerField</link>). Если значение атрибута равно <literal>true</literal>, то панель с кнопками не скрывается. По умолчанию значение атрибута равно <literal>false</literal>.</para>
          <para>Элементами панели с кнопками являются элементы <link linkend="gui_Button">button</link>.</para>
          <para>Атрибуты <sgmltag>buttonsPanel</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row>
                  <entry align="left">
                    <link linkend="attr_align">align</link>
                  </entry>
                  <entry align="left">
                    <link linkend="attr_id">id</link>
                  </entry>
                </row>
                <row>
                  <entry>
                    <link linkend="attr_alwaysVisible">alwaysVisible</link>
                  </entry>
                  <entry align="left">
                    <link linkend="attr_stylename">styleName</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="attr_expand">expand</link>
                  </entry>
                  <entry align="left">
                    <link linkend="attr_visible">visible</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="attr_height">height</link>
                  </entry>
                  <entry align="left">
                    <link linkend="attr_width">width</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
        </section>
        <section id="gui_GridLayout">
          <title>GridLayout</title>
          <para>Контейнер, располагающий компоненты по сетке.</para>
          <figure>
            <title/>
            <mediaobject>
              <imageobject>
                <imagedata align="center" fileref="img/gui_gridlayout.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>XML-имя компонента: <sgmltag>grid</sgmltag>.</para>
          <para>Для создания контейнера с табличным расположением нужно определить его описание в <glossterm linkend="screen_xml_glossentry">xml-дескрипторе</glossterm>.</para>
          <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/grid/grid.txt" encoding="UTF-8" parse="text"/></programlisting>
          <warning>
            <para>Обязательными вложенными элементами являются элементы <sgmltag>columns</sgmltag> и <sgmltag>rows</sgmltag>. </para>
          </warning>
          <para><sgmltag id="attr_layout_rows">rows</sgmltag> − обязательный элемент, содержит последовательность строк (<sgmltag>row</sgmltag>). Хотя бы один элемент строки является обязательным.</para>
          <para><sgmltag id="attr_layout_row">row</sgmltag> − элемент строки, контейнер для содержимого ряда. Состоит из контейнеров или  компонентов.</para>
          <para><sgmltag id="attr_grid_flex_row">flex</sgmltag> − необязательный атрибут для элемента <sgmltag>row</sgmltag>, задает соотношение высот рядов сетки.</para>
          <para><sgmltag id="attr_grid_columns">columns</sgmltag> − обязательный элемент, содержит последовательность <sgmltag>column</sgmltag>.</para>
          <para>Атрибут <sgmltag id="attr_grid_count">count</sgmltag> − необязательный атрибут, задает количество колонок, если не заданы элементы <sgmltag>column</sgmltag>.</para>
          <para><sgmltag id="attr_grid_column">column</sgmltag> − необязательный элемент для элемента <link linkend="attr_grid_columns">columns</link>, декларирует атрибуты колонок сетки.</para>
          <para>Атрибут <sgmltag id="attr_grid_flex_column">flex</sgmltag> − необязательный атрибут, задает соотношение ширин колонок.</para>
          <para>Атрибуты <sgmltag>grid</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row><entry align="left">
                    <link linkend="attr_height">height</link>
                  </entry>editable<entry align="left">
                    <link linkend="attr_spacing">spacing</link>
                  </entry><entry>
                    <link linkend="attr_width">width</link>
                  </entry></row>
                <row>
                  <entry>
                    <link linkend="attr_id">id</link>
                  </entry>
                  <entry align="left">
                    <link linkend="attr_stylename">styleName</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="attr_margin">margin</link>
                  </entry>
                  <entry>
                    <link linkend="attr_visible">visible</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
          <para>Элементы <sgmltag>grid</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row><entry align="left">
                    <link linkend="attr_grid_columns">columns</link>
                  </entry>editable</row>
                <row>
                  <entry>
                    <link linkend="attr_layout_rows">rows</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
          <para>Атрибуты <sgmltag>columns</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row><entry align="left">
                    <link linkend="attr_grid_count">count</link>
                  </entry>editable</row>
              </tbody></tgroup>
          </informaltable>
          <para>Атрибуты <sgmltag>row</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row><entry align="left">
                    <link linkend="attr_align">align</link>
                  </entry>editable</row>
                <row>
                  <entry>
                    <link linkend="attr_grid_flex_row">flex</link>
                  </entry>
                </row>
                <row>
                  <entry>
                    <link linkend="attr_spacing">spacing</link>
                  </entry>
                </row>
                <row>
                  <entry>
                    <link linkend="attr_visible">visible</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
        </section>
        <section id="gui_ScrollBoxLayout">
          <title>ScrollBoxLayout</title>
          <para><code>ScrollBoxLayout</code> − контейнер, который позволяет прокручивать свое содержимое.</para>
          <figure>
            <title/>
            <mediaobject>
              <imageobject>
                <imagedata align="center" fileref="img/gui_scrollBox.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>XML-имя компонента: <sgmltag>scrollBox</sgmltag></para>
          <para>Для создания контейнера с табличным расположением нужно определить его описание в <glossterm linkend="screen_xml_glossentry">xml-дескрипторе</glossterm>.</para>
          <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/scrollBox/scrollBox.txt" encoding="UTF-8" parse="text"/></programlisting>
          <para>С помощью атрибута <sgmltag id="attr_scroll_orientation">orientation</sgmltag> можно задавать направление расположения вложенных компонентов − <literal>horizontal</literal> или <literal>vertical</literal>. По умолчанию значением атрибута является <literal>vertical</literal>.</para>
          <warning>
            <para>Вложенные в <sgmltag>scrollBox</sgmltag> компоненты должны иметь фиксированные размеры или размеры по умолчанию. Нельзя устанавливать <code>height=&quot;100%&quot;</code> или <code>width=&quot;100%&quot;</code>.</para>
          </warning>
          <para>Атрибуты <sgmltag>scrollBox</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row><entry align="left">
                    <link linkend="attr_align">align</link>
                  </entry><entry>
                    <link linkend="attr_scroll_orientation">orientation</link>
                  </entry>editable</row>
                <row>
                  <entry>
                    <link linkend="attr_height">height</link>
                  </entry>
                  <entry>
                    <link linkend="attr_spacing">spacing</link>
                  </entry>
                </row>
                <row>
                  <entry>
                    <link linkend="attr_id">id</link>
                  </entry>
                  <entry>
                    <link linkend="attr_stylename">stylename</link>
                  </entry>
                </row>
                <row>
                  <entry>
                    <link linkend="attr_margin">margin</link>
                  </entry>
                  <entry>
                    <link linkend="attr_width">width</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
        </section>
        <section id="gui_SplitPanel">
          <title>SplitPanel</title>
          <para>Панель с разделителем (<code>SplitPanel</code>) − контейнер, разбитый на две области, размер которых по одному из направлений (горизонтали либо вертикали) можно менять путем перемещения разделителя. На рисунке показан пример разбивки области окна на три панели. Во внешней панели формируется горизонтальная граница, которая отделяет нижнюю панель от верхней. Верхняя панель разделяется по вертикали.</para>
          <figure>
            <title/>
            <mediaobject>
              <imageobject>
                <imagedata align="center" fileref="img/gui_splitPanel.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>XML-имя компонента: <sgmltag>split</sgmltag>.</para>
          <para>Для создания панели с разделителем нужно определить ее описание в <glossterm linkend="screen_xml_glossentry">xml-дескрипторе</glossterm>.</para>
          <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/split/split.txt" encoding="UTF-8" parse="text"/></programlisting>
          <para>При создании панели с разделителем нужно указать ориентацию разделителя с помощью атрибута <sgmltag id="attr_layout_orientation">orientation</sgmltag>. По умолчанию значение атрибута равно <literal>vertical</literal>.</para>
          <para id="attr_layout_pos"><sgmltag>pos</sgmltag> − необязательный атрибут, определяет процентное соотношение областей. Например, <code>pos=&quot;30%&quot;</code> означает соотношение областей 30/70. По умолчанию соотношение областей составляет 50/50.</para>
          <warning>
            <para>Обязательными вложенными элементами являются два контейнера или компонента.</para>
          </warning>
          <para>Атрибуты <sgmltag>split</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row><entry align="left">
                    <link linkend="attr_id">id</link>
                  </entry>editable<entry align="left">
                    <link linkend="attr_layout_pos">pos</link>
                  </entry></row>
                <row>
                  <entry>
                    <link linkend="attr_height">height</link>
                  </entry>
                  <entry align="left">
                    <link linkend="attr_width">width</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="attr_layout_orientation">orientation</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
        </section>
        <section id="gui_GroupBoxLayout">
          <title>GroupBox</title>
          <para>Контейнер, позволяющий выделить рамкой группу объектов, задать им общий заголовок и описание. Кроме того, он умеет сворачивать свое содержимое.</para>
          <figure>
            <title/>
            <mediaobject>
              <imageobject>
                <imagedata contentwidth="188" contentdepth="270" align="center" fileref="img/gui_groupBox.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>XML-имя компонента: <sgmltag>groupBox</sgmltag>.</para>
          <para>Для создания контейнера с названием и рамкой нужно определить его описание в <glossterm linkend="screen_xml_glossentry">xml-дескрипторе</glossterm>.</para>
          <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/groupBox/groupBox.txt" encoding="UTF-8" parse="text"/></programlisting>
          <para>Атрибут <sgmltag id="attr_group_orientation">orientation</sgmltag>  задает направление расположения вложенных компонентов − <literal>horizontal</literal> или <literal>vertical</literal>. По умолчанию значением атрибута является <literal>vertical</literal>.</para>
          <para><sgmltag id="attr_group_collapsable">collapsable</sgmltag> − необязательный атрибут, в значении <literal>true</literal> компонент может сворачивать свое содержимое. В верхнем нижнем углу контейнера появляется значок <inlinemediaobject>
              <imageobject>
                <imagedata fileref="img/gui_groupBox_minus.png"/>
              </imageobject>
            </inlinemediaobject>/<inlinemediaobject>
              <imageobject>
                <imagedata fileref="img/gui_groupBox_plus.png"/>
              </imageobject>
            </inlinemediaobject>.</para>
          <para><sgmltag id="attr_group_collapsed">collapsed</sgmltag> − необязательный атрибут, в значении <literal>true</literal> компонент будет свернут по умолчанию.</para>
          <figure>
            <title/>
            <mediaobject>
              <imageobject>
                <imagedata contentwidth="80%" align="center" fileref="img/gui_groupBox_collapsed.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>Атрибуты <sgmltag>groupBox</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row><entry align="left">
                    <link linkend="attr_caption">caption</link>
                  </entry>editable<entry align="left">
                    <link linkend="attr_description">description</link>
                  </entry><entry>
                    <link linkend="attr_id">id</link>
                  </entry><entry>
                    <link linkend="attr_stylename">stylename</link>
                  </entry></row>
                <row>
                  <entry>
                    <link linkend="attr_group_collapsable">collapsable</link>
                  </entry>
                  <entry align="left">
                    <link linkend="attr_expand">expand</link>
                  </entry>
                  <entry>
                    <link linkend="attr_orientation">orientation</link>
                  </entry>
                  <entry>
                    <link linkend="attr_width">width</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="attr_group_collapsed">collapsed</link>
                  </entry>
                  <entry>
                    <link linkend="attr_height">height</link>
                  </entry>
                  <entry>
                    <link linkend="attr_spacing">spacing</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
        </section>
        <section id="gui_TabSheet">
          <title>TabSheet</title>
          <para>Панель с вкладками (<code>TabSheet</code>) позволяет выводить на экран вкладки (<sgmltag>tabs</sgmltag>) − панели, имеющие название. При нажатии пользователем на названии вкладки <code>TabSheet</code> выводит на экран соответствующие выбранной вкладке элементы пользовательского интерфейса.</para>
          <figure>
            <title/>
            <mediaobject>
              <imageobject>
                <imagedata align="center" fileref="img/gui_tabsheet.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>XML-имя компонента: <sgmltag>tabSheet</sgmltag>.</para>
          <para>Для создания панели с вкладками нужно определить ее описание в <glossterm linkend="screen_xml_glossentry">xml-дескрипторе</glossterm>.</para>
          <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/tabsheet/tabsheet.txt" encoding="UTF-8" parse="text"/></programlisting>
          <para>Как видно, компонент <sgmltag>tabSheet</sgmltag> состоит из элементов <sgmltag>tab</sgmltag>.</para>
          <para>Элемент <sgmltag>tab</sgmltag> может содержать как другой <link linkend="gui_layouts">контейнер</link>, так и <link linkend="gui_components">компонент</link>.</para>
          <para>Атрибут <link linkend="attr_id" id="attr_tabsheet_id">id</link> является идентификатором вкладки. Следует отметить, что вкладка не является компонентом, и данный идентификатор используется только в рамках <code>TabSheet</code>.</para>
          <para>Атрибут <sgmltag id="attr_tabsheet_lazy">lazy</sgmltag> задает отложенную загрузку содержимого вкладки. При открытии экрана <sgmltag>lazy</sgmltag>-вкладки не загружают свое содержимое, что приводит к созданию меньшего количества компонентов в памяти и, как следствие, к меньшему количеству запросов к БД. Компоненты вкладки загружаются только в тот момент, когда пользователь выбирает данную вкладку. Значение по умолчанию равно <literal>false</literal>. Если компоненты <sgmltag>lazy</sgmltag>-вкладки требуют инициализации, проводить ее нужно не напрямую в методе <code>init()</code> <glossterm linkend="screen_controller_glossentry">контроллера</glossterm>, а в слушателе на переключение вкладок <code>TabSheet.TabChangeListener.</code></para>
          <para>В десктоп-приложении есть возможность открывать вкладки в новом окне. Для этого нужно атрибуту <sgmltag id="attr_detachable">detachable</sgmltag> присвоить значение <literal>true</literal>.</para>
          <figure>
            <title>Вид отделяемой вкладки</title>
            <mediaobject>
              <imageobject>
                <imagedata contentwidth="80%" align="center" fileref="img/gui_tabsheetDetachable.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>Атрибуты <sgmltag>tabSheet</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row><entry align="left">
                    <link linkend="attr_height">height</link>
                  </entry>editable<entry align="left">
                    <link linkend="attr_visible">visible</link>
                  </entry></row>
                <row>
                  <entry>
                    <link linkend="attr_id">id</link>
                  </entry>
                  <entry align="left">
                    <link linkend="attr_width">width</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="attr_stylename">stylename</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
          <para>Атрибуты элемента  <sgmltag>tab</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row><entry align="left">
                    <link linkend="attr_caption">caption</link>
                  </entry>editable<entry align="left">
                    <link linkend="attr_expand">expand</link>
                  </entry><entry>
                    <link>margin</link>
                  </entry></row>
                <row>
                  <entry>
                    <link linkend="attr_detachable">detachable</link>
                  </entry>
                  <entry align="left">
                    <link linkend="attr_tabsheet_id">id</link>
                  </entry>
                  <entry>
                    <link linkend="attr_spacing">spacing</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="attr_enable">enable</link>
                  </entry>
                  <entry>
                    <link linkend="attr_tabsheet_lazy">lazy</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
        </section>
        <section id="gui_IFrame">
          <title>IFrame</title>
          <para>Элемент <sgmltag>iframe</sgmltag> предназначен для включения в экран <link linkend="frame">фрейма</link>.</para>
          <para>Атрибуты:<itemizedlist>
              <listitem>
                <para><sgmltag id="attr_frame_src">src</sgmltag> − путь к XML-дескриптору фрейма</para>
              </listitem>
              <listitem>
                <para><sgmltag>screen</sgmltag> - идентификатор фрейма в <filename>screens.xml</filename> (если имеется)</para>
              </listitem>
            </itemizedlist> Должен быть указан один из этих атрибутов. Если указано оба, фрейм будет загружен из явно указанного в <sgmltag>src</sgmltag> файла. </para>
          <para>Другие атрибуты <sgmltag>iframe</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="3" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c4"/>c <tbody>
                <row><entry align="left">
                    <link linkend="attr_align">align</link>
                  </entry>editable<entry align="left">
                    <link linkend="attr_stylename">stylename</link>
                  </entry></row>
                <row>
                  <entry>
                    <link linkend="attr_height">height</link>
                  </entry>
                  <entry align="left">
                    <link linkend="attr_visible">visible</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="attr_id">id</link>
                  </entry>
                  <entry>
                    <link linkend="attr_width">width</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
        </section>
      </section>
      <section>
        <title>Разное</title>
        <section>
          <title>AccessControl</title>
          <para>Компонент <code>accessControl</code> предназначен для декларативного управления доступом к частям экрана. Он представляет собой контейнер, который никак не отображает себя на экране, а только управляет атрибутами <parameter>visible</parameter> и <parameter>editable</parameter> входящих в него компонентов.</para>
          <para>Состояние управляемых компонентов определяется на основе двух элементов, вложенных в <code>accessControl</code>: <parameter>visible</parameter> и <parameter>editable</parameter>.</para>
          <para>Соответствующее значение принимается либо из скрипта, возвращающего <type>boolean</type>, либо из свойства объекта <code>AccessData</code>, связанного с компонентом (см. ниже).
Скрипт задается либо атрибутом <parameter>script</parameter>, либо in-place в тексте элемента. 
Свойство объекта <code>AccessData</code> задается атрибутом <parameter>property</parameter> и имеет больший приоритет, чем скрипт.</para>
          <warning>
            <para>В случае <parameter>visible=false</parameter> вложенные компоненты вообще не создаются, поэтому будьте осторожны при обращении к ним из контроллера.</para>
          </warning>
          <para>
                <programlisting>&lt;tab id=&quot;mainTab&quot; caption=&quot;msg://mainTab&quot;&gt;
            &lt;accessControl data=&quot;workflow.client.web.ui.card.CardAccessData&quot; param=&quot;accessData&quot;&gt;
            &lt;editable property=&quot;notStarted&quot;/&gt;

            &lt;vbox margin=&quot;true&quot; expand=&quot;attachmentsPane&quot;&gt;
                ...</programlisting>
            </para>
          <section>
            <title>Объект AccessData</title>
            <para>В связи с тем, что одни и те же параметры доступа могут многократно потребоваться в разных частях экрана и в коде контроллера, компонент <code>accessControl</code> может быть связан с объектом Java|Groovy, вычисляющим и хранящим эти параметры. Т.о. дорогостоящая инициализация параметра доступа производится только один раз, и затем доступна на протяжении жизни экрана.</para>
            <para>Для связи компонента с данными доступа создайте класс, унаследованный от <code>AbstractAccessData</code>, и задайте следующие атрибуты компонента <code>accessControl</code>:</para>
            <itemizedlist>
              <listitem>
                <para><emphasis role="bold">data</emphasis> − имя класса <code>AccessData</code></para>
              </listitem>
              <listitem>
                <para><emphasis role="bold">param</emphasis> − имя параметра экрана, в котором будет сохранен объект <code>AccessData</code></para>
              </listitem>
            </itemizedlist>
            <para>В момент создания экрана загрузчик компонента <code>accessControl</code> проверяет наличие экземпляра <code>AccessData</code> в указанном параметре, и если его там нет, создает новый экземпляр.</para>
            <para>В дальнейшем в коде контроллера можно получить экземпляр <code>AccessData</code> из параметров экрана, например:</para>
            <programlisting>AbstractWfAccessData accessData = getContext().getParamValue(&quot;accessData&quot;);</programlisting>
            <para>При создании класса <code>AccessData</code> следует иметь в виду, что в параметры экрана-редактора всегда передается параметр <parameter>param$item</parameter>, содержащий текущий редактируемый экземпляр сущности. Однако этот экземпляр загружен по view вызывающего экрана, а не по view редактора.</para>
            <para>Свойства <code>AccessData</code>, на которые можно ссылаться из компонента <code>accessControl</code>, должны быть реализованы по стандарту JavaBeans: методами с сигнатурой boolean <methodname>getXxx()</methodname></para>
            <para>
            <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/CardAccessData.java" encoding="UTF-8" parse="text"/></programlisting>
            </para>
          </section>
        </section>
        <section id="gui_Action">
          <title>Action</title>
          <para><code>Action</code> − интерфейс, абстрагирующий действие от визуального компонента.</para>
          <para>Визуальный компонент, содержащий одно действие, реализует интерфейс <interface>Component.ActionOwner</interface>. Это, например, <code>Button</code>.</para>
          <para>Визуальный компонент, содержащий несколько действий, реализует интерфейс <interface>Component.ActionsHolder</interface>. Это <code>Window</code>, <code>IFrame</code>, <code>Table</code> и ее наследники, <code>Tree</code>, <code>PopupButton</code>, <code>PickerField</code>, <code>LookupPickerField</code>.</para>
          <section>
            <title>Декларативное создание действий</title>
            <para>В дескрипторе экрана может быть задан набор действий для некоторого <code>ActionsHolder</code>.</para>
            <itemizedlist>
              <title>Доступные атрибуты действия</title>
              <listitem>
                <para><parameter>id</parameter> − идентификатор, должен быть уникален в рамках данного <code>ActionsHolder</code></para>
              </listitem>
              <listitem>
                <para>caption</para>
              </listitem>
              <listitem>
                <para>icon</para>
              </listitem>
              <listitem>
                <para>enable</para>
              </listitem>
              <listitem>
                <para>visible − в отличие от компонентов Groovy-выражения не поддерживаются</para>
              </listitem>
              <listitem>
                <para><parameter>invoke</parameter> − имя вызываемого метода контроллера. Метод должен быть <code>public</code>, не возвращать результата, и либо не иметь аргументов, либо иметь один аргумент типа <code>Component</code>. Если метод имеет аргумент <code>Component</code>, то при вызове в него будет передан экземпляр визуального компонента, запустившего данное действие.</para>
              </listitem>
              <listitem>
                <para><parameter>shortcut</parameter> − доступен только для действий, задаваемых в окне или фрейме. Задает комбинацию клавиш для вызова.</para>
              </listitem>
            </itemizedlist>
            <para>Примеры:</para>
            <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/action/example1.txt" encoding="UTF-8" parse="text"/></programlisting>
            <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/action/example2.txt" encoding="UTF-8" parse="text"/></programlisting>
            <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/action/example3.txt" encoding="UTF-8" parse="text"/></programlisting>
          </section>
          <section>
            <title>Использование в кнопках</title>
            <para>Действия, заданные для некоторого <code>ActionsHolder</code>, могут быть использованы в компонентах <code>ActionOwner</code>, например в <code>Button</code>. Для этого достаточно указать полное имя действия в соотв. атрибуте. Например:</para>
            <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/action/example4.txt" encoding="UTF-8" parse="text"/></programlisting>
            <para>При этом Button возьмет значения атрибутов caption, icon, enable, visible из назначенного действия.</para>
          </section>
          <section id="standard_actions">
            <title>Стандартные действия</title>
            <para>Для наследников ListComponent (это Table и Tree) существует набор стандартных действий, определяемых перечислением ListActionType. Для таких действий не нужно определять никаких атрибутов, кроме идентификатора. Например:</para>
            <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/action/example5.txt" encoding="UTF-8" parse="text"/></programlisting>
            <para>Для компонентов PickerField и LookupPickerField существует набор стандартных действий, определяемых перечислением PickerField.ActionType. Для таких действий не нужно определять никаких атрибутов, кроме идентификатора. Например:</para>
            <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/action/example6.txt" encoding="UTF-8" parse="text"/></programlisting>
          </section>
          <section>
            <title>Программное создание и управление действиями</title>
            <para>Базовым классом реализации действий является <code>AbstractAction</code>. Пример использования:</para>
            <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/action/example7.txt" encoding="UTF-8" parse="text"/></programlisting>
            <para>При выполнении метода <methodname>addAction()</methodname> реализация <code>ActionsHolder</code> проверяет, нет ли уже в нем действия с таким же идентификатором. Если есть, то имеющееся действие будет заменено на новое переданное. Поэтому можно безопасно, например, декларировать стандартное действие в дескрипторе экрана, а затем в контроллере создать новое с переопределенными методами, и добавить в <code>ActionsHolder</code>.</para>
            <para>Кроме создания наследников <code>AbstractAction</code> или стандартных действий, возможно конфигурирование декларативно созданных действий путем получения их в контроллере и установки атрибутов. Например:</para>
            <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/action/example8.txt" encoding="UTF-8" parse="text"/></programlisting>
            <para>При этом во всех визуальных компонентах, связанных с данным действием, значение соответствующего атрибута также изменится.</para>
          </section>
        </section>
        <section id="gui_Table_aggregation">
          <title>Aggregation</title>
          <para>Механизм задания агрегаций для колонок в Table.</para>
          <itemizedlist>
            <title>Атрибуты aggregation</title>
            <listitem>
              <para>type −  функция агрегирования:</para>
              <itemizedlist>
                <listitem>
                  <para>SUM − сумма</para>
                </listitem>
                <listitem>
                  <para>AVG − среднее значение</para>
                </listitem>
                <listitem>
                  <para>COUNT − количество</para>
                </listitem>
                <listitem>
                  <para>MIN − минимальное значение</para>
                </listitem>
                <listitem>
                  <para>MAX − максимальное значение</para>
                </listitem>
              </itemizedlist>
            </listitem>
            <listitem>
              <para>formatter − задает формат вывода агрегированного значения.</para>
            </listitem>
          </itemizedlist>
          <para>Логика применения форматирования к агрегированному значению следующая: если в элементе <code>aggregation</code> указан <parameter>formatter</parameter>, то применяется он; иначе применяется <parameter>formatter</parameter> соответствующего агрегированному значению <parameter>datatype</parameter>.</para>
          <para>
          <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="source/section_gui/aggregation/example1.txt" encoding="UTF-8" parse="text"/></programlisting>
          </para>
        </section>
        <section id="gui_Table_presentations">
          <title>Presentation </title>
          <para>TODO</para>
        </section>
      </section>
      <section>
        <title>Элементы XML</title>
        <variablelist>
          <varlistentry id="gui_element_basic_formatter">
            <term>formatter</term>
            <listitem>
              <para>XML-элемент formatter задает класс, который будет применен для преобразования значения в строку.</para>
              <para>Атрибуты:</para>
              <itemizedlist>
                <listitem>
                  <para>class − имя класса, реализующего интерфейс <code>com.haulmont.cuba.gui.components.Formatter</code></para>
                </listitem>
              </itemizedlist>
            </listitem>
          </varlistentry>
          <varlistentry id="gui_element_basic_validator">
            <term>validator</term>
            <listitem>
              <para>XML-элемент для задания механизма валидации значений, введенных в визуальном компоненте.</para>
              <para>Атрибуты:</para>
              <itemizedlist>
                <listitem>
                  <para>script − путь к скрипту Groovy, осуществляющему валидацию</para>
                </listitem>
                <listitem>
                  <para>class − имя класса Java, реализующего интерфейс <code>Field.Validator</code></para>
                </listitem>
                <listitem>
                  <para>message − сообщение, выводимое пользователю в случае ошибки валидации. Атрибут должен содержать ключ сообщения в пакете, например, message=&quot;msg://infoTextField.validationMsg&quot;</para>
                </listitem>
              </itemizedlist>
              <para>Выбор механизма валидации осуществляется следующим образом:</para>
              <itemizedlist>
                <listitem>
                  <para>Если не указано значение атрибута script, и сам элемент validator не содержит текста выражения Groovy, то в качестве валидатора используется класс, указанный в атрибуте class.</para>
                </listitem>
                <listitem>
                  <para>Если элемент validator содержит текст, то он будет использован как выражение Groovy и выполнен с помощью <link linkend="scripting">Scripting</link>.</para>
                </listitem>
                <listitem>
                  <para>В противном случае с помощью <link linkend="scripting">Scripting</link> будет выполнен скрипт Groovy, указанный в атрибуте script.</para>
                </listitem>
              </itemizedlist>
              <para>В выражение или скрипт Groovy будет передана одна переменная value, содержащая значение, введенное в визуальном компоненте.</para>
              <para>Выражение или скрипт должны вернуть boolean значение: true − valid, false − not valid.</para>
              <para>CUBA уже содержит несколько реализаций наиболее часто используемых валидаторов (см. пакет <code>com.haulmont.cuba.gui.components.validators</code>), которые можно применять в своих проектах:</para>
              <itemizedlist>
                <listitem>
                  <para><code>DateValidator</code></para>
                </listitem>
                <listitem>
                  <para><code>DoubleValidator</code></para>
                </listitem>
                <listitem>
                  <para><code>EmailValidator</code></para>
                </listitem>
                <listitem>
                  <para><code>IntegerValidator</code></para>
                </listitem>
                <listitem>
                  <para><code>LongValidator</code></para>
                </listitem>
                <listitem>
                  <para><code>PatternValidator</code></para>
                </listitem>
                <listitem>
                  <para><code>ScriptValidator</code></para>
                </listitem>
              </itemizedlist>
              <para>Примеры использования:</para>
              <programlisting>&lt;field id=&quot;imei&quot;&gt;
    &lt;validator class=&quot;com.haulmont.cuba.gui.components.validators.PatternValidator&quot;
               pattern=&quot;\d{15}&quot;
               message=&quot;msg://general.imeiValidationFailed&quot;/&gt;
&lt;/field&gt;

&lt;field id=&quot;maxCountOfVisits&quot;&gt;
    &lt;validator class=&quot;com.haulmont.cuba.gui.components.validators.IntegerValidator&quot;/&gt;
&lt;/field&gt;</programlisting>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>
      <section>
        <title>Атрибуты XML</title>
        <variablelist>
          <varlistentry id="gui_attr_basic_align">
            <term>align</term>
            <listitem>
              <para>Атрибут, задающий расположение компонента относительно вышестоящего контейнера.</para>
              <para>Возможные значения:</para>
              <itemizedlist>
                <listitem>
                  <para>TOP_RIGHT</para>
                </listitem>
                <listitem>
                  <para>TOP_LEFT</para>
                </listitem>
                <listitem>
                  <para>TOP_CENTER</para>
                </listitem>
                <listitem>
                  <para>MIDDLE_RIGHT</para>
                </listitem>
                <listitem>
                  <para>MIDDLE_LEFT</para>
                </listitem>
                <listitem>
                  <para>MIDDLE_CENTER</para>
                </listitem>
                <listitem>
                  <para>BOTTOM_RIGHT</para>
                </listitem>
                <listitem>
                  <para>BOTTOM_LEFT</para>
                </listitem>
                <listitem>
                  <para>BOTTOM_CENTER</para>
                </listitem>
              </itemizedlist>
            </listitem>
          </varlistentry>
          <varlistentry id="gui_attr_basic_caption">
            <term>caption</term>
            <listitem>
              <para>XML-атрибут, устанавливающий заголовок для визуального компонента.</para>
              <para>Значением атрибута должна быть либо собственно строка сообщения, либо ключ в пакете сообщений. В случае ключа значение должно начинаться с префикса msg://</para>
              <para>Способы задания ключа:</para>
              <itemizedlist>
                <listitem>
                  <para>Короткий ключ − при этом сообщение ищется в пакете, заданном для данного экрана:</para>
                  <programlisting>caption=&quot;msg://infoFieldCaption&quot;</programlisting>
                </listitem>
                <listitem>
                  <para>Полный ключ, с заданием пакета:</para>
                  <programlisting>caption=&quot;msg://com.haulmont.refapp.gui.app/infoFieldCaption&quot;</programlisting>
                </listitem>
              </itemizedlist>
            </listitem>
          </varlistentry>
          <varlistentry id="gui_attr_basic_captionProperty">
            <term>captionProperty</term>
            <listitem>
              <para>XML-атрибут визуального компонента, реализующего интерфейс <code>OptionsField</code>.</para>
              <para>Задает имя атрибута сущности, которую содержит <link linkend="datasources">источник данных</link>, используемый для формирования списка опций (<link linkend="attr_optionsDatasource">optionsDatasource</link>).</para>
              <para>Если данный атрибут не задан, список опций будет содержать Instance Name экземпляров, содержащихся в списке.</para>
            </listitem>
          </varlistentry>
          <varlistentry id="gui_attr_basic_clickAction">
            <term>clickAction</term>
            <listitem>
              <para>Атрибут содержит описание действия, которое будет выполнено при клике в ячейке или в поле (для компонента <link linkend="gui_FieldGroup">FieldGroup</link>). Возможны два типа действий:</para>
              <itemizedlist>
                <listitem>
                  <para><code>open</code> − открывает для <glossterm linkend="entity">сущности</glossterm>, отображаемой в ячейке, экран редактирования с указанным именем, например: <code>clickAction=&quot;open:sec$User.edit&quot;</code>. Имя сущности отображается в виде ссылки:</para>
                  <figure>
                    <title/>
                    <mediaobject>
                      <imageobject>
                        <imagedata contentwidth="40%" align="center" fileref="img/gui_clickAction_open.png"/>
                      </imageobject>
                    </mediaobject>
                  </figure>
                </listitem>
                <listitem>
                  <para><code>invoke</code> − вызывает метод <glossterm linkend="screen_controller_glossentry">контроллера</glossterm> экрана с указанным именем, например: <code>clickAction=&quot;invoke:onClick&quot;</code>. Метод должен иметь единственный параметр типа <type>Object</type>, в который будет передан экземпляр сущности, отображаемой в ячейке.</para>
                </listitem>
              </itemizedlist>
            </listitem>
          </varlistentry>
          <varlistentry id="gui_attr_basic_datasource">
            <term>datasource</term>
            <listitem>
              <para>XML-атрибут компонента, реализующего интерфейс <code>DatasourceComponent</code>.</para>
              <para>Предназначен для задания <link linkend="datasources">источника данных</link> и должен содержать имя источника данных, описанного в секции <parameter>dsContext</parameter> <link linkend="screen_xml_glossentry">дескриптора</link> экрана.</para>
              <para>Атрибут property является обязательным, иначе возникает ошибка java.lang.IllegalStateException: Can&apos;t set assign datasource &apos;sampleDs&apos; for component &apos;labelInfo&apos; due &apos;property&apos; attribute is not defined. </para>
              <para>Смотрите также атрибут property.</para>
            </listitem>
          </varlistentry>
          <varlistentry id="gui_attr_basic_description">
            <term>description</term>
            <listitem>
              <para>Атрибут, задающий текст подсказки для компонента.</para>
            </listitem>
          </varlistentry>
          <varlistentry id="gui_attr_basic_editable">
            <term>editable</term>
            <listitem>
              <para>XML-атрибут, указывающий на возможность редактирования содержимого (не путать с <link linkend="attr_enable">enable</link>).</para>
              <para>Возможные значения − true, false. По умолчанию true.</para>
            </listitem>
            <listitem>На возможность редактирования содержимого для компонента, связанного с данными (наследника DatasourceComponent или List), влияет также Security. Если по данным security данный компонент должен быть недоступен для редактирования, значение атрибута editable не принимается во внимание.</listitem>
          </varlistentry>
          <varlistentry id="gui_attr_basic_enable">
            <term>enable</term>
            <listitem>
              <para>Атрибут компонента, устанавливающий его состояние &quot;enabled/disabled&quot; − доступен/недоступен.</para>
              <para>Если компонент недоступен, то он не принимает фокус ввода. Недоступность контейнера приводит к тому, что все его компоненты также становятся недоступными.

Возможные значения − true, false.

По умолчанию у всех компонентов enable = true.</para>
            </listitem>
          </varlistentry>
          <varlistentry id="gui_attr_basic_expand">
            <term>expand</term>
            <listitem>
              <para>Атрибут контейнера для управления его внутренней компоновкой.</para>
              <para>Задает компонент внутри контейнера, который необходимо &quot;развернуть&quot;, т.е. установить ему максимально возможную высоту и ширину.</para>
            </listitem>
          </varlistentry>
          <varlistentry id="gui_attr_basic_height">
            <term>height</term>
            <listitem>
              <para>Атрибут, устанавливающий высоту компонента.</para>
              <para>Может быть задана в пикселях либо в процентах от высоты вышестоящего контейнера. Например: 100px, 100%, 50. Если единица измерения не указана, подразумевается высота в пикселях.</para>
              <para>Простановка значения в % означает, что компонент по высоте займет соответствующую часть пространства, предоставляемого контейнером более высокого уровня.</para>
            </listitem>
          </varlistentry>
          <varlistentry id="gui_attr_basic_icon">
            <term>icon</term>
            <listitem>
              <para>XML-атрибут, устанавливающий пиктограмму для визуального компонента.</para>
              <para>Значением атрибута должен быть путь к файлу пиктограммы относительно каталога темы. Например:</para>
              <programlisting>icon=&quot;icons/create.png&quot;</programlisting>
              <para>Если пиктограмма должна быть выбрана в зависимости от языка пользователя, можно указать путь к ней в пакете сообщений, а в атрибуте icon − ключ сообщения, например:</para>
              <programlisting>icon=&quot;msg://addIcon&quot;</programlisting>
            </listitem>
          </varlistentry>
          <varlistentry id="gui_attr_basic_id">
            <term>id</term>
            <listitem>
              <para>Идентификатор компонента.</para>
              <para>Возможное значение − любой допустимый Java-идентификатор. Рекомендуется использовать только camelСase, например, <code>userGrid</code>, <code>filterPanel</code>.

Может быть указан для любого компонента и должен быть уникальным в пределах экрана.</para>
            </listitem>
          </varlistentry>
          <varlistentry id="gui_attr_basic_lookupScreen">
            <term>lookupScreen</term>
            <listitem>
              <para>В атрибуте  указывается идентификатор экрана, который нужно открыть для выбора экземпляра сущности.</para>
            </listitem>
          </varlistentry>
          <varlistentry id="gui_attr_basic_margin">
            <term>margin</term>
            <listitem>
              <para>Атрибут margin устанавливает наличие отступа между внешними границами и содержимым контейнера.</para>
              <para>Может иметь 2 вида значений:</para>
              <itemizedlist>
                <listitem>
                  <para>margin=&quot;true&quot; − установить отступ со всех сторон сразу</para>
                </listitem>
                <listitem>
                  <para>margin=&quot;true;false;true;false;&quot; −  установить отступ только сверху и снизу (формат значения &quot;сверху,справа,снизу,слева&quot;)</para>
                </listitem>
              </itemizedlist>
              <para>По умолчанию отступы отсутствуют.</para>
            </listitem>
          </varlistentry>
          <varlistentry id="gui_attr_basic_optionsDatasource">
            <term>optionsDatasource</term>
            <listitem>
              <para>XML-атрибут визуального компонента, реализующего интерфейс <code>OptionsField</code>.</para>
              <para>Задает имя <link linkend="datasources">источника данных</link>, используемого для формирования списка опций.</para>
              <para>Совместно с optionsDatasource может использоваться атрибут <link linkend="attr_captionProperty">captionProperty</link>.</para>
            </listitem>
          </varlistentry>
          <varlistentry id="gui_attr_basic_property">
            <term>property</term>
            <listitem>
              <para>XML-атрибут компонента, реализующего интерфейс <code>DatasourceComponent</code>.</para>
              <para>Предназначен для задания имени атрибута сущности, значение которого будет отображаться/редактироваться данным визуальным компонентом.</para>
              <para>Используется всегда совместно с атрибутом <link linkend="attr_datasource">datasource</link>.</para>
            </listitem>
          </varlistentry>
          <varlistentry id="gui_attr_basic_required">
            <term>required</term>
            <listitem>
              <para>XML-атрибут визуального компонента, реализующего интерфейс Field. Указывает, что в данное поле обязательно должно быть введено значение.</para>
              <para>Возможные значения атрибута − true, false. По умолчанию false.</para>
              <para>Совместно с required может использоваться атрибут requiredMessage.</para>
            </listitem>
          </varlistentry>
          <varlistentry id="gui_attr_basic_requiredMessage">
            <term>requiredMessage</term>
            <listitem>
              <para>XML-атрибут, используемый совместно с атрибутом <link linkend="attr_required">required</link>. Позволяет установить сообщение, выводимое пользователю в случае нарушения требования <link linkend="attr_required">required</link>.</para>
              <para>Атрибут должен содержать ключ сообщения в пакете, например: requiredMessage=&quot;msg://infoTextField.requiredMessage&quot;</para>
            </listitem>
          </varlistentry>
          <varlistentry id="gui_attr_basic_spacing">
            <term>spacing</term>
            <listitem>
              <para>Атрибут spacing устанавливает наличие отступов между компонентами внутри контейнера.</para>
              <para>Возможные значения − true, false.</para>
              <para>По умолчанию отступы отсутствуют.</para>
            </listitem>
          </varlistentry>
          <varlistentry id="gui_attr_basic_stylename">
            <term>stylename</term>
            <listitem>
              <para>Атрибут, задающий имя стиля компонента.</para>
              <para>Для веб-клиента стиль задается в CSS.</para>
            </listitem>
          </varlistentry>
          <varlistentry id="gui_attr_basic_visible">
            <term>visible</term>
            <listitem>
              <para>Атрибут   либо элемент видимости компонента.</para>
              <para>Возможные значения − true, false, либо выражение Groovy с boolean-результатом. Если выражение длинное, имеет смысл использовать не атрибут, а элемент visible внутри текущего компонента − эффект тот же. Если контейнер невидим, не видны и все его компоненты. По умолчанию все компоненты видимы.</para>
            </listitem>
          </varlistentry>
          <varlistentry id="gui_attr_basic_width">
            <term>width</term>
            <listitem>
              <para>Атрибут, устанавливающий ширину компонента.</para>
              <para>Значение может быть задано в пикселях или в процентах от ширины вышестоящего контейнера. Например: 100px, 100%, 50. Если единица измерения не указана, подразумевается ширина в пикселях. Простановка значения в % означает, что компонент по ширине займет соответствующую часть пространства, предоставляемого контейнером более высокого уровня.</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>
      <section id="gui_themes">
        <title>Создание темы приложения</title>
        <para>TODO</para>
      </section>
    </section>
    <section id="datasources">
      <title>Источники данных</title>
      <section>
        <title>Общие сведения</title>
        <para>Источники данных обеспечивают работу связанных с данными (data-aware) компонентов.</para>
        <para>Визуальные компоненты сами не обращаются к Middleware, а получают экземпляры сущностей  из связанных источников данных. При этом один источник данных может обслуживать несколько визуальных компонентов, если им нужен один и тот же экземпляр или набор экземпляров.</para>
        <para>Источники данных также отслеживают изменения содержащихся в них сущностей, и могут отправлять измененные экземпляры обратно на Middleware для сохранения в базе данных.</para>
        <para>Рассмотрим основные интерфейсы источников.</para>
        <figure>
          <title>Интерфейсы источников данных</title>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/Datasources.png"/>
            </imageobject>
          </mediaobject>
        </figure>
        <itemizedlist>
          <listitem>
            <para><code>Datasource</code> − простейший источник данных, предназначенный для работы с одним экземпляром сущности. Экземпляр устанавливается методом <code>setItem()</code> и  доступен через <code>getItem()</code>. </para>
            <para>Стандартной реализацией такого источника является класс <code>DatasourceImpl</code>, который используется, например, как главный источник данных в <link linkend="screen_edit">экранах редактирования</link> сущностей.</para>
          </listitem>
          <listitem>
            <para><code>CollectionDatasource</code> − источник данных, предназначенный для работы с коллекцией экземпляров сущности. Коллекция загружается при вызове метода <code>refresh()</code>, ключи экземпляров доступны через метод <code>getItemIds()</code>. Метод <code>setItem()</code> устанавливает, а <code>getItem()</code> возвращает  &quot;текущий&quot; экземпляр коллекции, т.е. например соответствующий выбранной в данный момент строке таблицы.</para>
            <para>Способ загрузки коллекции сущностей определяется реализацией. Наиболее типичный - загрузка с Middleware через <code>
                <link linkend="dataService">DataService</link>
              </code>, при этом для формирования JPQL запроса используются методы <code>setQuery()</code>, <code>setQueryFilter()</code>.</para>
            <para>Стандартной реализацией такого источника является класс <code>CollectionDatasourceImpl</code>, который используется в экранах, отображающих списки сущностей.</para>
            <itemizedlist>
              <listitem>
                <para><code>GroupDatasource</code> − подвид <code>CollectionDatasource</code>, предназначенный для работы с компонентом <code>
                    <link linkend="gui_GroupTable">GroupTable</link>
                  </code>.</para>
                <para>Стандартной реализацией является класс <code>GroupDatasourceImpl</code>.</para>
              </listitem>
              <listitem>
                <para><code>HierarchicalDatasource</code> − подвид <code>CollectionDatasource</code>, предназначенный для работы с компонентами <code>
                    <link linkend="gui_Tree">Tree</link>
                  </code> и  <code>
                    <link linkend="gui_TreeTable">TreeTable</link>
                  </code>.</para>
                <para>Стандартной реализацией является класс <code>HierarchicalDatasourceImpl</code>.</para>
              </listitem>
            </itemizedlist>
          </listitem>
          <listitem>
            <para><code>NestedDatasource</code> - источник данных, предназначенный для работы с экземплярами, загруженными в атрибуте другой сущности. При этом источник, содержащий сущность-хозяина, доступен методом <code>getMaster()</code>, а <link linkend="metaProperty">мета-свойство</link>, соответствующее атрибуту хозяина, содержащему экземпляры данного источника, доступно через метод <code>getProperty()</code>.</para>
            <para>Например,  в источнике <code>dsOrder</code> установлен экземпляр сущности <code>Order</code>, содержащий ссылку на экземпляр <code>Customer</code>. Тогда для связи экземпляра <code>Customer</code> с визуальными компонентами достаточно создать <code>NestedDatasource</code>, у которого хозяином является <code>dsOrder</code>, а мета-свойство указывает на атрибут <code>Order.customer</code>.</para>
            <itemizedlist>
              <listitem>
                <para><code>PropertyDatasource</code> - подвид <code>NestedDatasource</code>, предназначенный для работы с одним экземпляром или коллекцией связанных сущностей, не являющихся встроенными (embedded).</para>
                <para>Стандартные реализации: для работы с одним экземпляром - <code>PropertyDatasourceImpl</code>, для работы с коллекцией - <code>CollectionPropertyDatasourceImpl</code>, <code>GroupPropertyDatasourceImpl</code>, <code>HierarchicalPropertyDatasourceImpl</code>. Последние реализуют также интерфейс <code>CollectionDatasource</code>, однако некоторые его нерелевантные методы, связанные с загрузкой, например <code>setQuery()</code>, выбрасывают <code>UnsupportedOperationException</code>.</para>
              </listitem>
              <listitem>
                <para><code>EmbeddedDatasource</code> - подвид <code>NestedDatasource</code>, содержащий экземпляр встроенной сущности.</para>
                <para>Стандартной реализацией является класс <code>EmbeddedDatasourceImpl</code>.</para>
              </listitem>
            </itemizedlist>
          </listitem>
          <listitem>
            <para><code>RuntimePropsDatasource</code> − специфический источник, предназначенный для работы с <link linkend="runtime_properties">динамическими атрибутами</link> сущностей.</para>
          </listitem>
        </itemizedlist>
        <para>Как правило, источники данных объявляются декларативно в секции <sgmltag>dsContext</sgmltag> <link linkend="screen_xml">дескриптора экрана</link>.</para>
      </section>
      <section>
        <title>Создание источников данных</title>
        <section>
          <title>Декларативное создание</title>
          <para>Как правило источники данных объявляются декларативно в элементе <sgmltag>dsContext</sgmltag> дескриптора экрана. В зависимости от взаимного расположения элементов объявлений создаются источники двух разновидностей:<itemizedlist>
              <listitem>
                <para>если элемент расположен непосредственно в <sgmltag>dsContext</sgmltag>, создается обычный <code>Datasource</code> или <code>CollectionDatasource</code>, который содержит независимо загруженную сущность или коллекцию;</para>
              </listitem>
              <listitem>
                <para>если элемент расположен внутри элемента другого источника, создается <code>NestedDatasource</code>, при этом  внешний источник становится его хозяином. </para>
              </listitem>
            </itemizedlist></para>
          <para>Рассмотрим схему XML. </para>
          <para><sgmltag>dsContext</sgmltag> - корневой элемент.</para>
          <para>Элементы <sgmltag>dsContext</sgmltag>:<itemizedlist>
              <listitem>
                <para><sgmltag>datasource</sgmltag> - определяет источник данных, содержащий единственный экземпляр сущности. </para>
                <para>Атрибуты:<itemizedlist>
                    <listitem>
                      <para><sgmltag>id</sgmltag> - идентификатор источника, должен быть уникальным в для данного <code>DsContext</code>.</para>
                    </listitem>
                    <listitem>
                      <para><sgmltag>class</sgmltag> - Java класс сущности, которая будет содержаться в данном источнике</para>
                    </listitem>
                    <listitem>
                      <para><sgmltag>view</sgmltag> - имя <link linkend="views">представления</link> сущности. Если источник сам загружает экземпляры, то это представление будет использовано при загрузке. В противном случае это представление сигнализирует внешним механизмам о том, как нужно загрузить сущность для данного источника.</para>
                    </listitem>
                    <listitem>
                      <para><sgmltag>allowCommit</sgmltag> - при установке значения <code>false</code> метод <code>isModified()</code> данного источника всегда возвращает <code>false</code>, а метод <code>commit()</code> ничего не делает. Таким образом, изменения содержащихся в источнике сущностей игнорируются. По умолчанию <code>true</code>, т.е. изменения отслеживаются и могут быть сохранены.</para>
                    </listitem>
                    <listitem>
                      <para><sgmltag>datasourceClass</sgmltag> - нестандартный класс реализации источника данных, если необходим.</para>
                    </listitem>
                  </itemizedlist></para>
              </listitem>
              <listitem>
                <para><sgmltag>collectionDatasource</sgmltag> - определяет источник данных, содержащий коллекцию экземпляров.</para>
                <para>Атрибуты <sgmltag>collectionDatasource</sgmltag>:<itemizedlist>
                    <listitem>
                      <para><sgmltag>refreshMode</sgmltag> - режим обновления источника, по умолчанию <code>ALWAYS</code>. В режиме <code>NEVER</code> при вызове <code>refresh()</code> источник не производит загрузку данных, а только переходит в состояние <code>Datasource.State.VALID</code>, оповещает слушателей и сортирует имеющиеся в нем экземпляры. Режим <code>NEVER</code> удобен, если необходимо программно заполнить <code>CollectionDatasource</code> предварительно загруженными или созданными сущностями. Например:<programlisting>@Override
public void init(Map&lt;String, Object&gt; params) {
    Set&lt;Customer&gt; entities = (Set&lt;Customer&gt;) params.get(&quot;customers&quot;);
    for (Customer entity : entities) {
        customersDs.includeItem(entity);
    }
    customersDs.refresh();
}</programlisting></para>
                    </listitem>
                    <listitem>
                      <para><sgmltag>softDeletion</sgmltag> - значение <code>false</code> отключает режим <link linkend="soft_deletion">мягкого удаления</link> при загрузке сущностей, т.е. будут загружены также и удаленные экземпляры. По умолчанию <code>true</code>.</para>
                    </listitem>
                  </itemizedlist></para>
                <para>Элементы <sgmltag>collectionDatasource</sgmltag>:<itemizedlist>
                    <listitem>
                      <para><sgmltag>query</sgmltag> - запрос для загрузки сущностей</para>
                    </listitem>
                  </itemizedlist></para>
              </listitem>
              <listitem>
                <para><sgmltag>groupDatasource</sgmltag> - полностью аналогичен <sgmltag>collectionDatasource</sgmltag>, но создает реализацию источника данных, пригодную для использования совместно с компонентом <code>
                    <link linkend="gui_GroupTable">GroupTable</link>
                  </code>.</para>
              </listitem>
              <listitem>
                <para><sgmltag>hierarchicalDatasource</sgmltag> - аналогичен <sgmltag>collectionDatasource</sgmltag>, и создает реализацию источника данных, пригодную для использования совместно с компонентами <code>
                    <link linkend="gui_Tree">Tree</link>
                  </code> и <code>
                    <link linkend="gui_TreeTable">TreeTable</link>
                  </code>.</para>
                <para>Специфическим атрибутом является <sgmltag>hierarchyProperty</sgmltag>, задающий имя атрибута сущности, по которому строится иерархия.</para>
              </listitem>
            </itemizedlist></para>
          <para>Все созданные декларативно источники данных  регистрируются в объекте <code>DsContext</code> экрана. <code>DsContext</code> решает следующие задачи:<itemizedlist>
              <listitem>
                <para>Позволяет организовать зависимости между источниками данных, когда при навигации по одному источнику (т.е. при изменении &quot;текущего&quot; экземпляра методом <code>setItem()</code>) обновляется связанный источник. Такие зависимости дают возможность в экранах легко организовывать master-detail связи между компонентами.</para>
              </listitem>
              <listitem>
                <para>Позволяет собрать все измененные экземпляры сущностей и отправить их на Middleware в одном вызове <code>DataService.commit()</code>, т.е. сохранить в базе данных в одной транзакции.</para>
              </listitem>
            </itemizedlist></para>
          <para>Класс реализации источника выбирается неявно на основе имени элемента XML и, как было сказано выше, взаимного расположения элементов. Однако если необходимо применить нестандартный источник данных, его класс может быть явно указан в атрибуте <code>datasourceClass</code>. </para>
        </section>
        <section>
          <title>Прораммное создание</title>
          <para>При необходимости создать источник данных в Java коде рекомендуется воспользоваться специальным классом <code>DsBuilder</code>. </para>
          <para>Экземпляр <code>DsBuilder</code> параметризуется цепочкой вызовов его методов в стиле текучего (fluent) интерфейса. Если установлены параметры <code>master</code> и <code>property</code>, то в результате будет создан <code>NestedDatasource</code>, в противном случае - <code>Datasource</code> или <code>CollectionDatasource</code>.</para>
          <para>Пример:<programlisting>CollectionDatasource ds = new DsBuilder(getDsContext())
        .setJavaClass(Order.class)
        .setViewName(View.LOCAL)
        .setId(&quot;ordersDs&quot;)
        .buildCollectionDatasource();</programlisting></para>
        </section>
      </section>
      <section>
        <title>Собственные классы реализации</title>
        <para>Как правило, нестандартная реализация источника данных требуется для изменения процесса загрузки коллекции сущностей. При создании класса такого источника рекомендуется унаследовать его от <code>CollectionDatasourceImpl</code>, либо от <code>GroupDatasourceImpl</code> или <code>HierarchicalDatasourceImpl</code>, и переопределить метод <code>loadData()</code>.</para>
        <para>Пример:<programlisting>public class MyDatasource extends CollectionDatasourceImpl&lt;SomeEntity, UUID&gt; {

    private SomeService someService = AppBeans.get(SomeService.NAME);

    @Override
    protected void loadData(Map&lt;String, Object&gt; params) {
        detachListener(data.values());
        data.clear();

        for (SomeEntity entity : someService.getEntities()) {
            data.put(entity.getId(), entity);
            attachListener(entity);
        }
    }
}</programlisting></para>
        <para>Здесь <code>data</code> - поле базового класса, хранящее коллекцию загруженных экземпляров. Методы базового класса <code>detachListener()</code> и <code>attachListener()</code> управляют назначением на загруженные сущности слушателя, который оповещает источник данных об изменениях в полях экземпляров.</para>
        <para>Для создания нестандартного источника данных декларативным способом необходимо указать класс в атрибуте <sgmltag>datasourceClass</sgmltag> элемента XML. При программном содании через <code>DsBuilder</code> класс источника указывается вызовом <code>setDsClass()</code>.</para>
      </section>
      <section>
        <title>Запросы в CollectionDatasourceImpl</title>
        <para>Класс <code> CollectionDatasourceImpl</code> и его наследники <code>GroupDatasourceImpl</code>, <code>HierarchicalDatasourceImpl</code> являются стандартной реализацией источников данных, работающих с коллекциями независимых экземпляров сущностей. Эти источники загружают данные через <code>DataService</code>, отправляя на Middleware запрос на языке JPQL. Далее рассмтриваются особенности формирования таких запросов.</para>
        <section>
          <title>Возвращаемые значения</title>
          <para>Запрос должен возвращать сущности того типа, который указан при создании источника данных. Тип сущности при декларативном создании указывается в атрибуте <sgmltag>class</sgmltag> элемента XML, при создании через <code>DsBuilder</code> - в методе <code>setJavaClass()</code> или <code>setMetaClass()</code>.</para>
          <para>Кроме того, тип объекта в предложении <code>from</code> запроса должен соответствовать типу источника. Это необходимо для проведения автоматических транформаций запроса при наложении ограничений безопасности и др.</para>
          <para>Например, запрос источника данных типа <code>Customer</code> может выглядеть следующим образом:<programlisting>select c from sales$Customer c</programlisting></para>
          <para>Примеры недопустимых для источника типа <code>Customer</code> запросов:<programlisting>select c.id, c.name from sales$Customer c /* неверно - возвращает отдельные поля, а не весь объект Customer */

select o.customer from sales$Order o /* неверно - тип from (Order) отличается от типа результата (Customer) */</programlisting></para>
        </section>
        <section>
          <title>Параметры запроса</title>
          <para>JPQL запрос в источнике данных может содержать параметры нескольких видов. Вид параметра определяется по префиксу имени параметра. Префиксом является часть имени до знака &quot;$&quot;. Интерпретация имени после &quot;$&quot; рассматривается ниже.</para>
          <itemizedlist>
            <listitem>
              <para>Префикс <code>ds</code>. </para>
              <para>Значением параметра являются данные другого источника данных, зарегистрированного в этом же <code>DsContext</code>. Например:<programlisting>&lt;collectionDatasource id=&quot;customersDs&quot; class=&quot;com.sample.sales.entity.Customer&quot; view=&quot;_local&quot;&gt;
    &lt;query&gt;
        select c from sales$Customer c
    &lt;/query&gt;
&lt;/collectionDatasource&gt;

&lt;collectionDatasource id=&quot;ordersDs&quot; class=&quot;com.sample.sales.entity.Order&quot; view=&quot;_local&quot;&gt;
    &lt;query&gt;
        select o from sales$Order o where o.customer.id = :ds$customersDs
    &lt;/query&gt;
&lt;/collectionDatasource&gt;</programlisting></para>
              <para>В данном случае параметром запроса источника данных <code>ordersDs</code> будет текущий экземпляр сущности, находящийся в источнике данных <code>customersDs</code>. </para>
              <para>При использовании параметров с префиксом <code>ds</code> между источниками данных автоматически создаются зависимости, приводящие к обновлению источника если меняется значение его параметра. В приведенном примере если изменяется выбранный Покупатель, автоматически обновляется список его Заказов. </para>
              <para>Обратите внимание, что в примере запроса с параметром  левой частью оператора сравнения является значение идентификатора <code>o.customer.id</code>, а правой - экземпляр <code>Customer</code>, содержащийся в источнике <code>customersDs</code>. Такое сравнение допустимо, так как при выполнении запроса на Middleware реализация интерфейса <link linkend="query">
                  <code>Query</code>
                </link>, присваивая значения параметрам запроса, автоматически подставляет ID сущности вместо переданного экземпляра сущности.</para>
              <para>В имени параметра после префикса и имени источника может быть также указан путь по графу сущностей к атрибуту, из которого нужно взять значение, например: <programlisting>&lt;query&gt;
    select o from sales$Order o where o.customer.id = :ds$customersDs.id
&lt;/query&gt;</programlisting></para>
              <para>или<programlisting>&lt;query&gt;
    select o from sales$Order o where o.tagName = :ds$customersDs.group.tagName
&lt;/query&gt;</programlisting></para>
            </listitem>
            <listitem>
              <para>Префикс <code>custom</code>. </para>
              <para>Значение параметра будет взято из объекта <code>Map&lt;String, Object&gt;</code>, переданного в метод <code>refresh()</code> источника данных. Например:<programlisting>&lt;collectionDatasource id=&quot;ordersDs&quot; class=&quot;com.sample.sales.entity.Order&quot; view=&quot;_local&quot;&gt;
    &lt;query&gt;
        select o from sales$Order o where o.number = :custom$number
    &lt;/query&gt;
&lt;/collectionDatasource&gt;</programlisting><programlisting>Map&lt;String, Object&gt; params = new HashMap&lt;&gt;();
params.put(&quot;number&quot;, &quot;1&quot;);
ordersDs.refresh(params);</programlisting></para>
              <para>Приведение экземпляра при необходимости к его идентификатору осуществляется аналогично параметрам с префиксом <code>ds</code>. Путь по графу сущностей в имени параметра в данном случае не поддерживается. </para>
            </listitem>
            <listitem>
              <para>Префикс <code>param</code>. </para>
              <para>Значение параметра будет взято из объекта <code>Map&lt;String, Object&gt;</code>, переданного при открытии экрана в метод <code>init()</code> <link linkend="screen_controller">контроллера</link>. </para>
              <para>Приведение экземпляра при необходимости к его идентификатору осуществляется аналогично параметрам с префиксом <code>ds</code>. Поддерживается путь к атрибуту по графу сущностей в имени параметра. </para>
            </listitem>
            <listitem>
              <para>Префикс <code>component</code>. </para>
              <para>Значением параметра будет текущее значение визуального компонента, путь к которому указан в имени параметра. Например:<programlisting>&lt;query&gt;
    select o from sales$Order o where o.number = :component$filter.orderNumberField
&lt;/query&gt;</programlisting></para>
              <para>Путь к компоненту должен включать все вложенные <link linkend="frame">фреймы</link>.
</para>
              <para>Приведение экземпляра при необходимости к его идентификатору аналогично параметрам <code>ds</code>.
Поддерживается путь к атрибуту по графу сущностей в имени параметра как продолжение пути к компоненту. </para>
            </listitem>
            <listitem>
              <para>Префикс <code>session</code>. </para>
              <para>Значением параметра будет значение атрибута <link linkend="userSession">пользовательской сессии</link>, указанного в имени параметра.</para>
              <para>Значение извлекается методом <code>UserSession.getAttribute()</code>, поэтому поддерживаются также  предопределенные имена атрибутов сессии: <itemizedlist>
                  <listitem>
                    <para><code>userId</code> - ID текущего зарегистрированного или замещенного пользователя;</para>
                  </listitem>
                  <listitem>
                    <para><code>userLogin</code> - логин текущего зарегистрированного или замещенного пользователя в нижнем регистре.</para>
                  </listitem>
                </itemizedlist></para>
              <para>Пример:<programlisting>&lt;query&gt;
    select o from sales$Order o where o.createdBy = :session$userLogin
&lt;/query&gt;</programlisting></para>
              <para>Приведение экземпляра при необходимости к его идентификатору аналогично параметрам <code>ds</code>.
Путь по графу сущностей в имени параметра в данном случае не поддерживается. </para>
            </listitem>
          </itemizedlist>
        </section>
        <section>
          <title>Фильтр запроса</title>
          <para>Запрос источника данных может быть модифицирован во время работы приложения, в зависимости от вводимых пользователем условий, что позволяет эффективно фильтровать данные на уровне выборки из БД.</para>
          <para>Простейший способ обеспечения такой возможности - подключение к источнику данных специального визуального компонента <link linkend="gui_Filter">Filter</link>.</para>
          <para>Если по какой-то причине применение универсального фильтра нежелательно, можно встроить в текст запроса специальную разметку на XML, позволяющую сформировать итоговый запрос в зависимости от значений, введенных пользователем в произвольные визуальные компоненты экрана.</para>
          <para>В таком фильтре могут быть использованы следующие элементы:<itemizedlist>
              <listitem>
                <para><sgmltag>filter</sgmltag> - корневой элемент фильтра. Может непосредственно содержать  только одно условие.<itemizedlist>
                    <listitem>
                      <para><sgmltag>and</sgmltag>, <sgmltag>or</sgmltag> - логические условия, могут содержать любое количество других условий и предложений. </para>
                    </listitem>
                    <listitem>
                      <para>предложение на JPQL, которое добавляется в секцию <code>where</code>. Содержит только текст и опционально атрибут <sgmltag>join</sgmltag>, значение которого будет добавлено в соответствующее место запроса, если добавляется данное предложение <code>where</code>. </para>
                    </listitem>
                  </itemizedlist></para>
              </listitem>
            </itemizedlist></para>
          <para>Условия и предложения добавляются в итоговый запрос, только если присутствующие внутри них параметры получили значения, т.е. не равны <code>null</code>. </para>
          <para>Пример:<programlisting>&lt;query&gt;
    select distinct d from app$GeneralDoc d
    &lt;filter&gt;
        &lt;or&gt;
            &lt;and&gt;
                &lt;c join=&quot;, app$DocRole dr&quot;&gt;dr.doc.id = d.id and d.processState = :custom$state&lt;/c&gt;
                &lt;c&gt;d.barCode like :component$barCodeFilterField&lt;/c&gt;
            &lt;/and&gt;
            &lt;c join=&quot;, app$DocRole dr&quot;&gt;dr.doc.id = d.id and dr.user.id = :custom$initiator&lt;/c&gt;
        &lt;/or&gt;
    &lt;/filter&gt;
&lt;/query&gt;</programlisting></para>
          <para>В данном случае если в метод <code>refresh()</code> источника данных переданы параметры <code>state</code> и <code>initiator</code>, а в визуальном компоненте <code>barCodeFilterField</code> установлено некоторое значение, то итоговый запрос примет вид:<programlisting>select distinct d from app$GeneralDoc d, app$DocRole dr 
where 
  (
    (dr.doc.id = d.id and d.processState = :custom$state) 
    and 
    (d.barCode like :component$barCodeFilterField)
  ) 
  or 
  (dr.doc.id = d.id and dr.user.id = :custom$initiator)</programlisting></para>
          <para>Если же, к примеру, компонент <code>barCodeFilterField</code> пуст, а в <code>refresh()</code> передан только параметр <code>initiator</code>, то запрос получится следующим:<programlisting>select distinct d from app$GeneralDoc d, app$DocRole dr 
where   
  (dr.doc.id = d.id and dr.user.id = :custom$initiator)</programlisting></para>
        </section>
        <section>
          <title>Поиск подстроки без учета регистра</title>
          <para>В источниках данных можно использовать особенность выполнения JPQL запросов, описанную для интерфейса <code>
              <link linkend="query">Query</link>
            </code> уровня Middleware: для удобного формирования условия поиска без учета регистра символов и по любой части строки можно использовать префикс <code>(?i)</code> имени параметра запроса, например:<programlisting>select c from sales$Customer c where c.name like :(?i)component$customerNameField</programlisting></para>
          <para>В данном случае значение параметра, взятое из компонента <code>customerNameField</code>, будет переведено в нижний регистр и обрамлено символами &quot;%&quot;, а затем в базе данных будет выполнен SQL запрос с условием вида <code>lower(C.NAME) like ?</code></para>
          <para>Следует иметь в виду, что при таком поиске индекс, созданный в БД по полю <code>NAME</code>, не используется. </para>
        </section>
      </section>
      <section id="datasource_commitMode">
        <title>Режим коммита</title>
        <para>Любой источник данных имеет параметр типа <code>Datasource.CommitMode</code>, определяющий, куда будут отправляться измененные сущности при коммите:<itemizedlist>
            <listitem>
              <para><code>CommitMode.DATASTORE</code> - на Middleware через установленный для данного источника <code>DataSupplier</code>. </para>
            </listitem>
            <listitem>
              <para><code>CommitMode.PARENT</code> - в так называемый &quot;родительский&quot; источник данных, установленный для данного источника и доступный через метод <code>DatasourceImplementation.getParent()</code>.</para>
            </listitem>
          </itemizedlist></para>
        <para>Режим <code>CommitMode.PARENT</code> используется в экранах редактирования композитных сущностей, которые представляют собой экземпляр основной сущности (master), и связанную с ним коллекцию экземпляров детализирующей сущности (detail). При этом детализирующая сущность имеет смысл только часть как часть основной сущности, и ее изменения должны отправляться в базу данных только вместе с основной сущностью в единой транзакции.</para>
        <para>Для организации такой связи в классе основной сущности ссылка на детализирующую сущность помечается аннотацией <link linkend="composition_annotation">
            <code>@Composition</code>
          </link>.</para>
        <para>Последовательность действий и условия правильной работы режима <code>CommitMode.PARENT</code>:<itemizedlist>
            <listitem>
              <para>Открывается экран редактирования основной сущности (master), в котором в элементе <sgmltag>dsContext</sgmltag> внутри основного источника описаны источники детализирующих сущностей, обязательно  на всю глубину композиции. Например, если сущность <code>Airport</code> имеет <code>@Composition</code> коллекцию сущности <code>Terminal</code>, а та в свою очередь имеет <code>@Composition</code> коллекцию сущности <code>MeetingPoint</code>, то описание источников должно быть примерно следующим:<programlisting>&lt;datasource
        id=&quot;airportDs&quot;
        class=&quot;com.sample.app.entity.Airport&quot;
        view=&quot;airportEdit&quot;&gt;
    &lt;collectionDatasource id=&quot;terminalsDs&quot; 
                          property=&quot;terminals&quot;&gt;
        &lt;collectionDatasource id=&quot;meetingPointsDs&quot; 
                              property=&quot;meetingPoints&quot;/&gt;
    &lt;/collectionDatasource&gt;
&lt;/datasource&gt;</programlisting></para>
              <para>В данном случае источник <code>meetingPointsDs</code> не используется никакими визуальными компонентами текущего экрана, однако он все равно нужен для того, чтобы служить родительским для источников в порождаемых экранах.</para>
              <para>Все источники данного экрана имеют <code>CommitMode.DATASTORE</code>. </para>
            </listitem>
            <listitem>
              <para>Открывается экран редактирования детализирующей сущности. При этом для главный источник этого экрана имеет <code>CommitMode.PARENT</code>, и родительским для него становится соответствующий <sgmltag>collectionDatasource</sgmltag> экрана основной сущности.</para>
            </listitem>
            <listitem>
              <para>При коммите экрана детализирующей сущности измененный экземпляр попадет не в базу данных, а в <sgmltag>collectionDatasource</sgmltag> экрана основной сущности. </para>
            </listitem>
            <listitem>
              <para>При коммите экрана основной сущности измененный экземпляр детализирующей сущности будет отправлен на Middleware вместе с экземпляром основной сущности.</para>
            </listitem>
          </itemizedlist></para>
      </section>
    </section>
    <section id="background_tasks">
      <title>Фоновые задачи</title>
      <para><emphasis role="bold">Предназначение</emphasis></para>
      <para>Фоновые задачи используются на клиентском уровне для выполнения длительных процессов без заморозки пользовательского интерфейса. </para>
      <para>В платформе реализован объект <code>BackgroundWorker</code>, который предоставляется окружением и управляет фоновыми задачами</para>
      <programlisting>BackgroundWorker backgroundWorker = AppConfig.getBackgroundWorker();</programlisting>
      <para><emphasis role="bold">Использование</emphasis></para>
      <orderedlist>
        <listitem>
          <para>Задача описывается как наследник абстрактного класса <code>BackgroundTask</code>. Для нее необходимо задать окно, которому принадлежит задача, и описать главный метод <methodname>run()</methodname>.</para>
        </listitem>
        <listitem>
          <para>Создается объект управления задачей − <code>BackgroundTaskHandler</code>. Для этого задачу необходимо передать классу <code>BackgroundWorker</code>.</para>
        </listitem>
        <listitem>
          <para>Выполняется запуск задачи</para>
          <programlisting>// Задача с ограничением 10 секунд и с текущим окном в качестве родителя
final BackgroundTask&lt;Integer, Void&gt; progressIndicator = new BackgroundTask&lt;Integer, Void&gt;(10, this) {
    @Override
    public Void run(TaskLifeCycle&lt;T&gt; taskLifeCycle) {
        // 1 2 3 4 5 :-)
        for (int i = 0; i &lt; 5; i++) {
            Long res;
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException ignored) {
                return null;
            }
            // Оглашаем прогресс
            taskLifeCycle.publish(i);
        }
        return null;
    }

    @Override
    public void canceled() {
        // отменено
    }

    @Override
    public void done(Void result) {
        // завершено
    }

    @Override
    public void progress(List&lt;Integer&gt; changes) {
        // индикация прогресса
    }

    @Override
    public Map&lt;String, Object&gt; getParams() {
        // передаём параметры
        return Collections.emptyMap();
    }
};

// Получение управляющего объекта и запуск
BackgroundTaskHandler taskHandler = backgroundWorker.handle(progressIndicator);
taskHandler.execute();</programlisting>
        </listitem>
      </orderedlist>
      <para><emphasis role="bold">Объект задачи</emphasis></para>
      <para><code>BackgroundTask&lt;T, V&gt;</code> − параметризованный класс:</para>
      <itemizedlist>
        <listitem>
          <para><code>T</code> − тип объектов, показывающих прогресс задачи. Они передаются в метод <methodname>progress()</methodname> при вызове <methodname>publish()</methodname> в рабочем потоке</para>
        </listitem>
        <listitem>
          <para><code>V</code> − тип результата задачи, его можно получить после выполнения задачи или вызвать синхронно <methodname>getResult()</methodname> для ожидания.</para>
        </listitem>
      </itemizedlist>
      <para>Метод <methodname>canceled()</methodname> вызывается только в случае управляемой отмены задачи (то есть при вызове <methodname>cancel()</methodname> у <code>TaskHandler</code>).</para>
      <para>Если у задачи истек таймаут, или было закрыто окно, в котором она исполнялась, то задача будет завершена без уведомлений.</para>
      <warning>
        <para>Следует помнить, что в Java невозможно прервать поток, если он не использует операций, выбрасывающих <errorname>InterrruptedException</errorname>. Никогда не перехватывайте это исключение или все исключения с целью тихо завершить операцию. Хорошим тоном является проверка флага <code>isInterrupted()</code> у объекта <code>TaskLifeCycle</code> в различных циклических операциях, для того чтобы вовремя отменить выполнение при прерывании задачи.</para>
      </warning>
      <para>Объекты <code>BackgroundTask</code> не имеют состояния. Если придерживаться этого подхода и не заводить полей для хранения промежуточных данных, то можно использовать множество параллельно работающих задач, используя всего один объект задачи.</para>
      <para>Объект <code>BackgroundHandler</code> можно запускать всего один раз; если требуется частый перезапуск задач, то используйте <code>BackgroundTaskWrapper</code></para>
      <para><emphasis role="bold">Отображение фоновых действий для пользователя</emphasis></para>
      <para>Иногда необходимо показывать пользователю окно с прогрессом и кнопкой <guibutton>Отмена</guibutton>. Для этого есть <code>BackgroundWorkWindow&lt;T,V&gt;</code> с набором статических методов.
В окне можно отображать статус задачи и разрешать/запрещать отмену фонового процесса.</para>
      <para><emphasis role="bold">Отслеживание исполнения задач</emphasis></para>
      <para>Если Вы хотите использовать параметры из UI компонентов, то необходимо переопределить метод <methodname>Map&lt;String, Object&gt; getParams()</methodname> . Он выполняется один раз при запуске задачи в потоке UI. В методе <methodname>run</methodname> они доступны в объекте <code>TaskLifeCycle</code>, аксессор − <methodname>getParams()</methodname>.</para>
      <para>При возникновении исключительных ситуаций вызывается метод <methodname>handleException</methodname>, в котором можно отобразить ошибку на UI.</para>
      <para>Для отмены и удаления зависших задач предусмотрены следующие меры:</para>
      <orderedlist>
        <listitem>
          <para><code>WatchDog</code> − поток, постоянно проверяющий задачи на истечение таймаута. Зависшие задачи прерываются и удаляются из обработки</para>
        </listitem>
        <listitem>
          <para>При закрытии родительского окна задачи она прерывается</para>
        </listitem>
        <listitem>
          <para>По истечению сессии пользователя все его задачи прерываются.
Для этого в <filename>web.xml</filename> указать:</para>
          <programlisting>&lt;listener&gt;
    &lt;listener-class&gt;com.haulmont.cuba.web.gui.utils.BackgroundWorkerListener&lt;/listener-class&gt;
&lt;/listener&gt;</programlisting>
        </listitem>
      </orderedlist>
      <para><emphasis role="bold">Объявление WatchDog</emphasis></para>
      <para>В <filename>app-web-spring.xml</filename> и <filename>app-desktop-spring.xml</filename> добавить объявление задачи по расписанию:</para>
      <programlisting>&lt;bean id=&quot;backgroundWorkerScheduler&quot; class=&quot;org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler&quot;&gt;
    &lt;property name=&quot;daemon&quot; value=&quot;true&quot;/&gt;
    &lt;property name=&quot;poolSize&quot; value=&quot;1&quot;/&gt;
&lt;/bean&gt;

&lt;task:scheduled-tasks scheduler=&quot;backgroundWorkerScheduler&quot;&gt;
    &lt;task:scheduled ref=&quot;cuba_BackgroundWorker_WatchDog&quot; method=&quot;cleanupTasks&quot; fixed-delay=&quot;2000&quot;/&gt;
&lt;/task:scheduled-tasks&gt; </programlisting>
      <para><emphasis role="bold">Настройки</emphasis></para>
      <para>Для Web слоя в WebConfig настраивается частота проверки изменений на стороне клиента (браузера): <parameter>cuba.backgroundWorker.uiCheckInterval</parameter> (По умолчанию 2000 мс)</para>
    </section>
    <section>
      <title>Таймеры</title>
      <para>TODO</para>
    </section>
  </section>
  <section id="portal">
    <title>Компоненты портала</title>
    <para>В данном руководстве <firstterm>порталом</firstterm> называется клиентский <link linkend="app_tiers">блок</link>, способный решать следующие задачи:<itemizedlist>
        <listitem>
          <para>предоставлять альтернативный веб-интерфейс, как правило предназначенный для пользователей за пределами организации;</para>
        </listitem>
        <listitem>
          <para>предоставлять интерфейс для интеграции с мобильными приложениями и со сторонними системами.</para>
        </listitem>
      </itemizedlist></para>
    <para>Конкретное приложение может содержать несколько портальных модулей, предназначенных для различных целей, например в случае приложения, автоматизирующего бизнес такси это может быть публичный веб-сайт для клиентов, интеграционный модуль мобильного приложения заказа такси, интеграционный модуль мобильного приложения водителей, и т.д. </para>
    <para><link linkend="base_projects">Базовый проект</link> <structname>cuba</structname> платформы содержит в своем составе модуль <structname>portal</structname>, который является заготовкой для создания порталов в проектах. Он, во-первых, предоставляет базовую функциональность клиентского блока для работы с Middleware, а во-вторых, включает в себя универсальный <link linkend="rest_api">REST API</link> для работы с сущностями.</para>
    <section>
      <title>Базовая функциональность</title>
      <para>Рассмотрим основные компоненты, предоставляемые платформой для построения портала.<itemizedlist>
          <listitem>
            <para><code>PortalAppContextLoader</code> - загрузчик <code>
                <link linkend="appContext">AppContext</link>
              </code>, должен быть зарегистрирован в элементе <sgmltag>listener</sgmltag> файла <filename>web.xml</filename>.</para>
          </listitem>
          <listitem>
            <para><code>PortalDispatcherServlet</code> - центральный сервлет, распределяющий запросы по контроллерам <application>Spring MVC</application>, как для веб-интерфейса, так и для REST API. Набор файлов конфигурации контекста Spring определяется свойством приложения <property>
                <link linkend="cuba.dispatcherSpringContextConfig">cuba.dispatcherSpringContextConfig</link>
              </property>. Данный сервлет должен быть зарегистрирован в <filename>web.xml</filename> и отображен на корневой URL веб-приложения.</para>
          </listitem>
          <listitem>
            <para><code>App</code> - объект, содержащий информацию о текущем HTTP запросе и ссылку на объект <code>Connection</code>. Экземпляр <code>App</code> может быть получен в прикладном коде вызовом статического метода <code>App.getInstance()</code>.</para>
          </listitem>
          <listitem>
            <para><code>Connection</code> - позволяет выполнять логин и логаут пользователя на Middleware.</para>
          </listitem>
          <listitem>
            <para><code>PortalSession</code> - специфичесий для портала объект <link linkend="userSession">пользовательской сессии</link>. Возвращается интерфейсом инфраструктуры <code>
                <link linkend="userSessionSource">UserSessionSource</link>
              </code>, а также статическим методом <code>PortalSessionProvider.getUserSession()</code>.</para>
            <para>Имеет дополнительный метод <code>isAuthenticated()</code>, возвращающий <code>true</code>, если данная сессия принадлежит не-анонимному, т.е. явно зарегистрировавшемуся с логином и паролем, пользователю.</para>
            <para>При первом обращении некоторого пользователя к порталу <code>SecurityContextHandlerInterceptor</code> создает для него (или привязывает уже имеющуюся) анонимную сессию, регистрируясь на Middleware с именем пользователя, указанным в свойстве приложения <property>
                <link linkend="cuba.portal.anonymousUserLogin">cuba.portal.anonymousUserLogin</link>
              </property>. Регистрация производится методом <code>
                <link linkend="login">loginTrusted()</link>
              </code>, поэтому в блоке портала необходимо установить также свойство <property>
                <link linkend="cuba.trustedClientPassword">cuba.trustedClientPassword</link>
              </property>. Таким образом, любой анонимный пользователь портала может работать с сервисами Middleware с правами пользователя <property>cuba.portal.anonymousUserLogin</property>.</para>
            <para>Если портал содержит страницу регистрации пользователя с именем и паролем, то после выполнения <code>Connection.login()</code> при обработке запросов <code>SecurityContextHandlerInterceptor</code> устанавливает в потоке выполнения пользовательскую сессию явно зарегистрированного пользователя, и работа с Middleware происходит от его имени.</para>
          </listitem>
          <listitem>
            <para><code>PortalLogoutHandler</code> - обрабатывает навигацию на страницу логаута. Должен быть зарегистрирован в файле <filename>portal-security-spring.xml</filename> проекта.</para>
          </listitem>
        </itemizedlist></para>
      <para>Пример портала, содержащего страницу регистрации пользователей, включен в шаблон проекта,  рассмотренный в  <xref linkend="qs_setup"/></para>
    </section>
    <section id="rest_api">
      <title>REST API</title>
      <section>
        <title>Общие сведения</title>
        <para>Универсальный REST API платформы позволяет выполнять загрузку и сохранение  любых сущностей модели данных приложения посредством отправки простых HTTP запросов. Это открывает возможность легкой интеграции со сторонними приложениями самого широкого спектра - от JavaScript кода, выполняющегося в  браузере, до произвольных систем, работающих на Java, NET, PHP или любой другой платформе. </para>
        <para>Основные возможности API:<itemizedlist>
            <listitem>
              <para>загрузка экземпляров сущностей из базы данных по идентификатору или по JPQL запросу с параметрами</para>
            </listitem>
            <listitem>
              <para>сохранение новых и измененных экземпляров, удаление</para>
            </listitem>
            <listitem>
              <para>получение описания модели данных в формате HTML</para>
            </listitem>
            <listitem>
              <para>представление данных в форматах JSON и XML на выбор</para>
            </listitem>
            <listitem>
              <para>аутентификация пользователя</para>
            </listitem>
          </itemizedlist></para>
        <para>Все функции работают с данными в кодировке UTF-8. </para>
      </section>
      <section>
        <title>Включение в проект</title>
        <para>REST API реализован в модуле <structname>portal</structname> базового проекта <structname>cuba</structname>, поэтому для его использования необходимо создать модуль <structname>portal</structname> в проекте приложения. Пример содержится в шаблоне проекта,  рассмотренном в  <xref linkend="qs_setup"/> </para>
        <para>Основные элементы настройки:<itemizedlist>
            <listitem>
              <para>Добавить контроллеры REST API в контекст Spring, определяемый файлом <filename>
                  <link linkend="dispatcher-spring.xml">portal-dispather-spring.xml</link>
                </filename>:<programlisting>&lt;context:component-scan base-package=&quot;com.haulmont.cuba.portal.restapi&quot;/&gt;</programlisting></para>
            </listitem>
            <listitem>
              <para>Установить режим доступа в <filename>portal-security-spring.xml</filename>:<programlisting>&lt;intercept-url pattern=&quot;/api/**&quot; access=&quot;IS_AUTHENTICATED_ANONYMOUSLY&quot;/&gt;</programlisting></para>
            </listitem>
          </itemizedlist></para>
      </section>
      <section>
        <title>Описание функций</title>
        <para>При стандартных настройках модуля <structname>portal</structname> все запросы к REST API должны иметь URL, начинающийся с <literal>{host:port}/app-portal/api</literal>.</para>
        <para>TODO</para>
      </section>
    </section>
  </section>
  <section>
    <title>Механизмы платформы</title>
    <section id="scheduled_tasks">
      <title>Выполнение задач по расписанию</title>
      <para>Платформа предлагает два способа запуска задач по расписанию:<itemizedlist>
          <listitem>
            <para>Использование стандартного механизма <code>TaskScheduler</code> фреймворка <application>Spring</application></para>
          </listitem>
          <listitem>
            <para>Использование собственного механизма выполнения назначенных заданий</para>
          </listitem>
        </itemizedlist></para>
      <section id="scheduled_tasks_spring">
        <title>Spring TaskScheduler</title>
        <para>Данный механизм подробно описан в разделе <application>Task Execution and Scheduling</application> руководства <application>Spring Framework</application>.</para>
        <para><code>TaskScheduler</code> можно использовать для запуска методов произвольных бинов Spring в любом <link linkend="app_tiers">блоке</link> приложения - как на Middleware, так и на клиентском уровне.</para>
        <para>Пример конфигурации в файле <filename>
            <link linkend="spring.xml">spring.xml</link>
          </filename>:<programlisting>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:task=&quot;http://www.springframework.org/schema/task&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd
        http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task-3.0.xsd&quot;&gt;

    ...
    
    &lt;task:scheduled-tasks scheduler=&quot;scheduler&quot;&gt;
        &lt;task:scheduled ref=&quot;sales_Processor&quot; method=&quot;someMethod&quot; fixed-rate=&quot;60000&quot;/&gt;
        &lt;task:scheduled ref=&quot;sales_Processor&quot; method=&quot;someOtherMethod&quot; cron=&quot;0 0 1 * * MON-FRI&quot;/&gt;
    &lt;/task:scheduled-tasks&gt;
&lt;/beans&gt;</programlisting></para>
        <para>Здесь объявлены две задачи, запускающие на выполнение методы <code>someMethod()</code> и <code> someOtherMethod()</code> бина <code>sales_Processor</code>. При этом <code>someMethod()</code> запускается с момента старта приложения через фиксированные промежутки времени - 60 сек. Метод <code>someOtherMethod()</code> запускается в соответствии с расписанием, заданным выражением Cron (описание формата таких выражений см. <ulink url="http://quartz-scheduler.org/documentation/quartz-1.x/tutorials/crontrigger">http://quartz-scheduler.org/documentation/quartz-1.x/tutorials/crontrigger</ulink> ).</para>
        <para>Собственно запуск задач выполняет бин типа <code>TaskScheduler</code>, заданный в атрибуте <sgmltag>scheduler</sgmltag> элемента <sgmltag>scheduled-tasks</sgmltag>. В данном случае используется бин <code>CubaThreadPoolTaskScheduler</code> с именем <code>scheduler</code>, который сконфигурирован в модулях <structname>core</structname> и <structname>web</structname> базового проекта <structname>cuba</structname> (см. <filename>cuba-spring.xml</filename>, <filename>cuba-web-spring.xml</filename>). Этот класс содержит специфическую реализацию, выполняющую очистку <code>
            <link linkend="securityContext">SecurityContext</link>
          </code> в запускаемых на выполнение потоках.</para>
      </section>
      <section id="scheduled_tasks_cuba">
        <title>Назначенные задания CUBA</title>
        <para>Механизм назначенных заданий <application>CUBA</application> предназначен для запуска по расписанию методов произвольных бинов Spring в блоке Middleware. Целью данного механизма и отличием его от вышеупомянутого стандартного механизма <application> Spring Framework</application> являются: <itemizedlist>
            <listitem>
              <para>возможость конфигурирования заданий во время работы приложения   без остановки сервера</para>
            </listitem>
            <listitem>
              <para>координация выполнения синглтон-заданий в кластере Middleware, в том числе: <itemizedlist>
                  <listitem>
                    <para>надежная защита от одновременного выполнения </para>
                  </listitem>
                  <listitem>
                    <para>привязка заданий к серверам по приоритетам</para>
                  </listitem>
                </itemizedlist></para>
            </listitem>
          </itemizedlist></para>
        <para>Под <firstterm>синглтон</firstterm>-заданием понимается задача, которая должна выполняться в некоторый момент времени только на одном сервере. Пример - чтение из очереди и отсылка email.</para>
        <section>
          <title>Регистрация задания</title>
          <para>Задания регистрируются в таблице <code>SYS_SCHEDULED_TASK</code> базы данных, соответствующей сущности <code>ScheduledTask</code>. Для работы с заданиями существуют экраны просмотра и редактирования, доступные через меню <guimenu>Администрирование</guimenu> -&gt; <guimenuitem>Назначенные задания</guimenuitem>. </para>
          <para>Рассмотрим атрибуты задания:<itemizedlist>
              <listitem>
                <para><guilabel>Defined by</guilabel> - каким программным объектом реализуется задание. Возможные значения:<itemizedlist>
                    <listitem>
                      <para><guilabel>Bean</guilabel> - задание реализуется методом бина Spring. Дополнительные атрибуты:<itemizedlist>
                          <listitem>
                            <para><guilabel>Bean name</guilabel> - имя бина.</para>
                          </listitem>
                          <listitem>
                            <para><guilabel>Method name</guilabel> - метод бина для выполнения. Метод должен либо не иметь параметров, либо иметь все параметры типа <code>String</code>.</para>
                          </listitem>
                          <listitem>
                            <para><guilabel>Method parameters</guilabel> - параметры выбранного метода. Поддерживаются только параметры типа <code>String</code>.</para>
                          </listitem>
                        </itemizedlist></para>
                    </listitem>
                    <listitem>
                      <para><guilabel>Class</guilabel> - задание представляет собой класс, реализующий интерфейс <code>java.util.concurrent.Callable</code>. Класс должен иметь открытый конструктор без параметров. Дополнительные атрибуты:<itemizedlist>
                          <listitem>
                            <para><guilabel>Class name</guilabel> - имя класса</para>
                          </listitem>
                        </itemizedlist></para>
                    </listitem>
                    <listitem>
                      <para><guilabel>Script</guilabel> - задание представляет собой скрипт Groovy. Скрипт выполняется через <code>Scripting.<link linkend="scripting.runGroovyScript">runGroovyScript</link>()</code>. Дополнительные атрибуты:<itemizedlist>
                          <listitem>
                            <para><guilabel>Script name</guilabel> - имя скрипта.</para>
                          </listitem>
                        </itemizedlist></para>
                    </listitem>
                  </itemizedlist></para>
              </listitem>
              <listitem>
                <para><guilabel>User name</guilabel> - имя пользователя, от имени которого будет будет выполняться задание. Если не задано, то задание будет выполнено от имени пользователя, указанного в свойстве приложения <property>
                    <link linkend="cuba.jmxUserLogin">cuba.jmxUserLogin</link>
                  </property>.</para>
              </listitem>
              <listitem>
                <para><guilabel>Singleton</guilabel> - признак, является ли задание синглтоном, т.е. выполняющимся только на одном сервере системы.</para>
              </listitem>
              <listitem>
                <para><guilabel>Period</guilabel> - период запуска задания в секундах. </para>
              </listitem>
              <listitem>
                <para><guilabel>Timeout</guilabel> - время в секундах, по истечении которого считается, что задание закончило выполнение, независимо от того, есть ли информация о завершении задания, или нет. </para>
              </listitem>
              <listitem>
                <para><guilabel>Start date</guilabel> - дата/время первого запуска. Если не установлено, то задание запускается сразу при старте сервера. Если установлено, то задание запускается в момент <code>startDate + period * N</code>, где N - целое число. </para>
                <para>Start date имеет смысл указывать только для &quot;нечастых&quot; заданий - раз в 1 час, 1 сутки и т.п. </para>
              </listitem>
              <listitem>
                <para><guilabel>Time frame</guilabel> - в случае заданного Start date определяет временное окно в секундах, в течение которого будет запущено задание, если время <code>startDate + period * N</code> прошло. Если Time frame не задано явно, оно принимается равным <code>period / 2</code>. </para>
                <para>Если Start date не указано, то Time frame не принимается во внимание, т.е. задание будет запущено в любое время после прохождения промежутка времени Period после предыдущего выполнения задания. </para>
              </listitem>
              <listitem>
                <para><guilabel>Permitted servers</guilabel>
- список перечисленных через запятую <link linkend="serverId">идентификаторов серверов</link>, на которых возможен запуск данного задания. Если список не задан, то задание может выполняться на любом сервере. </para>
                <para>Для синглтон-заданий порядок перечисления серверов указывает их приоритет - первый имеет больший приоритет чем последний. Сервер с большим приоритетом перехватит выполнение синглтона следующим образом: если сервер с большим приоритетом обнаруживает, что предыдущий раз задание было выполнено сервером с меньшим приоритетом, то он запускает задание независимо от того, пройден ли Period или нет. <warning>
                    <para>Приоритет серверов работает только в случае не указанного атрибута Start date. Если Start date указан, старт происходит в одно и то же время, и перехват невозможен.</para>
                  </warning></para>
              </listitem>
              <listitem>
                <para><guilabel>Log start</guilabel> - признак регистрации факта запуска задания в таблице <code>SYS_SCHEDULED_EXECUTION</code>, соответствующей сущности <code>ScheduledExecution</code>. </para>
                <para>Если задание является синглтоном, то в текущей реализации регистрация факта запуска производится в любом случае, независимо от данного признака. </para>
              </listitem>
              <listitem>
                <para><guilabel>Log finish</guilabel> - признак регистрации факта завершения задания в таблице <code>SYS_SCHEDULED_EXECUTION</code>, соответствующей сущности <code>ScheduledExecution</code>. </para>
                <para>Если задание является синглтоном, то в текущей реализации регистрация факта завершения производится в любом случае, независимо от данного признака. </para>
              </listitem>
              <listitem>
                <para><guilabel>Description</guilabel> - произвольное текстовое описание задания.</para>
              </listitem>
            </itemizedlist></para>
          <para>Задание также имеет признак активности, который устанавливается в экране списка заданий. Неактивные задания не запускаются. </para>
        </section>
        <section>
          <title>Управление обработкой заданий</title>
          <itemizedlist>
            <listitem>
              <para>Для запуска обработки назначенных заданий необходимо перед стартом сервера установить свойство приложения <property>
                  <link linkend="cuba.schedulingActive">cuba.schedulingActive</link>
                </property> в значение <code>true</code>.</para>
            </listitem>
            <listitem>
              <para>Для оперативного управления обработкой заданий можно использовать JMX-бин <code>app-core.cuba:type=Scheduling</code>, атрибут <code>Active</code> которого запускает/останавливает обработку заданий для текущего сеанса работы сервера. После перезапуска сервера обработка будет запущена только при установленном в <code>true</code> свойстве приложения <property>cuba.schedulingActive</property>.</para>
            </listitem>
            <listitem>
              <para>Все изменения в заданиях, сделанные через экраны системы, вступают в силу немедленно для всех серверов кластера. </para>
            </listitem>
          </itemizedlist>
        </section>
        <section>
          <title>Особенности реализации</title>
          <itemizedlist>
            <listitem>
              <para>Период вызова обработки заданий (метода <code>SchedulingAPI.processScheduledTasks()</code>) задается в <filename>cuba-spring.xml</filename> и по умолчанию равен 1 сек. Он задает минимальное значение периода запуска задания, которое должно быть в 2 раза больше, т.е. 2 сек. Уменьшать эти времена не рекомендуется. </para>
            </listitem>
            <listitem>
              <para>Текущая реализация планировщика основана на синхронизации с помощью блокировки строк в таблице базы данных. Это означает, что при значительной нагрузке БД может не успевать вовремя отвечать планировщику, и необходимо увеличивать период запуска (&gt;1сек), и, соответственно, минимальный период запуска заданий также будет увеличиваться.</para>
            </listitem>
            <listitem>
              <para>Синглтон-задания в случае незаданного атрибута Permitted servers выполняются только на мастер-узле кластера (при выполнении прочих условий). Следует иметь в виду, что отдельный  сервер вне кластера также является мастером. </para>
            </listitem>
            <listitem>
              <para>Задание не запускается, если оно в данный момент не закончило предыдущее выполнение, и не истек указанный Timeout. Для синглтон-заданий в текущей реализации это обеспечивается информацией в базе данных, для не-синглтонов поддерживается таблица статуса выполнения в памяти сервера. </para>
            </listitem>
            <listitem>
              <para>Механизм выполнения создает и кэширует <link linkend="userSession">пользовательские сессии</link> в соответствии с указанными для заданий User name, либо свойством приложения <property>
                  <link linkend="cuba.jmxUserLogin">cuba.jmxUserLogin</link>
                </property>. Сессия доступна в потоке выполнения запускаемого задания обычным способом - через интерфейс <code>
                  <link linkend="userSessionSource">UserSessionSource</link>
                </code>.</para>
            </listitem>
          </itemizedlist>
          <warning>
            <para>Для нормальной работы синглтон-заданий необходима точная синхронизация серверов Middleware по времени!</para>
          </warning>
        </section>
      </section>
    </section>
    <section id="email_sending">
      <title>Отправка email</title>
      <para>Платформа предоставляет средства отправки сообщений электронной почты со следующими возможностями:<itemizedlist>
          <listitem>
            <para>Синхронная или асинхронная отправка. В случае синхронной отправки вызывающий код ожидает, пока сообщение не будет передано на SMTP сервер. При асинхронной отправке сообщение сохраняется в базе данных, и управление немедленно возвращается вызывающему коду. Отправка производится позже путем вызова из <link linkend="scheduled_tasks">назначенного задания</link>.  </para>
          </listitem>
          <listitem>
            <para>Надежная фиксация факта отправки и ошибок в базе данных, как для синхронной, так и для асинхронной отправки.</para>
          </listitem>
          <listitem>
            <para>Пользовательский интерфейс для поиска и просмотра информации о посылаемых сообщениях, включая все атрибуты и содержимое сообщений, а также статус отправки и количество предпринятых попыток.</para>
          </listitem>
        </itemizedlist></para>
      <section>
        <title>Методы отправки</title>
        <para>Для отправки email на Middleware следует использовать бин <code>EmailerAPI</code>, на клиентском уровне - сервис <code>EmailService</code>.</para>
        <para>Рассмотрим основные методы этих компонентов:<itemizedlist>
            <listitem>
              <para><code>sendEmail()</code> -  синхронная отправка сообщения. Вызывающий код блокируется на время отправки сообщения SMTP серверу.</para>
              <para>Сообщение может быть передано как в виде набора параметров (список адресатов через запятую, тема, содержимое, массив вложений), так и в виде специального объекта <code>EmailInfo</code>, инкапсулирующего всю эту информацию, плюс позволяющего явно задать адрес отправителя и сформировать тело письма по шаблону <application>FreeMarker</application>.</para>
              <para>При синхронной отправке может быть сгенерировано исключение <code>EmailException</code>, несущее в себе информацию о том, по каким адресам отправка не удалась, и соответствующие им сообщения об ошибках.</para>
              <para>В процессе работы метода для каждого адресата в базе данных создается экземпляр сущности <code>SendingMessage</code>, который сначала получает статус <code>SendingStatus.SENDING</code>, а после успешной отправки - <code>SendingStatus.SENT</code>. В случае ошибки отправки статус сообщения меняется на <code>SendingStatus.NOTSENT</code>.</para>
            </listitem>
            <listitem>
              <para><code>sendEmailAsync()</code> - асинхронная отправка сообщения. Данный метод возвращает список (по числу получателей) экземпляров <code>SendingMessage</code> со статусом <code>SendingStatus.QUEUE</code>, созданных  в базе данных. Собственно отправка производится при последующем вызове метода <code>EmailManagerAPI.queueEmailsToSend()</code>, который необходимо зарегистрировать в механизме <link linkend="scheduled_tasks">назначенных заданий</link> с желаемой периодичностью.</para>
            </listitem>
          </itemizedlist></para>
      </section>
      <section>
        <title>Вложения</title>
        <para>Объект <code>EmailAttachment</code> - обёртка, хранящая вложение в виде массива байт (поле <code>data</code>), имя файла (поле <code>name</code>), и при необходимости, уникальный для данного сообщения идентификатор вложения (необязательное, но полезное поле <code>contentId</code>). </para>
        <para>Идентификатор вложения  может быть использован для вставки в сообщение изображений следующим образом:
при создании <code>EmailAttachment</code> задаётся уникальный <code>contentId</code>, например <code>myPic</code>. В теле письма для вставки вложения необходимо в качестве пути использовать запись вида: <code>cid:myPic</code>. Т.е. для вставки изображения нужно указать следующий элемент HTML:<programlisting>&lt;img src=&quot;cid:myPic&quot;/&gt;</programlisting></para>
      </section>
      <section id="email_sending_properties">
        <title>Настройка параметров отправки</title>
        <para>Параметры отправки  email могут быть настроены с помощью перечисленных ниже <link linkend="app_properties">свойств приложения</link>. Все они являются параметрами времени выполнения и хранятся в базе данных, однако могут быть переопределены для конкретного блока Middleware в его файле <filename>app.properties</filename>.</para>
        <para>Все параметры отправки email доступны через конфигурационный интерфейс <code>EmailerConfig</code>.</para>
        <itemizedlist>
          <listitem>
            <para><property>cuba.email.fromAddress</property> - адрес отправителя по умолчанию. Принимается во внимание, если не указан атрибут <code>EmailInfo.from</code>.</para>
            <para>Значение по умолчанию: <literal>DoNotReply@haulmont.com</literal></para>
          </listitem>
          <listitem>
            <para><property>cuba.email.smtpHost</property> - адрес SMTP сервера.</para>
            <para>Значение по умолчанию: <literal>test.host</literal></para>
          </listitem>
          <listitem>
            <para><property>cuba.email.smtpPort</property> - порт SMTP сервера.</para>
            <para>Значение по умолчанию: <literal>25</literal></para>
          </listitem>
          <listitem>
            <para><property>cuba.email.smtpAuthRequired</property> - требуется ли аутентификация на SMTP сервере. Соответствует параметру <literal>mail.smtp.auth</literal>, передаваемому при создании объекта <code>javax.mail.Session</code>.</para>
            <para>Значение по умолчанию: <literal>false</literal></para>
          </listitem>
          <listitem>
            <para><property>cuba.email.smtpStarttlsEnable</property> - задает использование команды <literal>STARTTLS</literal> при аутентификации на SMTP сервере. Соответствует параметру <literal>mail.smtp.starttls.enable</literal>, передаваемому при создании объекта <code>javax.mail.Session</code>.</para>
            <para>Значение по умолчанию: <literal>false</literal></para>
          </listitem>
          <listitem>
            <para><property>cuba.email.smtpUser</property> - имя пользователя для аутентификации на SMTP сервере.</para>
          </listitem>
          <listitem>
            <para><property>cuba.email.smtpPassword</property> - пароль пользователя для аутентификации на SMTP сервере.</para>
          </listitem>
          <listitem>
            <para><property>cuba.email.delayCallCount</property> - используется при асинхронной отправке email из очереди для пропуска нескольких первых вызовов <code>EmailManager.queueEmailsToSend()</code> сразу после старта сервера, чтобы снизить нагрузку во время инициализации приложения. Отправка email начнется следующим вызовом.</para>
            <para>Значение по умолчанию: <literal>2</literal></para>
          </listitem>
          <listitem>
            <para><property>cuba.email.messageQueueCapacity</property> - при асинхронной отправке количество сообщений, читаемое из очереди и отправляемое за один вызов <code>EmailManager.queueEmailsToSend()</code>.</para>
            <para>Значение по умолчанию: <literal>100</literal></para>
          </listitem>
          <listitem>
            <para><property>cuba.email.defaultSendingAttemptsCount</property> - при асинхронной отправке email количество попыток отправки по умолчанию. Принимается во внимание, если при вызове <code>Emailer.sendEmailAsync()</code> не указан параметр <code>attemptsCount</code>.</para>
            <para>Значение по умолчанию: <literal>10</literal></para>
          </listitem>
          <listitem>
            <para>cuba.email.maxSendingTimeSec - максимальное предполагаемое время в секундах, требуемое для отправки сообщения на SMTP сервер. Используется при асинхронной отправке для оптимизации выборки объектов <code>SendingMessage</code> из очереди в БД.</para>
            <para>Значение по умолчанию: 120</para>
          </listitem>
          <listitem>
            <para><property>cuba.email.sendAllToAdmin</property> - указывает, что все сообщения должны отправляться на адрес <property>cuba.email.adminAddress</property>, независимо от указанного адреса получателя. Этот параметр рекомендуется использовать во время отладки системы.</para>
            <para>Значение по умолчанию: <literal>false</literal></para>
          </listitem>
          <listitem>
            <para><property>cuba.email.adminAddress</property> - адрес, на который отправляются все сообщения при включенном свойстве <property>cuba.email.sendAllToAdmin</property>.</para>
            <para>Значение по умолчанию: <literal>address@company.com</literal></para>
          </listitem>
        </itemizedlist>
        <para>Просмотреть текущие значения параметров, а также отправить тестовое сообщение, можно с помощью JMX-бина <code>app-core.cuba:type=Emailer</code>.</para>
      </section>
    </section>
    <section id="runtime_properties">
      <title>Динамические атрибуты</title>
      <section>
        <title>Общие сведения</title>
        <para>Механизм динамических атрибутов предназначен для описания новых свойств сущностей на этапе настройки и эксплуатации системы. При этом для одного типа сущности может быть задано несколько наборов динамических атрибутов.</para>
        <figure>
          <title>Диаграмма классов механизма динамических атрибутов</title>
          <mediaobject>
            <imageobject>
              <imagedata contentwidth="" align="center" fileref="img/RuntimeProperties.png"/>
            </imageobject>
          </mediaobject>
        </figure>
        <para>Рассмотрим приведенные на диаграмме классы.</para>
        <itemizedlist>
          <listitem>
            <para><code>CategorizedEntity</code> - базовый класс сущностей, которые могут иметь динамические атрибуты. Содержит ссылку на объект <code>Category</code>, т.е. каждый экземпляр сущности <code>SomeEntity</code> может быть отнесен к одной из определенных заранее категорий.</para>
          </listitem>
          <listitem>
            <para><code>Category</code> - определяет категорию объектов и соответствующий набор динамических атрибутов. Категория должна быть отнесена к некоторому типу сущности.</para>
            <para>Например, имеется сущность типа <userinput>Автомобиль</userinput>. Для нее можно определить две категории: <userinput>Грузовой</userinput> и <userinput>Пассажирский</userinput>. При этом категория <userinput>Грузовой</userinput>  будет содержать атрибуты <userinput>Грузоподъемность</userinput> и <userinput>Вид кузова</userinput>, а категория <userinput>Пассажирский</userinput> - атрибуты <userinput>Количество мест</userinput> и <userinput>Наличие детского сидения</userinput>.</para>
            <para>Атрибут <code>isDefault</code> указывает, что при создании нового экземпляра сущности для него автоматически выбирается данная категория.</para>
            <para>Атрибут <code>special</code> указывает, что данная категория обрабатывается в приложении специальным образом, и не отображается в универсальном UI редактирования категорий.</para>
          </listitem>
          <listitem>
            <para><code>CategoryAttribute</code> - определяет динамический атрибут, относящийся к некоторой категории. Содержит значение по умолчанию для различных типов данных. Значение перечислений задается в виде списка строк через запятую.</para>
          </listitem>
          <listitem>
            <para><code>CategoryAttributeValue</code> - значение динамического атрибута для конкретного экземпляра сущности.</para>
          </listitem>
        </itemizedlist>
        <para>Управление категориями и описаниями атрибутов осуществляется с помощью специальных экранов, доступных через меню <guimenu>Администрирование</guimenu> -&gt; <guimenuitem>Категории</guimenuitem>.</para>
      </section>
      <section>
        <title>Применение</title>
        <para>Для того, чтобы некоторая сущность могла иметь динамические атрибуты, ее класс необходимо унаследовать от <code>CategorizedEntity</code>, и, соответственно, обеспечить в таблице наличие поля <database>CATEGORY_ID</database> типа <code>UUID</code>.</para>
        <para>Для включения  динамических атрибутов в экран редактирования сущности необходимо выполнить следующее:<itemizedlist>
            <listitem>
              <para>В секции <sgmltag>dsContext</sgmltag> необходимо объявить два источника данных:<itemizedlist>
                  <listitem>
                    <para><sgmltag>runtimePropsDatasource</sgmltag> - специфический источник, в который будут загружены экземпляры <code>CategoryAttributeValue</code>. Атрибут <sgmltag>mainDs</sgmltag> должен ссылаться на главный источник данных, содержащий редактируемую сущность.</para>
                  </listitem>
                  <listitem>
                    <para>обычный <sgmltag>collectionDatasource</sgmltag> для загрузки списка категорий данного типа сущности</para>
                  </listitem>
                </itemizedlist></para>
              <para>Например:<programlisting>&lt;dsContext&gt;
    &lt;datasource id=&quot;carDs&quot; 
                class=&quot;com.sample.app.entity.Car&quot; 
                view=&quot;carEdit&quot;/&gt;

    &lt;runtimePropsDatasource id=&quot;runtimePropsDs&quot; 
                            mainDs=&quot;carDs&quot;/&gt;

    &lt;collectionDatasource id=&quot;categories&quot; 
                          class=&quot;com.haulmont.cuba.core.entity.Category&quot; 
                          view=&quot;_local&quot;&gt;
        &lt;query&gt;
            select c from sys$Category c where c.entityType=&apos;app$Car&apos;
        &lt;/query&gt;
    &lt;/collectionDatasource&gt;
&lt;/dsContext&gt;</programlisting></para>
            </listitem>
            <listitem>
              <para>Для отображения списка категорий и собственно динамических атрибутов используется визуальный компонент <sgmltag>runtimeProperties</sgmltag>:<programlisting>&lt;runtimeProperties id=&quot;runtimePropsFrame&quot; 
                   runtimeDs=&quot;runtimePropsDs&quot; 
                   categoriesDs=&quot;categories&quot; 
                   width=&quot;100%&quot;/&gt;</programlisting></para>
            </listitem>
          </itemizedlist></para>
      </section>
    </section>
    <section>
      <title>Пессимистичная блокировка</title>
      <section>
        <title>Блокировка редактирования сущностей</title>
        <para>Пессимистичная блокировка сущностей применяется, если велика вероятность одновременного редактирования одного и того же экземпляра, и стандартная <link linkend="optimistic_locking">оптимистичная блокировка</link>, основанная на версионности сущностей, порождает слишком много коллизий.</para>
        <para>Пессимистичная блокировка использует явное блокирование экземпляра сущности при открытии его в <link linkend="screen_edit">экране редактирования</link>. В результате только один пользователь  в некоторый момент времени может редактировать данный экземпляр сущности.</para>
        <para>Режим пессимистичной блокировки может быть задан для любого класса сущности в процессе настройки или эксплуатации системы. Для этого достаточно выполнить следующие действия:<itemizedlist>
            <listitem>
              <para>вставить в таблицу <database>SYS_LOCK_CONFIG</database> запись со следующими значениями полей:<itemizedlist>
                  <listitem>
                    <para><database>ID</database> - произвольный идентификатор типа UUID.</para>
                  </listitem>
                  <listitem>
                    <para><database>NAME</database> - наименование блокируемого объекта. Для сущности это должно быть имя ее <link linkend="metaClass">мета-класса</link>. </para>
                  </listitem>
                  <listitem>
                    <para><database>TIMEOUT_SEC</database> - таймаут истечения блокировки в секундах.</para>
                  </listitem>
                </itemizedlist></para>
              <para>Например: <programlisting>insert into sys_lock_config (id, create_ts, name, timeout_sec) values (newid(), current_timestamp, &apos;sales$Order&apos;, 300)</programlisting></para>
            </listitem>
            <listitem>
              <para>перезапустить сервер или выполнить метод <code>reloadConfiguration()</code> JMX-бина <code>app-core.cuba:type=LockManager</code>.</para>
            </listitem>
          </itemizedlist></para>
      </section>
      <section>
        <title>Блокировка произвольных процессов</title>
        <para>Механизм пессимистичной блокировки можно использовать также для управления совместным выполнением произвольных процессов. Причем блокировки являются распределенными, т.к. информация о них реплицируется в кластере  Middleware. </para>
        <para>Подробнее см. JavaDoc интерфейсов <code>LockManagerAPI</code> и <code>LockService</code>.</para>
      </section>
      <section>
        <title>Мониторинг блокировок</title>
        <para>Текущее состояние блокировок можно отслеживать через JMX-бин <code>app-core.cuba:type=LockManager</code>, или через специальный экран, доступный в меню <guimenu>Администрирование</guimenu> -&gt; <guimenuitem>Блокировки</guimenuitem>. Экран также позволяет разблокировать любой объект принудительно. </para>
      </section>
    </section>
    <section id="entity_statistics">
      <title>Статистика сущностей</title>
      <para>Механизм статистики сущностей  предоставляет данные о текущем количестве экземпляров сущностей в базе данных. Эти данные используются для автоматического принятия решений о выборе способа поиска связанных сущностей и ограничении размера выборок в экранах пользовательского интерфейса.</para>
      <para>Статистика хранится  в таблице <database>SYS_ENTITY_STATISTICS</database>, соответствующей сущности <code>EntityStatistics</code>. Заполнить статистику можно как вручную, внося соответствующие записи в таблицу, так и автоматически с помощью метода <code>refreshStatistics()</code> JMX-бина <code>
          <link linkend="persistenceManagerMBean">PersistenceManagerMBean</link>
        </code>. При указании в качестве параметра имени сущности статистика будет собрана только для данной сущности, в противном случае - для всех. Сбор статистики может занять значительное время и вызвать нежелательную нагрузку на БД, поэтому выполнять его нужно либо вручную, либо <link linkend="scheduled_tasks_cuba">назначенным заданием</link>   в подходящее время.</para>
      <para>Программный доступ к статистике осуществляется с помощью интерфейса <code>PersistenceManagerAPI</code> на Middleware и <code>PersistenceManagerService</code> на клиентском уровне. Статистика кэшируется в памяти, поэтому если изменения статистики вносятся напрямую в базу данных, для всупления их в силу необходимо перезапустить сервер или вызвать метод <code>PersistenceManagerMBean.flushStatisticsCache()</code>.</para>
      <para>Рассмотрим атрибуты <code>EntityStatistics</code> и их влияние на поведение системы.<itemizedlist>
          <listitem>
            <para><code>name</code> (колонка <database>NAME</database>) - тип сущности в виде имени <link linkend="metaClass">мета-класса</link>, например <code>sales$Customer</code>.</para>
          </listitem>
          <listitem>
            <para><code>instanceCount</code> (колонка <database>INSTANCE_COUNT</database>) - примерное текущее количество экземпляров сущности. </para>
          </listitem>
          <listitem>
            <para><code>fetchUI</code> (колонка <database>FETCH_UI</database>) - размер страницы данных, предлагаемый пользователю при извлечении списков сущностей. </para>
            <para>Например, компонент <link linkend="gui_Filter">
                <code>Filter</code>
              </link> устанавливает это число в поле <guilabel>Показывать N строк</guilabel>.</para>
          </listitem>
          <listitem>
            <para><code>maxFetchUI</code> (колонка <database>MAX_FETCH_UI</database>) - максимальное количество экземпляров сущности, которое может быть извлечено и передано на клиентский уровень. </para>
            <para>Данный параметр играет роль при отображении списков сущностей в компонентах типа <code>
                <link linkend="gui_LookupField">LookupField</link>
              </code> и <code>
                <link linkend="gui_LookupPickerField">LookupPickerField</link>
              </code>, а также в таблицах без универсального <link linkend="gui_Filter">фильтра</link>, то есть когда на связанный <link linkend="datasources">источник данных</link> не налагается ограничений методом <code>CollectionDatasource.setMaxResults()</code>.  В этом случае сам источник данных ограничивает количество извлекаемых экземпляров значением <code>maxFetchUI</code>.</para>
          </listitem>
          <listitem>
            <para><code>lookupScreenThreshold</code> (колонка <database>LOOKUP_SCREEN_THRESHOLD</database>) - порог количества экземпляров сущности, при превышении которого в универсальных механизмах пользовательского интерфейса для поиска связанных сущностей будут использоваться <link linkend="screen_lookup">экраны выбора</link>  вместо выпадающих списков. </para>
            <para>В частности, этот параметр принимается во внимание компонентом <code>
                <link linkend="gui_Filter">Filter</link>
              </code> при выборе параметров фильтрации: до достижения порога используется компонент <code>
                <link linkend="gui_LookupField">LookupField</link>
              </code>, при превышении порога - компонент <code>
                <link linkend="gui_PickerField">PickerField</link>
              </code>. Поэтому, если необходимо заставить фильтр отображать выбор параметра некоторого типа через экран выбора, достаточно внести запись статистики для этой сущности со значением <code>lookupScreenThreshold</code> меньшим, чем <code>instanceCount</code>.</para>
          </listitem>
        </itemizedlist></para>
      <para>JMX-бин <code>PersistenceManagerMBean</code> в атрибутах <code>DefaultFetchUI</code>, <code>DefaultMaxFetchUI</code>, <code>DefaultLookupScreenThreshold</code> позволяет задать значения вышеперечисленных параметров по умолчанию. В результате, если для некоторой сущности статистика отсутствует (что является обычной ситуацией), будет использоваться соответствующий параметр по умолчанию.</para>
    </section>
    <section id="entity_log">
      <title>Журнал изменений сущностей</title>
      <para>Механизм журналирования предназначен для отслеживания изменений атрибутов произвольных сущностей в процессе работы приложения. Измененные значения сохраняются в специальной таблице базы данных, список изменений для конкретного экземпляра сущности может быть отображен в пользовательском интерфейсе.</para>
      <para>Данный механизм перехватывает сохранение сущностей в БД  на уровне <link linkend="entity_listeners">Entity Listeners</link>, т.е. гарантированно отслеживаются все изменения, проходящие через персистентный контекст <code>
          <link linkend="entityManager">EntityManager</link>
        </code>. Непосредственное изменение сущностей в базе данных с помощью SQL, в том числе изнутри системы через <link linkend="nativeQuery">
          <code>NativeQuery</code>
        </link> и <code>
          <link linkend="queryRunner">QueryRunner</link>
        </code>, в журнал не попадает.  </para>
      <para>Измененные экземпляры сущностей перед сохранением в БД отправляются в  методы <code>registerCreate()</code>, <code>registerModify()</code>, <code>registerDelete()</code> бина <code>EntityLogAPI</code>. Параметр <code>auto</code> этих методов позволяет отделить автоматическое журналирование посредством Entity Listeners от ручного вызова этих же методов в прикладном коде. При вызове из Entity Listeners в параметре <code>auto</code> передается <code>true</code>. </para>
      <para>Журнал содержит информация о том, кто и  когда изменил данный экземпляр, а также новые значения измененных атрибутов. Записи журнала сохраняются в таблице <database>SEC_ENTITY_LOG</database> базы данных, соответствующей сущности <code>EntityLogItem</code>. Измененные значения атрибутов хранятся в этой же таблице в колонке <database>CHANGES</database>, а при чтении на Middleware преобразуются в экземпляры сущности <code>EntityLogAttr</code>. </para>
      <section>
        <title>Настройка журналирования</title>
        <para>Аудит настраивается при помощи сущностей <code>LoggedEntity</code> и <code>LoggedAttribute</code> (соответствующих таблицам <database>SEC_LOGGED_ENTITY</database> и <database>SEC_LOGGED_ATTR</database>).</para>
        <para><code>LoggedEntity</code> описывает тип сущности, изменения которой необходимо журналировать. Атрибуты <code>LoggedEntity</code>:</para>
        <itemizedlist>
          <listitem>
            <para><code>name</code> (колонка <database>NAME</database>) - тип сущности в виде имени <link linkend="metaClass">мета-класса</link>, например <code>sales$Customer</code>.</para>
          </listitem>
          <listitem>
            <para><code>auto</code> (колонка <database>AUTO</database>) - нужно ли журналировать изменения при вызове <code>EntityLogAPI</code> с параметром <code>auto = true</code> (т.е. из <link linkend="entity_listeners">Entity Listeners</link>).</para>
          </listitem>
          <listitem>
            <para><code>manual</code> (колонка <database>MANUAL</database>) - нужно ли журналировать изменения при вызове <code>EntityLogAPI</code> с параметром <code>auto = false</code>.</para>
          </listitem>
        </itemizedlist>
        <para><code>LoggedAttribute</code> описывает журналируемый атрибут сущности и содержит ссылку на <code>LoggedEntity</code> и имя атрибута.</para>
        <para>Для настройки журналирования некоторой сущности достаточно внести соответствующие записи в таблицы <database>SEC_LOGGED_ENTITY</database> и <database>SEC_LOGGED_ATTR</database>. Например, для ведения журнала изменений атрибутов <code>name</code>  и <code>grade</code> сущности <code>Customer</code>, необходимо выполнить:<programlisting>insert into SEC_LOGGED_ENTITY (ID, CREATE_TS, CREATED_BY, NAME, AUTO, MANUAL) 
values (&apos;25eeb644-e609-11e1-9ada-3860770d7eaf&apos;, now(), &apos;admin&apos;, &apos;sales$Customer&apos;, true, true);

insert into SEC_LOGGED_ATTR (ID, CREATE_TS, CREATED_BY, ENTITY_ID, NAME) 
values (newid(), now(), &apos;admin&apos;, &apos;25eeb644-e609-11e1-9ada-3860770d7eaf&apos;, &apos;name&apos;);

insert into SEC_LOGGED_ATTR (ID, CREATE_TS, CREATED_BY, ENTITY_ID, NAME) 
values (newid(), now(), &apos;admin&apos;, &apos;25eeb644-e609-11e1-9ada-3860770d7eaf&apos;, &apos;grade&apos;);</programlisting></para>
        <para>Для активации механизма журналирования необходимо установить в <code>true</code> атрибут <code>Enabled</code> JMX-бина <code>app-core.cuba:type=EntityLog</code>. Для вступления в силу изменений настройки журналирования, произведенных во время работы приложения, необходимо перезапустить сервер или вызвать метод <code>invalidateCache()</code> этого же бина.</para>
      </section>
      <section>
        <title>Отображение журнала</title>
        <para>Для просмотра журнала изменений некоторого экземпляра сущности достаточно обычным способом загрузить в источники данных экрана коллекцию экземпляров <code>EntityLogItem</code> и ассоциированных с ними <code>EntityLogAttr</code>, и  создать визуальные компоненты, связанные с этими источниками. Например:<programlisting>&lt;dsContext&gt;
    &lt;datasource id=&quot;customerDs&quot; 
                class=&quot;com.sample.sales.entity.Customer&quot; 
                view=&quot;customerEdit&quot;/&gt;

    &lt;collectionDatasource id=&quot;logDs&quot; 
                          class=&quot;com.haulmont.cuba.security.entity.EntityLogItem&quot; 
                          view=&quot;logView&quot;&gt;
        &lt;query&gt;
            select i from sec$EntityLog i 
            where i.entityId = :ds$customerDs order by i.eventTs
        &lt;/query&gt;

        &lt;collectionDatasource id=&quot;logAttrDs&quot; 
                              property=&quot;attributes&quot;/&gt;
    &lt;/collectionDatasource&gt;
&lt;/dsContext&gt;
&lt;layout&gt;
...
    &lt;split orientation=&quot;vertical&quot; width=&quot;100%&quot; height=&quot;100%&quot;&gt;

        &lt;table id=&quot;logTable&quot; width=&quot;100%&quot; height=&quot;100%&quot;&gt;
            &lt;columns&gt;
                &lt;column id=&quot;eventTs&quot;/&gt;
                &lt;column id=&quot;user.login&quot;/&gt;
                &lt;column id=&quot;type&quot;/&gt;
            &lt;/columns&gt;
            &lt;rows datasource=&quot;logDs&quot;/&gt;
        &lt;/table&gt;

        &lt;table id=&quot;logAttrTable&quot; width=&quot;100%&quot; height=&quot;100%&quot;&gt;
            &lt;columns&gt;
                &lt;column id=&quot;name&quot;/&gt;
                &lt;column id=&quot;value&quot;/&gt;
            &lt;/columns&gt;
            &lt;rows datasource=&quot;logAttrDs&quot;/&gt;
        &lt;/table&gt;

    &lt;/split&gt;
...
&lt;/layout&gt;</programlisting></para>
        <para>Для отображения локализованных значений журналируемых атрибутов эти атрибуты должны содержать аннотацию <link linkend="localizedValue_annotation">
            <code>@LocalizedValue</code>
          </link>. При ее наличии механизм журналирования заполняет поле <code>EntityLogAttr.messagesPack</code>, и таблица, отображающая значения атрибутов из примера выше может использовать колонку <code>locValue</code> вместо <code>value</code>:<programlisting>&lt;table id=&quot;logAttrTable&quot; width=&quot;100%&quot; height=&quot;100%&quot;&gt;
    &lt;columns&gt;
        &lt;column id=&quot;name&quot;/&gt;
        &lt;column id=&quot;locValue&quot;/&gt;
    &lt;/columns&gt;
    &lt;rows datasource=&quot;logAttrDs&quot;/&gt;
&lt;/table&gt;</programlisting></para>
      </section>
    </section>
    <section id="entity_snapshots">
      <title>Снимки сущностей</title>
      <para>Механизм сохранения снимков сущностей, так же как и <link linkend="entity_log">журнал изменений</link>, предназначен для отслеживания изменений данных в процессе работы приложения. Его отличительными особенностями являются:<itemizedlist>
          <listitem>
            <para>Сохраняются не изменения некоторых атрибутов одного экземпляра, а состояние (снимок) целого графа сущностей, определяемого заданным <link linkend="views">представлением</link>.</para>
          </listitem>
          <listitem>
            <para>Процесс сохранения снимка вызывается явно из кода клиентского уровня.</para>
          </listitem>
          <listitem>
            <para>Платформа предоставляет возможность просмотра  и сравнения между собой сохраненных снимков.</para>
          </listitem>
        </itemizedlist></para>
      <section>
        <title>Сохранение снимков</title>
        <para>Для сохранения снимка некоторого графа сущностей достаточно вызвать метод <code>EntitySnapshotService.createSnapshot()</code> и передать ему основную сущность графа и  <link linkend="views">представление</link>, описывающее граф. Снимок создается по загруженной сущности, никаких обращений к базе данных не производится, поэтому снимок в результате содержит не больше полей, чем представление, с которым была загружена основная сущность.</para>
        <para>Граф Java объектов преобразуется в XML и сохраняется в базе данных вместе со ссылкой на основную сущность в таблице <database>SYS_ENTITY_SNAPSHOT</database>, соответствующей сущности <code>EntitySnapshot</code>.  </para>
        <para>Как правило, снимки требуется сохранять после коммита <link linkend="screen_edit">экрана редактирования</link>. Для этого можно переопределить метод <code>postCommit()</code> контроллера экрана, например:<programlisting>public class CustomerEditor extends AbstractEditor&lt;Customer&gt; {

    @Inject
    protected Datasource&lt;Customer&gt; customerDs;

    @Inject
    protected EntitySnapshotService entitySnapshotService;

...
    @Override
    protected boolean postCommit(boolean committed, boolean close) {
        if (committed) {
            entitySnapshotService.createSnapshot(customerDs.getItem(), customerDs.getView());
        }
        return super.postCommit(committed, close);
    }
}</programlisting></para>
      </section>
      <section>
        <title>Отображение снимков</title>
        <para>Для отображения сохраненных для некоторой сущности снимков можно использовать фрейм <filename>com/haulmont/cuba/gui/app/core/entitydiff/diff-view.xml</filename>, например:<programlisting>&lt;iframe id=&quot;diffFrame&quot; 
        src=&quot;/com/haulmont/cuba/gui/app/core/entitydiff/diff-view.xml&quot;
        width=&quot;100%&quot; 
        height=&quot;100%&quot;/&gt;</programlisting></para>
        <para>В контроллере экрана редактирования необходимо вызвать загрузку снимков во фрейм:<programlisting>public class CustomerEditor extends AbstractEditor&lt;Customer&gt; {

    @Inject
    protected EntityDiffViewer diffFrame;

...
    @Override
    protected void postInit() {
        if (!PersistenceHelper.isNew(getItem())) {
            diffFrame.loadVersions(getItem());
        }
    }
}</programlisting></para>
        <para>Фрейм <filename>diff-view.xml</filename> отображает список сохраненных для данной сущности снимков с возможностью их сравнения. Для каждого снимка указывается пользователь, дата и время сохранения. При выборе из списка некоторого снимка сущности в таблице сравнения показываются изменения  данных по сравнению с предыдущим снимком. В первом снимке измененными считаются все атрибуты. Если выбрано два снимка, то в таблицу   выводится результат их сравнения.
</para>
        <para>В таблице сравнения отображаются имена атрибутов и их новые значения, при выборе строки показывается детальная информация по изменениям атрибута в двух снимках. Ссылочные поля выводятся в соответствии с их шаблоном <link linkend="namePattern">
            <code>@NamePattern</code>
          </link>. При сравнении коллекций добавленные и удаленные элементы выделяются цветом (зеленый, красный), а элементы с измененными атрибутами остаются без выделения. Изменение позиций элементов не учитывается.  </para>
      </section>
    </section>
    <section id="file_storage">
      <title>Хранилище файлов</title>
      <para>Хранилище файлов обеспечивает загрузку, хранение и выгрузку произвольных файлов, ассоциированных с сущностями системы. Стандартная реализация сохраняет файлы вне основной базы данных, в специальной структуре файловой системы.</para>
      <para>Механизм работы с  файлами состоит из следующих частей:<itemizedlist>
          <listitem>
            <para>Сущность <code>FileDescriptor</code> - описатель загруженного файла (не путать с <code>java.io.FileDescriptor</code>), позволяющий ссылаться на файл из объектов модели данных.</para>
          </listitem>
          <listitem>
            <para>Интерфейс <code>FileStorageAPI</code> - доступ к хранилищу файлов на <link linkend="app_tiers">уровне</link> Middleware. Основные методы:<itemizedlist>
                <listitem>
                  <para><code>saveStream()</code> - сохранить содержимое файла, переданное в <code>InputStream</code>, по данным указанного <code>FileDescriptor</code>.</para>
                </listitem>
                <listitem>
                  <para><code>openStream()</code> - вернуть содержимое файла, указанного объектом <code>FileDescriptor</code>,  в виде открытого <code>InputStream</code>.</para>
                </listitem>
              </itemizedlist></para>
          </listitem>
          <listitem>
            <para>Класс <code>FileUploadController</code> - контроллер Spring MVC, позволяющий отправлять файлы с клиентского    уровня на  Middleware посредством HTTP POST запросов.</para>
          </listitem>
          <listitem>
            <para>Класс <code>FileDownloadController</code> - контроллер Spring MVC, позволяющий получать файлы с Middleware на клиентский уровень посредством HTTP GET запросов.</para>
          </listitem>
          <listitem>
            <para>Визуальные компоненты <code>
                <link linkend="gui_FileUploadField">FileUpload</link>
              </code> и <code>
                <link linkend="gui_FileMultiUploadField">FileMultiUpload</link>
              </code> - позволяют загрузить файлы с компьютера пользователя на клиентский уровень приложения, и затем организовать их передачу на Middleware.</para>
          </listitem>
          <listitem>
            <para>Интерфейс <code>FileUploadingAPI</code> - промежуточное хранилище загружаемых файлов на клиентском уровне. Используется вышеупомянутыми компонентами для загрузки файлов на клиентский уровень. В прикладном коде используется метод <code>putFileIntoStorage()</code>, перемещающий файл в постоянное хранилище на Middleware.</para>
          </listitem>
          <listitem>
            <para><code>ExportDisplay</code> - интерфейс клиентского уровня, позволяющий выгружать различные ресурсы приложения на компьютер пользователя. Для получения файлов из хранилища можно использовать метод <code>show()</code>, принимающий <code>FileDescriptor</code>. Экземпляр <code>ExportDisplay</code> можно получить либо вызовом статического метода <code>AppConfig.createExportDisplay()</code>, либо <link linkend="screen_controller_injection">инжекцией</link> в класс контроллера.</para>
          </listitem>
        </itemizedlist></para>
      <para>Передача файлов между пользовательским компьютером и хранилищем в обе стороны производится только путем копирования данных между потоками ввода-вывода. Ни на каком уровне приложения файл не оказывается целиком в памяти, поэтому возможна передача файлов практически любых размеров.</para>
      <section id="file_upload">
        <title>Загрузка файлов</title>
        <para>Для загрузки файлов с компьютера пользователя в хранилище следует использовать компоненты <code>
            <link linkend="gui_FileUploadField">FileUpload</link>
          </code> и <code>
            <link linkend="gui_FileMultiUploadField">FileMultiUpload</link>
          </code>. Примеры использования приведены в описании компонентов.</para>
        <para>Промежуточное хранилище клиентского уровня <code>FileUploadingAPI</code> для хранения временных файлов использует каталог, заданный свойством приложения <property>
            <link linkend="cuba.tempDir">cuba.tempDir</link>
          </property>.  В случае сбоев в нем могут оставаться временные файлы, для  удаления которых желательно в клиентских блоках приложения периодически вызывать метод <code>clearTempDirectory()</code> бина <code>cuba_FileUploading</code>. Это можно сделать, создав задание планировщика в файле <filename>
            <link linkend="spring.xml">spring.xml</link>
          </filename> модуля <structname>web</structname> (и/или <structname>desktop</structname>) проекта приложения, например:<programlisting>&lt;task:scheduled-tasks scheduler=&quot;scheduler&quot;&gt;
    &lt;task:scheduled ref=&quot;cuba_FileUploading&quot; method=&quot;clearTempDirectory&quot; cron=&quot;0 0 0 * * 2,4,6&quot;/&gt;
&lt;/task:scheduled-tasks&gt;</programlisting></para>
        <para>В данном случае очистка будет производиться в 00:00:00 каждый вторник, четверг и субботу.</para>
      </section>
      <section id="file_download">
        <title>Выгрузка данных</title>
        <para>Для выгрузки файлов на клиентском уровне следует использовать интерфейс <code>ExportDisplay</code>, получив ссылку на него вызовом статического метода <code>AppConfig.createExportDisplay()</code>, либо <link linkend="screen_controller_injection">инжекцией</link> в класс контроллера. Например:<programlisting>AppConfig.createExportDisplay(this).show(fileDescriptor);</programlisting></para>
        <para>Метод <code>show()</code> может принимать дополнительный параметр типа <code>ExportFormat</code>, в котором можно задать тип содержимого и расширение имени файла. Если формат не передан, расширение берется из <code>FileDescriptor</code>, а типом содержимого принимается <code>application/octet-stream</code>. </para>
        <para>При использовании пользователем веб-интерфейса от расширения имени файла зависит, будет ли файл выгружаться через диалог сохранения или открытия файлов браузера (<code>Content-Disposition = attachment</code>), или браузер попытается отобразить содержимое прямо в своем окне (<code>Content-Disposition = inline</code>). Список расширений файлов, отображаемых в окне браузера, задается свойством приложения <property>
            <link linkend="cuba.web.viewFileExtensions">cuba.web.viewFileExtensions</link>
          </property>.</para>
      </section>
      <section id="file_storage_impl">
        <title>Стандартная реализация хранилища</title>
        <para>Стандартная реализация хранит файлы в специальной структуре каталогов на одном или нескольких файловых ресурсах.</para>
        <para>Корни структуры можно задать в свойстве приложения <property>
            <link linkend="cuba.fileStorageDir">cuba.fileStorageDir</link>
          </property>. Формат - список путей через запятую. Например: <programlisting>cuba.fileStorageDir=/work/sales/filestorage,/mnt/backup/filestorage</programlisting></para>
        <para>Если данное свойство не задано, хранилище будет создано в подкаталоге <filename>filestorage</filename> <link linkend="work_dir">рабочего каталога</link> Middleware. В стандартном варианте развертывания в Tomcat это каталог <filename>tomcat/work/app-core/filestorage</filename>. </para>
        <para>В случае указания нескольких ресурсов хранилище ведет себя следующим образом: <itemizedlist>
            <listitem>
              <para>Первый каталог в списке является <firstterm>основным</firstterm>, остальные - <firstterm>резервными</firstterm>. </para>
            </listitem>
            <listitem>
              <para>Запись сохраняемых файлов производится в основной каталог, а затем файл копируется во все резервные каталоги. </para>
              <para>Перед записью проверяется доступность каждого каталога. Если недоступен основной каталог, выбрасывается исключение и запись не производится. Если недоступен какой-то из резервных каталогов, запись все равно производится, в лог выводится сообщение об ошибке. </para>
            </listitem>
            <listitem>
              <para>Чтение производится из основного каталога. </para>
              <para>При недоступности основного каталога чтение производится из первого резервного каталога, в котором имеется данный файл. В лог выводится сообщение об ошибке. </para>
            </listitem>
          </itemizedlist></para>
        <para>Файловая структура хранилища организована следующим образом:<itemizedlist>
            <listitem>
              <para>Имеется три уровня каталогов, соответствующих дате загрузки файла - год, месяц, день.</para>
            </listitem>
            <listitem>
              <para>Файл сохраняется в каталоге дня. Именем файла является  идентификатор соответствующего объекта <code>FileDescriptor</code>. Расширение файла - исходное.</para>
            </listitem>
            <listitem>
              <para>В корне структуры хранилища ведется файл <filename>storage.log</filename>, содержащий информацию о том, какой файл, когда и каким пользователем был записан в хранилище. Этот журнал не несет никакой функциональности, но может быть полезен при поиске проблем.</para>
            </listitem>
          </itemizedlist></para>
        <para>JMX-бин <code>app-core.cuba:type=FileStorage</code> отображает текущий список корней хранилища, а также предоставляет следующие методы для поиска проблем:<itemizedlist>
            <listitem>
              <para><code>findOrphanDescriptors()</code> - найти в базе данных все экземпляры <code>FileDescriptor</code>, для которых не имеется соответствующего файла в хранилище.</para>
            </listitem>
            <listitem>
              <para><code>findOrphanFiles()</code> - найти файлы в хранилище, для которых не имеется соответствующего экземпляра <code>FileDescriptor</code> в БД.</para>
            </listitem>
          </itemizedlist></para>
      </section>
    </section>
    <section id="queryRunner">
      <title>Выполнение SQL с помощью QueryRunner</title>
      <para><code>QueryRunner</code> - класс, предназначенный для выполнения SQL. Его следует использовать вместо <application>JDBC</application> везде, где есть необходимость работы с SQL и нежелательно применение аналогичных <link linkend="nativeQuery">средств ORM</link>. </para>
      <para>QueryRunner платформы является вариантом <ulink url="http://commons.apache.org/dbutils/apidocs/org/apache/commons/dbutils/QueryRunner.html">Apache DbUtils QueryRunner</ulink>, усовершенствованным для использования Java Generics.</para>
      <para>Пример использования: <programlisting>

QueryRunner runner = new QueryRunner(persistence.getDataSource());
try {
    Set&lt;String&gt; scripts = runner.query(&quot;select SCRIPT_NAME from SYS_DB_CHANGELOG&quot;,
            new ResultSetHandler&lt;Set&lt;String&gt;&gt;() {
                public Set&lt;String&gt; handle(ResultSet rs) throws SQLException {
                    Set&lt;String&gt; rows = new HashSet&lt;String&gt;();
                    while (rs.next()) {
                        rows.add(rs.getString(1));
                    }
                    return rows;
                }
            });
    return scripts;
} catch (SQLException e) {
    throw new RuntimeException(e);
}</programlisting></para>
      <para>Есть два варианта использования <code>QueryRunner</code> - либо в текущей транзакции, либо в отдельной в режиме autocommit.<itemizedlist>
          <listitem>
            <para>Для выполнения запроса в текущей транзакции необходимо  создать экземпляр <code>QueryRunner</code> конструктором без параметров, не передавая <code>DataSource</code>. После этого нужно вызывать методы <code>query()</code> или <code>update()</code>, передавая в них <code>Connection</code>, полученный вызовом <code>EntityManager.getConnection()</code>. После выполнения закрывать <code>Connection</code> не нужно, он будет закрыт при коммите транзакции. </para>
          </listitem>
          <listitem>
            <para>Для выполнения запроса в отдельной транзакции необходимо создать экземпляр <code>QueryRunner</code> конструктором с параметром <code>DataSource</code>, получив экземпляр <code>DataSource</code> вызовом <code>Persistence.getDataSource()</code>. После этого нужно вызывать методы <code>query()</code> или <code>update()</code> без передачи какого-либо <code>Connection</code>, оно будет создано из указанного <code>DataSource</code> и затем сразу закрыто.</para>
          </listitem>
        </itemizedlist> </para>
    </section>
    <section>
      <title>Интеграция с MyBatis</title>
      <para>В состав платформы включен фреймворк <ulink url="http://www.mybatis.org">MyBatis</ulink>, обладающий, по сравнению с <link linkend="nativeQuery">ORM</link> и <link linkend="queryRunner">QueryRunner</link>,  более  широкими возможностями по выполнению SQL и отображению результатов на объекты предметной области.</para>
      <para>Для использование MyBatis в проекте необходимо добавить следующие бины в файл <filename>
          <link linkend="spring.xml">spring.xml</link>
        </filename> модуля <structname>core</structname>:<programlisting>&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;property name=&quot;configLocation&quot; value=&quot;cuba-mybatis.xml&quot;/&gt;
    &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath*:com/sample/sales/core/sqlmap/*.xml&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt;
    &lt;constructor-arg index=&quot;0&quot; ref=&quot;sqlSessionFactory&quot; /&gt;
&lt;/bean&gt;</programlisting></para>
      <para>В параметре <code>mapperLocations</code> задается путь (по правилам интерфейса <code>ResourceLoader</code> <application>Spring</application>)  к файлам отображений <application>MyBatis</application>. </para>
      <para>Пример файла отбражения для загрузки экземпляра сущности <code>Заказ</code> вместе со связанным <code>Покупателем</code> и коллекцией <code>Пунктов заказа</code>:<programlisting>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.sample.sales&quot;&gt;

    &lt;select id=&quot;selectOrder&quot; resultMap=&quot;orderResultMap&quot;&gt;
        select
            o.ID as order_id,
            o.DATE as order_date,
            o.AMOUNT as order_amount,
            c.ID as customer_id,
            c.NAME as customer_name,
            c.EMAIL as customer_email,
            i.ID as item_id,
            i.QUANTITY as item_quantity,
            p.ID as product_id,
            p.NAME as product_name    
        from
            SALES_ORDER o
            left join SALES_CUSTOMER c on c.ID = o.CUSTOMER_ID
            left join SALES_ITEM i on i.ORDER_ID = o.id and i.DELETE_TS is null
            left join SALES_PRODUCT p on p.ID = i.PRODUCT_ID
        where
            c.id = #{id}
    &lt;/select&gt;

    &lt;resultMap id=&quot;orderResultMap&quot; type=&quot;com.sample.sales.entity.Order&quot;&gt;
        &lt;id property=&quot;id&quot; column=&quot;order_id&quot;/&gt;
        &lt;result property=&quot;date&quot; column=&quot;order_date&quot;/&gt;
        &lt;result property=&quot;amount&quot; column=&quot;order_amount&quot;/&gt;

        &lt;association property=&quot;customer&quot; column=&quot;customer_id&quot; javaType=&quot;com.sample.sales.entity.Customer&quot;&gt;
            &lt;id property=&quot;id&quot; column=&quot;customer_id&quot;/&gt;
            &lt;result property=&quot;name&quot; column=&quot;customer_name&quot;/&gt;
            &lt;result property=&quot;email&quot; column=&quot;customer_email&quot;/&gt;
        &lt;/association&gt;

        &lt;collection property=&quot;items&quot; ofType=&quot;com.sample.sales.entity.Item&quot;&gt;
            &lt;id property=&quot;id&quot; column=&quot;item_id&quot;/&gt;
            &lt;result property=&quot;quantity&quot; column=&quot;item_quantity&quot;/&gt;
            &lt;association property=&quot;product&quot; column=&quot;product_id&quot; javaType=&quot;com.sample.sales.entity.Product&quot;&gt;
                &lt;id property=&quot;id&quot; column=&quot;product_id&quot;/&gt;
                &lt;result property=&quot;name&quot; column=&quot;product_name&quot;/&gt;
            &lt;/association&gt;
        &lt;/collection&gt;
    &lt;/resultMap&gt;

&lt;/mapper&gt;</programlisting></para>
      <para>Для получения результатов запроса в приведенном выше примере можно использовать следующий код:<programlisting>Transaction tx = persistence.createTransaction();
try {
    SqlSession sqlSession = AppBeans.get(&quot;sqlSession&quot;);
    Order order = (Order) sqlSession.selectOne(&quot;com.sample.sales.selectOrder&quot;, orderId);
    tx.commit();
} finally {
    tx.end();
}</programlisting></para>
      <tip>
        <para>Объекты, загруженные с помощью <application>MyBatis</application>, можно изменять и передавать в <code>EntityManager.merge()</code> для сохранения в базе данных. При этом в апдейт будут включены только не-<code>null</code> атрибуты, то есть если атрибут не был загружен, или специально установлен в значение <code>null</code>, соответствующее поле в БД не будет изменено.</para>
        <para>Такое поведение определяется параметром ORM <code>openjpa.DetachState=loaded</code>, установленным по умолчанию.</para>
      </tip>
    </section>
    <section id="folders_pane">
      <title>Панель папок</title>
      <para>Панель папок предназначена для быстрого доступа пользователя к часто используемой информации. Она представляет собой скрываемую панель в левой части главного окна приложения, в которой располагается иерархическая структура, нажатие на элементы которой (папки) приводит к отображению соответствующих экранов системы с определенными параметрами.</para>
      <para id="">На момент написания данного руководства панель папок реализована  только для <link linkend="app_tiers">Web Client</link>. </para>
      <para id="">Платформа поддерживает три вида папок: <firstterm>папки приложения</firstterm>, <firstterm>папки поиска</firstterm> и <firstterm>наборы</firstterm> записей. Папки приложения отображаются в верхней части панели в отдельной иерархии, папки поиска и наборы - в нижней части панели в совместной иерархии. <itemizedlist>
          <listitem>
            <para>Папки приложения:<itemizedlist>
                <listitem>
                  <para>Открывают  экраны с <link linkend="gui_Filter">фильтром</link> или без него.</para>
                </listitem>
                <listitem>
                  <para>Набор папок может зависеть от текущего сеанса пользователя. Видимость конкретной папки определяется путем выполнения скрипта Groovy.</para>
                </listitem>
                <listitem>
                  <para>Пользователь может создавать или изменять папки приложения, только если у него есть специальное право.</para>
                </listitem>
                <listitem>
                  <para>В заголовке папки может отображаться текущее количество входящих в папку записей, вычисляемое скриптом Groovy. </para>
                </listitem>
                <listitem>
                  <para>Заголовки папок приложения обновляются по таймеру, тем самым может изменяться счетчик записей и стиль отображения каждой папки.</para>
                </listitem>
              </itemizedlist></para>
          </listitem>
          <listitem>
            <para>Папки поиска:<itemizedlist>
                <listitem>
                  <para>Открывают экраны с <link linkend="gui_Filter">фильтром</link>. </para>
                </listitem>
                <listitem>
                  <para>Могут быть как локальными - доступными только пользователю, их создавшему, так и глобальными - доступными всем пользователям.</para>
                </listitem>
                <listitem>
                  <para>Локальные папки может создавать и изменять любой пользователь, глобальные - только имеющий специальное право.</para>
                </listitem>
              </itemizedlist></para>
          </listitem>
          <listitem>
            <para>Наборы: <itemizedlist>
                <listitem>
                  <para>Открывают экраны с <link linkend="gui_Filter">фильтром</link>, содержащим условие отбора отдельных записей по их идентификаторам.</para>
                </listitem>
                <listitem>
                  <para>Содержимое набора редактируется с помощью специальных <link linkend="gui_Action">действий</link> таблицы: <guibutton>Добавить в набор</guibutton>, <guibutton>Удалить из набора</guibutton>.</para>
                </listitem>
                <listitem>
                  <para>Наборы локальны, то есть доступны только создавшему их пользователю.</para>
                </listitem>
              </itemizedlist></para>
          </listitem>
        </itemizedlist></para>
      <para>На функционирование панели папок влияют следующие свойства приложения:<itemizedlist>
          <listitem>
            <para><link linkend="cuba.web.foldersPaneEnabled">
                <property>cuba.web.foldersPaneEnabled</property>
              </link></para>
          </listitem>
          <listitem>
            <para><link linkend="cuba.web.foldersPaneVisibleByDefault">
                <property>cuba.web.foldersPaneVisibleByDefault</property>
              </link></para>
          </listitem>
          <listitem>
            <para><link linkend="cuba.web.foldersPaneDefaultWidth">
                <property>cuba.web.foldersPaneDefaultWidth</property>
              </link></para>
          </listitem>
          <listitem>
            <para><link linkend="cuba.web.appFoldersRefreshPeriodSec">
                <property>cuba.web.appFoldersRefreshPeriodSec</property>
              </link></para>
          </listitem>
          <listitem>
            <para><link linkend="cuba.web.showFolderIcons">
                <property>cuba.web.showFolderIcons</property>
              </link></para>
          </listitem>
        </itemizedlist></para>
      <section>
        <title>Папки приложения</title>
        <para>Для создания папок приложения пользователь должен иметь специфическое право <guilabel>Создание/изменение папок приложения</guilabel> (код <literal>cuba.gui.appFolder.global</literal>).</para>
        <para>Простейшая папка приложения может быть создана из контекстного меню панели папок. Такая папка не связана с экранами системы и предназначена только для группировки других папок в иерархии.</para>
        <para>Для создания папки, открывающей некоторый экран с фильтром, необходимо выполнить следующее:<itemizedlist>
            <listitem>
              <para>Открыть экран и отобрать записи по нужному фильтру.</para>
            </listitem>
            <listitem>
              <para>В меню кнопки <guibutton>Фильтр...</guibutton> выбрать команду <guimenuitem>Сохранить как папку приложения</guimenuitem>.</para>
            </listitem>
            <listitem>
              <para>В окне добавления заполнить атрибуты папки:<itemizedlist>
                  <listitem>
                    <para>Наименование папки</para>
                  </listitem>
                  <listitem>
                    <para>Заголовок окна - строка, добавляемая к заголовку окна, когда он открывается из папки</para>
                  </listitem>
                  <listitem>
                    <para>Родительская папка - определяет место создаваемой папки в иерархии</para>
                  </listitem>
                  <listitem>
                    <para>Скрипт видимости - скрипт Groovy, выполняемый в начале сеанса пользователя, и определяющий доступность для него данной папки. </para>
                    <para>Скрипт должен вернуть булевское значение. Если скрипт не задан, либо возвращает null, папка доступна. Пример:<programlisting>userSession.currentOrSubstitutedUser.login == &apos;admin&apos;</programlisting></para>
                  </listitem>
                  <listitem>
                    <para>Cкрипт количества - скрипт Groovy, выполняемый в начале сеанса пользователя и по таймеру, для вычисления количества записей для данной папки и ее стиля отображения.</para>
                    <para>Скрипт должен вернуть числовое значение, целая часть которого будет использована в качестве счетчика. Если скрипт не задан, либо возвращает <code>null</code>, счетчик не будет отображаться. Кроме возвращаемого значения скрипт может установить переменную <code>style</code>, которая будет использована как имя стиля отображения папки. Пример:<programlisting>import com.haulmont.cuba.core.EntityManager
import com.haulmont.cuba.core.Query

EntityManager em = persistence.getEntityManager()
Query q = em.createQuery(&apos;select count(o) from sales$Order o&apos;)
Number count = q.getSingleResult()

style = count &gt; 0 ? &apos;emphasized&apos; : null
return count</programlisting></para>
                    <para>Для отображения указанного скриптом стиля тема приложения должна содержать описание этого стиля для элемента  <code>v-tree-node</code> внутри  <code>folderspane</code>, например:<programlisting>.folderspane .v-tree-node.emphasized {
    font-weight: bold;
}</programlisting></para>
                  </listitem>
                </itemizedlist></para>
            </listitem>
          </itemizedlist></para>
        <para>В скриптах доступны следующие переменные, установленные в контексте <code>groovy.lang.Binding</code>:<itemizedlist>
            <listitem>
              <para><code>folder</code>  - экземпляр сущности <code>AppFolder</code> - папка, для которой выполняется скрипт</para>
            </listitem>
            <listitem>
              <para><code>userSession</code> - экземпляр <code>UserSession</code> - текущая <link linkend="userSession">пользовательская сессия</link> </para>
            </listitem>
            <listitem>
              <para><code>persistence</code> - реализация интерфейса <link linkend="persistence">
                  <code>Persistence</code>
                </link></para>
            </listitem>
            <listitem>
              <para><code>metadata</code> - реализация интерфейса <link linkend="metadata">
                  <code>Metadata</code>
                </link></para>
            </listitem>
          </itemizedlist>При обновлении папок для всех скриптов используется один экземпляр <code>groovy.lang.Binding</code>, поэтому между ними можно передавать переменные для исключения дублирующихся запросов и повышения производительности. </para>
        <para>Тексты скриптов могут содержаться либо непосредственно в атрибутах сущности <code>AppFolder</code>, либо в отдельных файлах. В последнем случае атрибут должен содержать путь к файлу скрипта (обязательно с расширением &quot;.groovy&quot;) по правилам интерфейса <code>
            <link linkend="resources">Resources</link>
          </code>. Таким образом, если содержимое атрибута представляет собой строку, заканчивающуюся на &quot;.groovy&quot;, текст скрипта загружается из указанного файла, в противном случае в качестве скрипта используется само содержимое атрибута.</para>
        <para>Папки приложения представляют собой экземпляры сущности <code>AppFolder</code> и хранятся в связанных таблицах <database>SYS_FOLDER</database> и <database>SYS_APP_FOLDER</database>.</para>
      </section>
      <section>
        <title>Папки поиска</title>
        <para>Папки поиска создаются пользователями аналогично папкам приложения - группирующие папки непосредственно из контекстного меню панели папок, связанные с экранами - из меню кнопки <guibutton>Фильтр...</guibutton> экрана командой <guimenuitem>Сохранить как папку поиска</guimenuitem>.</para>
        <para>Для создания глобальной папки пользователь должен иметь специфическое право <guilabel>Создание/изменение глобальных папок поиска</guilabel> (код <literal>cuba.gui.searchFolder.global</literal>). </para>
        <para>Фильтр папки поиска можно изменить после ее создания - для этого достаточно открыть папку и  в экране изменить фильтр <guilabel>Папка: {имя папки}</guilabel>. После сохранения фильтра он будет изменен и в папке тоже.</para>
        <para>Папки поиска  представляют собой экземпляры сущности <code>SearchFolder</code> и хранятся в связанных таблицах <database>SYS_FOLDER</database> и <database>SEC_SEARCH_FOLDER</database>.</para>
      </section>
      <section>
        <title>Наборы</title>
        <para>Использование наборов в экране возможно, если для компонента <code>
            <link linkend="gui_Filter">Filter</link>
          </code> в атрибуте <sgmltag>applyTo</sgmltag> указан соответствующий компонент <code>
            <link linkend="gui_Table">Table</link>
          </code>. Например:<programlisting>&lt;layout&gt;
    &lt;filter id=&quot;customerFilter&quot; 
            datasource=&quot;customersDs&quot; 
            applyTo=&quot;customersTable&quot;/&gt;

    &lt;groupTable id=&quot;customersTable&quot; 
                width=&quot;100%&quot;&gt;
        &lt;buttonsPanel&gt;
            &lt;button action=&quot;customersTable.create&quot;/&gt;
...
        &lt;/buttonsPanel&gt;
...</programlisting></para>
        <para>При этом в контекстном меню таблицы появятся команды <guibutton>Добавить в набор</guibutton> или <guibutton>Добавить в тек. набор</guibutton> / <guibutton>Удалить из набора</guibutton>. Если таблица содержит внутри себя компонент <sgmltag>buttonsPanel</sgmltag> (как в приведенном выше примере), команды контекстного меню будут продублированы соответствующими кнопками.</para>
        <para>Наборы  представляют собой экземпляры сущности <code>SearchFolder</code> и хранятся в связанных таблицах <database>SYS_FOLDER</database> и <database>SEC_SEARCH_FOLDER</database>.</para>
      </section>
    </section>
    <section>
      <title>Инспектор сущностей</title>
      <para>Инспектор сущностей позволяет работать с любыми объектами предметной области без создания специфических экранов. Инспектор динамически генерирует экраны просмотра списка и редактирования экземпляра выбранной сущности.</para>
      <para>Это дает возможность администратору системы просматривать и редактировать данные, которые недоступны в стандартных экранах в силу их дизайна, а  на этапе прототипирования создать только модель данных и пункты главного меню, ссылающиеся на инспектор сущностей.</para>
      <para>Точкой входа в инспектор является экран <filename>com/haulmont/cuba/gui/app/core/entityinspector/entity-inspector-browse.xml</filename>. </para>
      <para>Если в экран передан параметр <code>entity</code> типа <code>String</code> с именем сущности, то инспектор отобразит список экземпляров этой сущности с возможностью фильтрации, выбора и редактирования экземпляров. Параметр может быть указан при регистрации экрана в <link linkend="screens.xml">
          <filename>screens.xml</filename>
        </link>, например:</para>
      <para><filename>screens.xml</filename><programlisting>&lt;screen id=&quot;sales$Product.lookup&quot; 
        template=&quot;/com/haulmont/cuba/gui/app/core/entityinspector/entity-inspector-browse.xml&quot;&gt;
    &lt;param name=&quot;entity&quot; 
           value=&quot;sales$Product&quot;/&gt;
&lt;/screen&gt;</programlisting></para>
      <para><filename>menu.xml</filename><programlisting>&lt;item id=&quot;sales$Product.lookup&quot;/&gt;</programlisting></para>
      <para>Идентификатор экрана вида <code>{имя_сущности}.lookup</code>  дает возможность использовать этот экран компонентам <code>
          <link linkend="gui_PickerField">PickerField</link>
        </code> и <code>
          <link linkend="gui_LookupPickerField">LookupPickerField</link>
        </code> в стандартном действии <code>PickerField.LookupAction</code>.</para>
      <para>В общем случае данный экран можно вызывать без передачи параметров, тогда в его верхней части отображается поле для выбора сущности. В базовом проекте <structname>cuba</structname> экран инспектора зарегистрирован с идентификатором <code>entityInspector.browse</code>, поэтому для его вызова достаточно наличия пункта меню:<programlisting>&lt;item id=&quot;entityInspector.browse&quot;/&gt;</programlisting></para>
    </section>
    <section id="credits">
      <title>Информация об используемом ПО</title>
      <para>Платформа предоставляет средства для регистрации и отображения в пользовательском интерфейсе информации об используемом в приложении стороннем программном обеспечении (credits). Информация включает в себя название, ссылку на веб-сайт и текст лицензии.</para>
      <para><link linkend="base_projects">Базовые проекты</link> платформы содержат собственные файлы описаний <filename>cuba-credits.xml</filename>, <filename>reports-credits.xml</filename> и т.д. В проекте приложения можно создать аналогичный файл и в свойстве приложения <property>
          <link linkend="cuba.creditsConfig">cuba.creditsConfig</link>
        </property> определить список файлов описаний в зависимости от используемых базовых проектов.</para>
      <para>Структура файла <filename>credits.xml</filename>: <itemizedlist>
          <listitem>
            <para>Элемент <sgmltag>items</sgmltag> - перечисление используемых библиотек с указанием текста лицензии либо во вложенном элементе <sgmltag>license</sgmltag>, либо атрибутом <sgmltag>license</sgmltag> со ссылкой на текст в секции <sgmltag>licenses</sgmltag>.</para>
            <para>Cсылаться можно на лицензии, объявленные не только в этом же файле, но и в любом другом файле, объявленном в переменной <property>cuba.creditsConfig</property> раньше, чем текущий. </para>
          </listitem>
          <listitem>
            <para>Элемент <sgmltag>licenses</sgmltag> - перечисление текстов общеупотребительных лицензий.</para>
          </listitem>
        </itemizedlist></para>
      <para>Для отображения общего списка используемого ПО  предназначен фрейм <filename>com/haulmont/cuba/gui/app/core/credits/credits-frame.xml</filename>, загружающий информацию из файлов, заданных в свойстве <property>cuba.creditsConfig</property>. Пример использования фрейма в экране:<programlisting>&lt;layout expand=&quot;creditsBox&quot;&gt;
    &lt;groupBox id=&quot;creditsBox&quot; 
              caption=&quot;msg://credits&quot; 
              width=&quot;100%&quot;&gt;
        &lt;iframe id=&quot;credits&quot; 
                src=&quot;/com/haulmont/cuba/gui/app/core/credits/credits-frame.xml&quot; 
                width=&quot;100%&quot; 
                height=&quot;100%&quot;/&gt;
    &lt;/groupBox&gt;
&lt;/layout&gt;</programlisting></para>
      <para>Если экран с фреймом открывается в модальном режиме (<code>WindowManager.OpenType.DIALOG</code>), ему необходимо задать высоту, иначе возможна неправильная работа скроллинга. Это можно сделать, например, в контроллере экрана, выводящего фрейм: <programlisting>@Override
public void init(Map&lt;String, Object&gt; params) {
    getDialogParams().setWidth(500).setHeight(400);
}</programlisting></para>
    </section>
  </section>
  <section id="extension">
    <title>Расширение функциональности </title>
    <para>Платформа позволяет расширять и переопределять свою функциональность в приложениях в следующих аспектах:
<itemizedlist>
        <listitem>
          <para>расширение набора атрибутов сущностей</para>
        </listitem>
        <listitem>
          <para>расширение функциональности экранов</para>
        </listitem>
        <listitem>
          <para>расширение и переопределение бизнес-логики, сосредоточенной в  бинах <application>Spring</application> </para>
        </listitem>
      </itemizedlist></para>
    <para>Рассмотрим две первые задачи на примере добавления поля &quot;Адрес&quot; в сущность <code>User</code> подсистемы безопасности платформы. </para>
    <section id="entity_extension">
      <title>Расширение сущности</title>
      <para>Создадим в проекте приложения класс сущности, унаследованный от <code>com.haulmont.cuba.security.entity.User</code> и добавим в него требуемый атрибут с соответствующими методами доступа: <programlisting>@Entity(name = &quot;sales$User&quot;)
@Extends(User.class)
public class ExtUser extends User {
    
    @Column(name = &quot;ADDRESS&quot;, length = 100)
    private String address;

    public String getAddress() {
        return address;
    }

    public void setAddress(String address) {
        this.address = address;
    }
}</programlisting></para>
      <para>В аннотации <code>
          <link linkend="entity_annotation">@Entity</link>
        </code> должно быть указано новое имя сущности. Так как базовая сущность не объявляет <link linkend="inheritance_annotation">стратегию наследования</link>, то по умолчанию это <code>SINGLE_TABLE</code>. Это означает, что унаследованная сущность будет хранится в той же таблице, что и базовая, и аннотация <code>
          <link linkend="table_annotation">@Table</link>
        </code> не требуется. Другие аннотации базовой сущности - <code>
          <link linkend="namePattern">@NamePattern</link>
        </code>, <code>
          <link linkend="listeners_annotation">@Listeners</link>
        </code> и прочие - автоматически применяются к расширяющей сущности, но могут быть переопределены в ее классе.  </para>
      <para>Важным элементом класса новой сущности является аннотация <code>@Extends</code> с базовым классом в качестве параметра. Она позволяет сформировать реестр расширяющих сущностей, и заставить механизмы платформы использовать их повсеместно вместо базовых. Реестр реализуется классом <code>ExtendedEntities</code>, который является бином <application>Spring</application> с именем <code>cuba_ExtendedEntities</code>, и доступен также через интерфейс <code>
          <link linkend="metadata">Metadata</link>
        </code>.</para>
      <para>Добавим локализованное название нового атрибута в <link linkend="message_packs">пакет</link> <code>com.sample.sales.entity</code>:</para>
      <para><filename>messages.properties</filename><programlisting>ExtUser.address=Address</programlisting></para>
      <para><filename>messages_ru.properties</filename><programlisting>ExtUser.address=Адрес</programlisting></para>
      <para>Зарегистрируем новую сущность в файле <filename>
          <link linkend="persistence.xml">persistence.xml</link>
        </filename> проекта:<programlisting>&lt;class&gt;com.sample.sales.entity.ExtUser&lt;/class&gt;</programlisting></para>
      <para>Добавим в <link linkend="db_scripts">скрипты создания и обновления базы данных</link> команду модификации соответствующей таблицы:<programlisting>alter table SEC_USER add ADDRESS varchar(100)</programlisting></para>
    </section>
    <section>
      <title>Расширение экранов</title>
      <para>Платформа позволяет создавать новые <link linkend="screen_xml">XML-дескрипторы</link> экранов путем наследования от существующих.</para>
      <para>Наследование XML выполняется путем указания в корневом элементе <sgmltag>window</sgmltag> атрибута <sgmltag>extends</sgmltag>, содержащего путь к базовому дескриптору.</para>
      <para>Правила переопределения элементов XML экрана:<itemizedlist>
          <listitem>
            <para>Если в расширяющем дескрипторе указан некоторый элемент, в базовом дескрипторе будет произведен поиск соответствующего элемента по следующему алгоритму:<itemizedlist>
                <listitem>
                  <para>Если переопределяющий элемент - <sgmltag>view</sgmltag>, то ищется соответствующий элемент по атрибутам <sgmltag>name</sgmltag>, <sgmltag>class</sgmltag>, <sgmltag>entity</sgmltag>.</para>
                </listitem>
                <listitem>
                  <para>Если переопределяющий элемент - <sgmltag>property</sgmltag>, то ищется соответствующий элемент по атрибуту <sgmltag>name</sgmltag>.</para>
                </listitem>
                <listitem>
                  <para>В других случаях, если в переопределяющем элементе указан атрибут <sgmltag>id</sgmltag>, ищется соответствующий элемент с таким же <sgmltag>id</sgmltag>. </para>
                </listitem>
                <listitem>
                  <para role="bold">Если поиск дал результат, то  найденный элемент <emphasis role="bold">переопределяется</emphasis>.</para>
                </listitem>
                <listitem>
                  <para>Если поиск не дал результата, то определяется сколько в базовом дескрипторе элементов по данному пути и с данным именем. Если ровно один - он <emphasis role="bold">переопределяется</emphasis>.</para>
                </listitem>
                <listitem>
                  <para>Если поиск не дал результата, и в базовом дескрипторе по данному пути с данным именем нет элементов либо их больше одного, <emphasis role="bold">добавляется</emphasis> новый элемент.</para>
                </listitem>
              </itemizedlist></para>
          </listitem>
          <listitem>
            <para>В переопределяемом либо добавляемом элементе устанавливается текст из расширяющего элемента. </para>
          </listitem>
          <listitem>
            <para>В переопределяемый либо добавляемый элемент копируются все атрибуты из расширяющего элемента. При совпадении имени атрибута значение берется из расширяющего элемента.</para>
          </listitem>
          <listitem>
            <para>Добавление нового элемента по умолчанию производится в конец списка соседних элементов. Чтобы добавить новый элемент в начало или с произвольным индексом, необходимо выполнить следующее: <itemizedlist>
                <listitem>
                  <para>определить в расширяющем дескрипторе дополнительный namespace: <code>xmlns:ext=&quot;http://schemas.haulmont.com/cuba/4.0/window-ext.xsd&quot;</code></para>
                </listitem>
                <listitem>
                  <para>добавить в расширяющий элемент атрибут <sgmltag>ext:index</sgmltag> с желаемым индексом, например: <code>ext:index=&quot;0&quot;.</code></para>
                </listitem>
              </itemizedlist></para>
          </listitem>
        </itemizedlist></para>
      <para>Для отладки преобразования дескрипторов можно включить вывод в журнал сервера результирующего XML. Делается это путем указания уровня <code>TRACE</code> для логгера <code>com.haulmont.cuba.gui.xml.XmlInheritanceProcessor</code> в файле конфигурации <application>Log4j</application>:<programlisting>&lt;appender name=&quot;FILE&quot; ...
        &lt;param name=&quot;Threshold&quot; value=&quot;TRACE&quot;/&gt;
...        
&lt;category name=&quot;com.haulmont.cuba.gui.xml.XmlInheritanceProcessor&quot;&gt;
    &lt;priority value=&quot;TRACE&quot;/&gt;
&lt;/category&gt;</programlisting></para>
      <para>Пример XML-дескриптора экрана браузера сущностей <code>ExtUser</code>:<programlisting>&lt;window xmlns=&quot;http://schemas.haulmont.com/cuba/4.0/window.xsd&quot;
        xmlns:ext=&quot;http://schemas.haulmont.com/cuba/4.0/window-ext.xsd&quot;
        extends=&quot;/com/haulmont/cuba/gui/app/security/user/browse/user-browse.xml&quot;&gt;
    &lt;layout&gt;
        &lt;groupTable id=&quot;usersTable&quot;&gt;
            &lt;columns&gt;
                &lt;column id=&quot;address&quot; ext:index=&quot;2&quot;/&gt;
            &lt;/columns&gt;
        &lt;/groupTable&gt;
    &lt;/layout&gt;
&lt;/window&gt;</programlisting></para>
      <para>В данном примере дескриптор унаследован от стандартного браузера сущностей <code>User</code> платформы, и в таблицу добавлена колонка <code>address</code> с индексом <code>2</code>, т.е. отображающаяся после <code>login</code> и <code>name</code>.</para>
      <para>Зарегистрируем новый экран в <filename>
          <link linkend="screens.xml">screens.xml</link>
        </filename> с теми же идентификаторами, которые использовались для базового экрана. После этого новый экран будет повсеместно вызываться взамен старого.<programlisting>&lt;screen id=&quot;sec$User.browse&quot;
        template=&quot;com/sample/sales/gui/extuser/extuser-browse.xml&quot;/&gt;
&lt;screen id=&quot;sec$User.lookup&quot;
        template=&quot;com/sample/sales/gui/extuser/extuser-browse.xml&quot;/&gt;</programlisting></para>
      <para>Аналогично создаем экран редактирования:<programlisting>&lt;window xmlns=&quot;http://schemas.haulmont.com/cuba/4.0/window.xsd&quot;
        xmlns:ext=&quot;http://schemas.haulmont.com/cuba/4.0/window-ext.xsd&quot;
        extends=&quot;/com/haulmont/cuba/gui/app/security/user/edit/user-edit.xml&quot;&gt;
    &lt;layout&gt;
        &lt;fieldGroup id=&quot;fieldGroup&quot;&gt;
            &lt;column id=&quot;fieldGroupColumn2&quot;&gt;
                &lt;field id=&quot;address&quot; ext:index=&quot;4&quot;/&gt;
            &lt;/column&gt;
        &lt;/fieldGroup&gt;
    &lt;/layout&gt;
&lt;/window&gt;</programlisting></para>
      <para>Регистрируем его в <filename>screens.xml</filename> с идентификатором базового экрана:<programlisting>&lt;screen id=&quot;sec$User.edit&quot;
        template=&quot;com/sample/sales/gui/extuser/extuser-edit.xml&quot;/&gt;</programlisting></para>
      <para>После выполнения описанных выше действий в приложении вместо платформенной сущности <code>User</code> будет использоваться <code>ExtUser</code> с соответствующими экранами.</para>
      <para>Контроллер экрана  может быть расширен путем создания нового класса, унаследованного от контроллера базового экрана. Имя класса указывается в атрибуте <sgmltag>class</sgmltag> корневого элемента расширяющего XML дескриптора, при этом выполняются обычные правила наследования XML, описанные выше. </para>
    </section>
    <section id="bean_extension">
      <title>Расширение бизнес-логики</title>
      <para>Основная часть бизнес-логики платформы сосредоточена в бинах <application>Spring</application>, что позволяет легко расширить или переопределить ее в приложении.</para>
      <para>Для подмены реализации бина достаточно создать свой класс, реализующий  интерфейс или расширяющий базовый класс платформы, и зарегистрировать его в <link linkend="spring.xml">
          <filename>spring.xml</filename>
        </link> приложения. Аннотацию <code>@ManagedBean</code> в расширяющем классе применять нельзя, переопределение бинов возможно только с помощью конфигурации в XML.</para>
      <para>Рассмотрим пример добавления метода в бин <link linkend="persistenceTools">
          <code>PersistenceTools</code>
        </link>.</para>
      <para>Создаем класс с нужным методом:<programlisting>public class ExtPersistenceTools extends PersistenceTools {

    public Entity reloadStartingTransaction(Entity entity, String... viewNames) {
        Transaction tx = persistence.createTransaction();
        try {
            Entity reloadedEntity = reloadEntity(entity, viewNames);
            tx.commit();
            return reloadedEntity;
        } finally {
            tx.end();
        }
    }
}</programlisting></para>
      <para>Регистрируем класс в <filename>spring.xml</filename> модуля <structname>core</structname> проекта с тем же идентификатором, что и бин платформы:<programlisting>&lt;bean id=&quot;cuba_PersistenceTools&quot; class=&quot;com.sample.sales.core.ExtPersistenceTools&quot;/&gt;</programlisting></para>
      <para>После этого контекст <application>Spring</application>  вместо экземпляра базового класса <code>PersistenceTools</code> будет всегда возвращать <code>ExtPersistenceTools</code>, например:<programlisting>Persistence persistence;
PersistenceTools tools;

persistence = AppBeans.get(Persistence.class);
tools = persistence.getTools();
assertTrue(tools instanceof ExtPersistenceTools);

tools = AppBeans.get(PersistenceTools.class);
assertTrue(tools instanceof ExtPersistenceTools);

tools = AppBeans.get(PersistenceTools.NAME);
assertTrue(tools instanceof ExtPersistenceTools);</programlisting></para>
    </section>
  </section>
</chapter>
